<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AMORE INSIGHT | AI-Powered Beauty Market Intelligence</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap');

        /* === ARITA FONT FAMILY (AMOREPACIFIC Corporate Font) === */
        @font-face {
            font-family: 'Arita Dotum';
            src: url('/fonts/AritaDotumKR-Thin.ttf') format('truetype');
            font-weight: 100;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Arita Dotum';
            src: url('/fonts/AritaDotumKR-Light.ttf') format('truetype');
            font-weight: 300;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Arita Dotum';
            src: url('/fonts/AritaDotumKR-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Arita Dotum';
            src: url('/fonts/AritaDotumKR-SemiBold.ttf') format('truetype');
            font-weight: 600;
            font-style: normal;
            font-display: swap;
        }
        @font-face {
            font-family: 'Arita Dotum';
            src: url('/fonts/AritaDotumKR-Bold.ttf') format('truetype');
            font-weight: 700;
            font-style: normal;
            font-display: swap;
        }

        /*
         * AMOREPACIFIC DESIGN SYSTEM
         * "Harmony of Contrast" - 대비의 조화
         * Amore (부드러움, 감성, 전통) + Pacific (강함, 이성, 미래)
         */
        :root {
            /* === AMOREPACIFIC CI COLORS === */
            --amore-blue: #1F5795;        /* 부드럽고 온화한 - 달 그림자 */
            --pacific-blue: #001C58;      /* 강하고 이지적인 - 깊은 바다 */
            --ap-black: #000000;
            --ap-gray: #7D7D7D;
            --ap-white: #FFFFFF;

            /* === FUNCTIONAL COLORS === */
            --success: #1F5795;           /* Amore Blue로 통일 */
            --warning: #C4A962;           /* 골드 톤 - 프리미엄 */
            --danger: #8B2635;            /* 깊은 레드 - 세련된 경고 */
            --info: #1F5795;

            /* === BACKGROUND === */
            --bg-main: #FAFAFA;
            --bg-card: #FFFFFF;
            --bg-subtle: #F5F5F5;

            /* === TEXT === */
            --text-primary: #001C58;      /* Pacific Blue */
            --text-secondary: #7D7D7D;    /* AP Gray */
            --text-light: #FFFFFF;

            /* === BORDERS & SHADOWS === */
            --border-light: #E8E8E8;
            --border-medium: #D0D0D0;
            --shadow-sm: 0 1px 3px rgba(0, 28, 88, 0.08);
            --shadow-md: 0 4px 12px rgba(0, 28, 88, 0.1);
            --shadow-lg: 0 8px 24px rgba(0, 28, 88, 0.12);

            /* === ARITA TYPOGRAPHY SCALE === */
            /* "단아하고 지적이며, 건강한 아름다움" */
            --font-xs: 9px;       /* AI label, 배지 */
            --font-sm: 11px;      /* 보조 텍스트, breadcrumb */
            --font-base: 13px;    /* 본문 기본 */
            --font-md: 14px;      /* 강조 본문 */
            --font-lg: 15px;      /* 소제목 */
            --font-xl: 16px;      /* 페이지 제목 */
            --font-2xl: 18px;     /* 섹션 타이틀 */

            /* === LETTER SPACING - 우아함을 위한 자간 === */
            --tracking-tight: -0.02em;    /* 본문 가독성 */
            --tracking-normal: 0;
            --tracking-wide: 0.5px;       /* 라벨 */
            --tracking-wider: 2px;        /* 대문자 라벨 */
            --tracking-widest: 3.5px;     /* 로고 워드마크 */

            /* === SPACING SCALE - 8px 베이스 === */
            --space-1: 4px;
            --space-2: 8px;
            --space-3: 12px;
            --space-4: 16px;
            --space-5: 20px;
            --space-6: 24px;
            --space-8: 32px;
            --space-10: 40px;

            /* === BORDER RADIUS - 부드러운 곡선 === */
            --radius-sm: 4px;     /* 배지, 작은 요소 */
            --radius-md: 6px;     /* 버튼, 탭 */
            --radius-lg: 8px;     /* 카드 */
            --radius-xl: 12px;    /* 채팅 버블 */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: 'Arita Dotum', 'Noto Sans KR', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-main);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            position: relative;
            font-weight: 400;
            letter-spacing: -0.02em;
        }

        .app-container { display: flex; height: 100vh; overflow: hidden; }

        /* === AMOREPACIFIC INSIGHT STYLES === */
        .insight-container {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            line-height: 1.8;
            color: var(--pacific-blue);
            font-size: 14px;
        }

        .insight-section-header {
            display: flex;
            align-items: center;
            margin: 24px 0 16px 0;
            font-size: 16px;
            font-weight: 700;
            color: var(--pacific-blue);
        }

        .insight-section-header::before {
            content: '';
            width: 4px;
            height: 20px;
            background: var(--pacific-blue);
            margin-right: 12px;
            border-radius: 2px;
            flex-shrink: 0;
        }

        .insight-layer-header {
            font-size: 14px;
            font-weight: 600;
            color: var(--amore-blue);
            margin: 16px 0 8px 0;
            padding-left: 16px;
            border-left: 2px solid var(--amore-blue);
        }

        .insight-metric-positive {
            color: var(--amore-blue);
            font-weight: 700;
        }

        .insight-metric-negative {
            color: var(--danger);
            font-weight: 700;
        }

        .insight-rank {
            color: var(--pacific-blue);
            font-weight: 700;
        }

        .insight-brand-name {
            font-weight: 700;
            color: var(--pacific-blue);
        }

        .insight-bullet {
            color: var(--pacific-blue);
        }

        .insight-sub-bullet {
            color: var(--text-secondary);
        }

        .insight-action-item {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(31, 87, 149, 0.04);
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .insight-action-priority {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 3px;
            font-weight: 500;
            flex-shrink: 0;
        }

        .insight-action-priority.high {
            background: rgba(139, 38, 53, 0.1);
            color: #8B2635;
        }

        .insight-action-priority.medium {
            background: rgba(196, 169, 98, 0.15);
            color: #8B7355;
        }

        .insight-action-priority.low {
            background: rgba(31, 87, 149, 0.1);
            color: #1F5795;
        }

        .insight-reference {
            font-size: 12px;
            color: var(--text-secondary);
            padding-left: 16px;
            margin: 4px 0;
        }

        .insight-reference a {
            color: var(--amore-blue);
            text-decoration: none;
        }

        .insight-reference a:hover {
            text-decoration: underline;
        }

        /* === SIDEBAR - Pacific Blue (강함, 이성, 미래) === */
        .sidebar {
            width: 240px;
            background: var(--pacific-blue);
            display: flex; flex-direction: column; flex-shrink: 0;
            z-index: 50;
        }
        /* === LOGO SECTION - ARITA Design Philosophy ===
         * "단아하고 지적이며, 건강한 아름다움"
         * 부드러움(Amore)과 강함(Pacific)의 대비 조화
         */
        .logo-section {
            padding: 0;
            background: var(--ap-white);
            position: relative;
        }
        .logo-section-inner {
            padding: 32px 20px 24px 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0;
        }
        /* AMOREPACIFIC Wordmark - 우아하고 단아한 타이포그래피 */
        .ap-wordmark {
            display: flex;
            align-items: baseline;
            gap: 0;
            letter-spacing: 2.5px;
        }
        .ap-wordmark-amore {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: var(--font-lg);
            font-weight: 500;
            color: var(--pacific-blue);
            letter-spacing: var(--tracking-widest);
        }
        .ap-wordmark-pacific {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: var(--font-lg);
            font-weight: 300;
            color: var(--pacific-blue);
            letter-spacing: var(--tracking-widest);
        }
        /* Subtle divider line - 섬세한 구분선 */
        .ap-divider-line {
            width: 48px;
            height: 1px;
            background: linear-gradient(90deg,
                transparent,
                var(--pacific-blue),
                transparent
            );
            margin: var(--space-4) 0 var(--space-3) 0;
            opacity: 0.25;
        }
        /* AI Intelligence Label - 지적이고 절제된 */
        .ai-label {
            font-size: var(--font-xs);
            color: var(--ap-gray);
            text-transform: uppercase;
            letter-spacing: 4px;
            font-weight: 400;
        }
        /* Elegant Gradient Transition - 자연스러운 흐름 */
        .logo-nav-divider {
            width: 100%;
            height: var(--space-10);
            background: linear-gradient(180deg,
                var(--ap-white) 0%,
                rgba(250,250,252,0.95) 20%,
                rgba(0,28,88,0.03) 45%,
                rgba(0,28,88,0.1) 70%,
                rgba(0,28,88,0.35) 88%,
                var(--pacific-blue) 100%
            );
            margin-top: var(--space-2);
        }
        /* Legacy styles - kept for compatibility */
        .logo { display: flex; align-items: center; gap: 14px; }
        .logo-icon {
            width: 36px; height: 36px;
            background: var(--amore-blue);
            border-radius: 8px;
            display: flex; align-items: center; justify-content: center;
            display: none; /* Hidden - 별 아이콘 제거 */
        }
        .logo-text { color: var(--ap-white); display: none; }
        .logo-text h1 {
            font-size: 15px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .logo-text span {
            font-size: 10px;
            opacity: 0.6;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: 400;
        }
        .nav-section { padding: 24px 16px; flex: 1; overflow-y: auto; }
        .nav-label {
            font-size: 10px;
            color: rgba(255,255,255,0.4);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            margin-bottom: 12px;
            padding-left: 12px;
            font-weight: 500;
        }
        .nav-item {
            display: flex; align-items: center; gap: var(--space-3);
            padding: var(--space-3) var(--space-4);
            border-radius: var(--radius-md);
            color: rgba(255,255,255,0.72);
            cursor: pointer;
            transition: all 0.2s ease;
            margin-bottom: var(--space-1);
            font-size: var(--font-base);
            font-weight: 400;
        }
        .nav-item:hover {
            background: rgba(255,255,255,0.08);
            color: rgba(255,255,255,0.95);
            box-shadow: inset 0 0 12px rgba(31, 87, 149, 0.12);
        }
        .nav-item.active {
            background: var(--amore-blue);
            color: var(--ap-white);
            font-weight: 500;
            box-shadow: 0 2px 8px rgba(31, 87, 149, 0.3);
        }
        .nav-divider {
            height: 1px;
            background: rgba(255,255,255,0.06);
            margin: 20px 0;
        }
        .channel-item {
            display: flex; align-items: center; justify-content: space-between;
            padding: 12px 16px;
            border-radius: 6px;
            color: rgba(255,255,255,0.7);
            font-size: 13px;
            background: rgba(255,255,255,0.04);
        }
        .channel-badge {
            font-size: 10px;
            background: var(--amore-blue);
            padding: 3px 10px;
            border-radius: 4px;
            color: white;
            font-weight: 500;
        }

        /* === MAIN - Clean & Professional === */
        .main-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
            z-index: 1;
            background: var(--bg-main);
        }
        .header {
            height: 64px;
            background: var(--ap-white);
            border-bottom: 1px solid rgba(0, 28, 88, 0.06);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 var(--space-8);
            flex-shrink: 0;
        }
        .header-left { display: flex; align-items: center; gap: var(--space-5); }
        .page-info h2 {
            font-size: var(--font-xl);
            font-weight: 600;
            color: var(--pacific-blue);
            letter-spacing: var(--tracking-tight);
        }
        .page-info .breadcrumb {
            font-size: var(--font-sm);
            color: var(--ap-gray);
            margin-top: 2px;
            letter-spacing: var(--tracking-wide);
        }
        .header-right { display: flex; align-items: center; gap: var(--space-3); }
        /* === CURRENCY SELECTOR === */
        .currency-selector {
            display: flex;
            background: var(--bg-subtle);
            border-radius: var(--radius-sm);
            padding: 2px;
            gap: 2px;
        }
        .currency-btn {
            padding: 5px 10px;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-size: var(--font-sm);
            font-weight: 500;
            border-radius: calc(var(--radius-sm) - 2px);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .currency-btn:hover {
            background: rgba(31, 87, 149, 0.1);
            color: var(--amore-blue);
        }
        .currency-btn.active {
            background: var(--amore-blue);
            color: var(--ap-white);
        }
        .exchange-rate-info {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: var(--font-xs);
            color: var(--text-secondary);
        }
        .exchange-rate-info .rate-badge {
            background: rgba(31, 87, 149, 0.08);
            padding: 3px 8px;
            border-radius: 10px;
            color: var(--amore-blue);
            font-weight: 500;
        }
        .exchange-rate-info .rate-time {
            opacity: 0.7;
        }
        /* Fallback 환율 경고 스타일 */
        .exchange-rate-info .rate-fallback {
            background: rgba(196, 169, 98, 0.15);
            color: #8B7355;
            border: 1px dashed #C4A962;
        }
        .exchange-rate-info .rate-warning {
            color: #C4A962;
            font-weight: 500;
        }
        @media (max-width: 768px) {
            .currency-selector { display: none; }
            .exchange-rate-info { display: none; }
        }

        .platform-badge {
            display: flex; align-items: center; gap: 6px;
            padding: 6px 14px;
            background: var(--pacific-blue);
            color: var(--ap-white);
            border-radius: var(--radius-sm);
            font-size: var(--font-sm);
            font-weight: 500;
            letter-spacing: 0.3px;
        }
        .export-btn {
            display: flex; align-items: center; gap: 6px;
            padding: 10px 18px;
            background: var(--amore-blue);
            color: var(--ap-white);
            border: none;
            border-radius: var(--radius-md);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .export-btn:hover {
            background: var(--pacific-blue);
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(31, 87, 149, 0.25);
        }
        /* === DATE/TIME DISPLAY - AMOREPACIFIC Style === */
        .time-display-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            align-items: flex-end;
        }
        .date-display {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 11px;
            color: var(--text-secondary);
            background: transparent;
            padding: 0;
            font-weight: 400;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .date-display .date-icon {
            width: 14px;
            height: 14px;
            color: var(--text-secondary);
        }
        .date-display .date-label {
            font-weight: 500;
            color: var(--pacific-blue);
            letter-spacing: 0.5px;
        }
        .date-display .date-value {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 11px;
            color: var(--text-secondary);
        }
        .current-time {
            color: var(--amore-blue);
        }
        .current-time .date-label {
            color: var(--amore-blue);
        }
        .current-time .date-value {
            color: var(--amore-blue);
        }

        /* === LOADING STATES === */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
        }
        .loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .loading-spinner {
            width: 48px;
            height: 48px;
            border: 3px solid var(--border-light);
            border-top-color: var(--amore-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .skeleton {
            background: linear-gradient(90deg, var(--bg-subtle) 25%, #e8e8e8 50%, var(--bg-subtle) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }
        @keyframes shimmer { 0% { background-position: -200% 0; } 100% { background-position: 200% 0; } }

        /* === TABLE SKELETON LOADING === */
        .promo-table-container.loading {
            position: relative;
            pointer-events: none;
        }
        .promo-table-container .skeleton-row td {
            padding: 12px 8px;
        }
        .promo-table-container .skeleton-cell {
            height: 16px;
            background: linear-gradient(90deg, var(--bg-subtle) 25%, #e8e8e8 50%, var(--bg-subtle) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }
        .promo-table tbody tr {
            transition: opacity 0.2s ease;
        }

        /* === CHART LOADING SKELETON === */
        .chart-container.loading {
            position: relative;
            pointer-events: none;
        }
        .chart-container.loading::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(90deg, var(--bg-subtle) 25%, #e8e8e8 50%, var(--bg-subtle) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            z-index: 10;
            border-radius: 8px;
        }

        /* === DATA SUMMARY CARD (날짜 변경 피드백) === */
        .data-summary-card {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 10px 16px;
            background: linear-gradient(135deg, rgba(0, 28, 88, 0.04) 0%, rgba(31, 87, 149, 0.06) 100%);
            border: 1px solid rgba(31, 87, 149, 0.12);
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 12px;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(-8px);
        }
        .data-summary-card.show {
            opacity: 1;
            transform: translateY(0);
        }
        .data-summary-card.updating {
            border-color: var(--amore-blue);
            box-shadow: 0 0 0 2px rgba(31, 87, 149, 0.15);
        }
        .data-summary-icon {
            width: 32px;
            height: 32px;
            background: var(--amore-blue);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .data-summary-content {
            flex: 1;
            display: flex;
            flex-wrap: wrap;
            gap: 8px 20px;
        }
        .data-summary-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .data-summary-label {
            color: var(--text-secondary);
        }
        .data-summary-value {
            font-weight: 600;
            color: var(--pacific-blue);
        }
        .data-summary-timestamp {
            font-size: 11px;
            color: var(--text-secondary);
            opacity: 0.8;
        }

        /* === IMPROVED CHART LOADING (최소 표시 시간 + 페이드 인) === */
        .chart-container {
            position: relative;
            transition: opacity 0.25s ease;
        }
        .chart-container.loading-fade {
            opacity: 0.5;
        }
        .chart-container.loading-complete {
            opacity: 1;
        }
        /* 차트 로딩 오버레이 - 웨이브 애니메이션 */
        .chart-loading-overlay {
            position: absolute;
            inset: 0;
            background: rgba(255, 255, 255, 0.85);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            border-radius: 8px;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
        }
        .chart-loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }
        .chart-loading-wave {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        .chart-loading-wave span {
            width: 4px;
            height: 20px;
            background: var(--amore-blue);
            border-radius: 2px;
            animation: chartWave 1.2s ease-in-out infinite;
        }
        .chart-loading-wave span:nth-child(2) { animation-delay: 0.1s; }
        .chart-loading-wave span:nth-child(3) { animation-delay: 0.2s; }
        .chart-loading-wave span:nth-child(4) { animation-delay: 0.3s; }
        .chart-loading-wave span:nth-child(5) { animation-delay: 0.4s; }
        @keyframes chartWave {
            0%, 100% { transform: scaleY(0.5); opacity: 0.5; }
            50% { transform: scaleY(1); opacity: 1; }
        }
        .chart-loading-text {
            font-size: 12px;
            color: var(--text-secondary);
            font-weight: 500;
        }

        /* === ERROR STATE === */
        .error-banner {
            background: rgba(139, 38, 53, 0.05);
            border: 1px solid rgba(139, 38, 53, 0.2);
            border-radius: 8px;
            padding: 16px 20px;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .error-banner.hidden { display: none; }
        .error-icon {
            width: 36px;
            height: 36px;
            background: rgba(139, 38, 53, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .error-content { flex: 1; }
        .error-title { font-size: 13px; font-weight: 600; color: var(--danger); margin-bottom: 4px; }
        .error-message { font-size: 12px; color: var(--text-secondary); }
        .error-action {
            padding: 6px 12px;
            background: var(--danger);
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .error-action:hover { background: #701f2a; }

        /* === ANIMATIONS === */
        @keyframes slideIn { from { opacity: 0; transform: translateX(20px); } to { opacity: 1; transform: translateX(0); } }
        @keyframes fadeSlideIn { from { opacity: 0; transform: translateY(8px); } to { opacity: 1; transform: translateY(0); } }

        .content-wrapper { flex: 1; display: flex; overflow: hidden; }
        .content-area {
            flex: 1;
            padding: 24px 32px;
            overflow-y: auto;
            background: var(--bg-main);
        }
        .page-view { display: none; animation: fadeSlideIn 0.3s ease; }
        .page-view.active { display: block; }

        /* === INSIGHT BANNER - Harmony of Contrast ===
         * AMOREPACIFIC Design Philosophy
         * "단아하고 지적이며, 건강한 아름다움"
         */
        .insight-banner {
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 0;
            margin-bottom: 24px;
            position: relative;
            overflow: hidden;
            display: flex;
        }
        /* 좌측 액센트 바 */
        .insight-banner::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
        }
        .insight-content {
            display: flex;
            align-items: stretch;
            flex: 1;
            position: relative;
            z-index: 1;
        }
        /* 좌측 브랜드 영역 */
        .insight-brand-area {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px 24px;
            background: linear-gradient(135deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            min-width: 140px;
        }
        .insight-brand-wordmark {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
        }
        .insight-brand-wordmark .amore {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 9px;
            font-weight: 600;
            color: rgba(255,255,255,0.9);
            letter-spacing: 2px;
        }
        .insight-brand-wordmark .pacific {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 9px;
            font-weight: 300;
            color: rgba(255,255,255,0.9);
            letter-spacing: 2px;
        }
        .insight-brand-divider {
            width: 24px;
            height: 1px;
            background: rgba(255,255,255,0.3);
            margin: 8px 0;
        }
        .insight-brand-label {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 10px;
            font-weight: 500;
            color: rgba(255,255,255,0.7);
            letter-spacing: 1px;
            text-transform: uppercase;
        }
        /* 우측 텍스트 영역 */
        .insight-text {
            flex: 1;
            padding: 20px 24px;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }
        .insight-label {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1.5px;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .insight-message {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            color: var(--pacific-blue);
            font-size: 14px;
            font-weight: 400;
            line-height: 1.7;
        }
        .insight-message strong {
            color: var(--amore-blue);
            font-weight: 700;
        }

        /* === STATUS CARDS - Clean & Professional === */
        .status-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }
        .status-card {
            background: var(--ap-white);
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
            cursor: default;
        }
        .status-card:hover {
            border-color: var(--amore-blue);
            box-shadow: var(--shadow-md);
        }
        .status-label {
            font-size: 10px;
            color: var(--ap-gray);
            text-transform: uppercase;
            letter-spacing: 1px;
            font-weight: 500;
            margin-bottom: 8px;
        }
        .status-value {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .status-value span {
            font-size: 18px;
            font-weight: 600;
            text-transform: uppercase;
        }
        .status-card.success .status-value { color: var(--amore-blue); }
        .status-card.info .status-value { color: var(--pacific-blue); }
        .status-card.danger .status-value { color: var(--danger); }
        .status-card.danger {
            border-color: rgba(139, 38, 53, 0.2);
            background: rgba(139, 38, 53, 0.03);
        }

        /* === STATUS CARD TOOLTIP (공통) === */
        .status-card { position: relative; z-index: 1; }
        .status-card:hover { z-index: 9999; }

        /* === STATUS CARD TOOLTIP - AMOREPACIFIC Style === */
        .status-card-tooltip {
            position: absolute;
            bottom: calc(100% + 12px);
            left: 0;
            transform: none;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            white-space: normal;
            word-break: keep-all;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease, transform 0.2s ease;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.15);
            text-align: left;
            min-width: 260px;
            max-width: 320px;
            width: max-content;
        }
        /* 좌측 상단 그라데이션 바 */
        .status-card-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        /* 화살표 (아래쪽) */
        .status-card-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 24px;
            border: 8px solid transparent;
            border-top-color: var(--ap-white);
            filter: drop-shadow(0 2px 2px rgba(0, 28, 88, 0.1));
        }
        .status-card-tooltip.align-right {
            left: auto;
            right: 0;
        }
        .status-card-tooltip.align-right::after {
            left: auto;
            right: 24px;
        }
        .status-card-tooltip.align-center {
            left: 50%;
            transform: translateX(-50%);
        }
        .status-card-tooltip.align-center::after {
            left: 50%;
            transform: translateX(-50%);
        }
        /* 툴팁 헤더 */
        .status-card-tooltip .tooltip-title {
            font-size: 11px;
            font-weight: 600;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
        }
        /* 툴팁 현재 상태 */
        .status-card-tooltip .tooltip-status {
            background: rgba(31, 87, 149, 0.06);
            padding: 10px 12px;
            border-radius: 6px;
            margin-bottom: 12px;
        }
        .status-card-tooltip .tooltip-status-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }
        .status-card-tooltip .tooltip-status-value {
            font-size: 13px;
            font-weight: 600;
            color: var(--pacific-blue);
        }
        .status-card-tooltip ul {
            list-style: none;
            text-align: left;
            margin: 0;
            padding: 0;
        }
        .status-card-tooltip li {
            padding: 6px 0;
            display: flex;
            align-items: flex-start;
            gap: 8px;
            font-size: 12px;
            line-height: 1.5;
            border-bottom: 1px solid rgba(0, 28, 88, 0.06);
        }
        .status-card-tooltip li:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .status-card-tooltip li::before {
            content: '';
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: var(--amore-blue);
            flex-shrink: 0;
            margin-top: 6px;
        }
        .status-card-tooltip li span {
            flex: 1;
        }
        .status-card:hover .status-card-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(-4px);
        }
        .status-card-tooltip.align-center:hover {
            transform: translateX(-50%) translateY(-4px);
        }

        /* 툴팁 색상별 bullet */
        .status-card-tooltip.stable-tooltip li::before { background: #22c55e; }
        .status-card-tooltip.moderate-tooltip li::before { background: var(--amore-blue); }
        .status-card-tooltip.attention-tooltip li::before { background: var(--danger); }
        .warning-tooltip li::before { background: var(--warning); }
        .exposure-status-tooltip li::before { background: var(--amore-blue); }
        .category-position-tooltip li::before { background: #60a5fa; }

        /* === STATUS CARD TOOLTIP - POSITION BELOW (Adaptive) === */
        /* 툴팁이 아래쪽에 표시될 때의 스타일 */
        .status-card-tooltip.position-below {
            bottom: auto !important;
            top: calc(100% + 12px) !important;
        }
        /* 화살표 방향 반전 (위쪽을 가리킴) */
        .status-card-tooltip.position-below::after {
            top: auto !important;
            bottom: 100% !important;
            border: 8px solid transparent !important;
            border-top-color: transparent !important;
            border-bottom-color: var(--ap-white) !important;
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.1));
        }
        /* position-below와 align 클래스 조합 */
        .status-card-tooltip.position-below.align-left::after {
            left: 24px;
            right: auto;
        }
        .status-card-tooltip.position-below.align-right::after {
            left: auto;
            right: 24px;
        }
        .status-card-tooltip.position-below.align-center::after {
            left: 50%;
            transform: translateX(-50%);
        }

        /* 툴팁 기준 (Criteria) 스타일 */
        .tooltip-criteria {
            margin-bottom: 12px;
            padding-bottom: 12px;
            border-bottom: 1px solid var(--border-light);
        }
        .criteria-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 0;
            font-size: 11px;
        }
        .criteria-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .criteria-item.stable .criteria-dot { background: #22c55e; }
        .criteria-item.moderate .criteria-dot { background: var(--amore-blue); }
        .criteria-item.attention .criteria-dot { background: var(--danger); }
        .criteria-label {
            font-weight: 600;
            min-width: 100px;
            color: var(--pacific-blue);
        }
        .criteria-item.stable .criteria-label { color: #22c55e; }
        .criteria-item.moderate .criteria-label { color: var(--amore-blue); }
        .criteria-item.attention .criteria-label { color: var(--danger); }
        .criteria-desc {
            color: var(--text-secondary);
            font-size: 11px;
        }

        /* === CHART TITLE TOOLTIP === */
        .card-title.has-tooltip {
            position: relative;
            cursor: help;
        }
        .card-title .help-icon {
            cursor: help;
            transition: opacity 0.2s;
        }
        .card-title:hover .help-icon {
            opacity: 1 !important;
        }
        .chart-title-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 12px;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            min-width: 280px;
            max-width: 320px;
            white-space: normal;
            line-height: 1.6;
            overflow: hidden;
        }
        .chart-title-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .chart-title-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 8px solid transparent;
            border-bottom-color: var(--ap-white);
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.05));
        }
        .chart-title-tooltip .tooltip-header {
            font-weight: 600;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
        }
        .chart-title-tooltip .tooltip-content p {
            margin: 0 0 10px 0;
            font-size: 12px;
            color: var(--text-secondary);
        }
        .chart-title-tooltip .tooltip-content p:last-child {
            margin-bottom: 0;
        }
        .chart-title-tooltip .tooltip-content strong {
            color: var(--pacific-blue);
            font-weight: 600;
        }
        .card-title.has-tooltip:hover .chart-title-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* SoS Trend Tooltip - 아리따 디자인 철학 반영 */
        .sos-trend-tooltip {
            min-width: 300px;
            max-width: 340px;
        }
        .sos-trend-tooltip .tooltip-content p {
            padding: 8px 0;
            border-bottom: 1px solid rgba(0, 28, 88, 0.06);
        }
        .sos-trend-tooltip .tooltip-content p:last-child {
            border-bottom: none;
        }
        .sos-trend-tooltip .tooltip-insight {
            background: linear-gradient(135deg, rgba(31, 87, 149, 0.08) 0%, rgba(0, 28, 88, 0.04) 100%);
            border-radius: 6px;
            padding: 10px 12px !important;
            margin-top: 4px;
            border-bottom: none !important;
        }
        .sos-trend-tooltip .tooltip-insight strong {
            color: var(--amore-blue);
        }

        /* === KPI CARD TOOLTIP === */
        .kpi-card.has-tooltip {
            position: relative;
            cursor: help;
        }
        .kpi-card .kpi-label {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .kpi-card .help-icon {
            width: 12px;
            height: 12px;
            opacity: 0.5;
            cursor: help;
            transition: opacity 0.2s;
        }
        .kpi-card:hover .help-icon {
            opacity: 1;
        }
        .kpi-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            transform: none;
            margin-top: 12px;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            min-width: 240px;
            max-width: 300px;
            white-space: normal;
            line-height: 1.6;
            text-align: left;
            overflow: hidden;
        }
        .kpi-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .kpi-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 8px solid transparent;
            border-bottom-color: var(--ap-white);
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.05));
        }
        .kpi-tooltip .tooltip-header {
            font-weight: 600;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
        }
        .kpi-tooltip .tooltip-content {
            font-size: 12px;
        }
        .kpi-tooltip .tooltip-content p {
            margin: 0 0 8px 0;
            color: var(--text-secondary);
        }
        .kpi-tooltip .tooltip-content p:last-child {
            margin-bottom: 0;
        }
        .kpi-tooltip .tooltip-content strong {
            color: var(--pacific-blue);
            font-weight: 600;
        }
        .kpi-card.has-tooltip:hover .kpi-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Product View 툴팁 - 아래쪽에 표시 (화면 상단에 위치하므로) */
        #page-product .kpi-tooltip {
            top: 100%;
            margin-top: 12px;
        }
        #page-product .kpi-tooltip::after {
            bottom: 100%;
            border: 8px solid transparent;
            border-bottom-color: var(--ap-white);
        }

        /* === TABLE HEADER TOOLTIP === */
        th.has-tooltip {
            position: relative;
            cursor: help;
        }
        th.has-tooltip .th-content {
            display: flex;
            align-items: center;
            gap: 4px;
            justify-content: inherit;
        }
        th .help-icon {
            width: 12px;
            height: 12px;
            opacity: 0.4;
            cursor: help;
            transition: opacity 0.2s;
        }
        th:hover .help-icon {
            opacity: 1;
        }
        .th-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            transform: none;
            margin-top: 12px;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 14px 18px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            font-weight: 400;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10000;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            min-width: 200px;
            max-width: 260px;
            white-space: normal;
            line-height: 1.6;
            text-align: left;
            overflow: hidden;
        }
        .th-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .th-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            left: 20px;
            border: 6px solid transparent;
            border-bottom-color: var(--ap-white);
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.05));
        }
        .th-tooltip .tooltip-header {
            font-weight: 600;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
            padding-bottom: 6px;
            border-bottom: 1px solid var(--border-light);
        }
        .th-tooltip .tooltip-content {
            color: var(--text-secondary);
        }
        .th-tooltip .tooltip-content strong {
            color: var(--pacific-blue);
            font-weight: 600;
        }
        th.has-tooltip:hover .th-tooltip {
            opacity: 1;
            visibility: visible;
        }
        /* 왼쪽 끝 열: 툴팁을 오른쪽으로 정렬 */
        th.has-tooltip:first-child .th-tooltip {
            left: 0;
        }
        th.has-tooltip:first-child .th-tooltip::after {
            left: 20px;
        }
        /* 오른쪽 끝 열: 툴팁을 왼쪽으로 정렬 */
        th.has-tooltip:last-child .th-tooltip {
            left: auto;
            right: 0;
        }
        th.has-tooltip:last-child .th-tooltip::after {
            left: auto;
            right: 20px;
        }

        /* === INFO POPUP TOOLTIP (아이콘 호버 시 팝업) === */
        .info-tooltip-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
        }
        .info-trigger {
            transition: opacity 0.2s;
        }
        .info-trigger:hover {
            opacity: 1 !important;
        }
        .info-popup-tooltip {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 12px;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            font-weight: 400;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 10001;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            min-width: 260px;
            max-width: 320px;
            white-space: normal;
            line-height: 1.6;
            text-align: left;
            overflow: hidden;
        }
        .info-popup-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .info-popup-tooltip::after {
            content: '';
            position: absolute;
            bottom: 100%;
            right: 20px;
            border: 6px solid transparent;
            border-bottom-color: var(--ap-white);
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.05));
        }
        .info-tooltip-wrapper:hover .info-popup-tooltip {
            opacity: 1;
            visibility: visible;
        }
        .info-popup-tooltip .tooltip-header {
            font-weight: 600;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border-light);
        }
        .info-popup-tooltip .tooltip-content p {
            margin-bottom: 10px;
            line-height: 1.6;
            color: var(--text-secondary);
        }
        .info-popup-tooltip .tooltip-content p:last-child {
            margin-bottom: 0;
        }
        .info-popup-tooltip .tooltip-content strong {
            color: var(--pacific-blue);
            font-weight: 600;
        }

        /* === CHART DATE RANGE PICKER === */
        .chart-date-range {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-left: auto;
        }
        .chart-date-range label {
            font-size: 11px;
            color: var(--text-secondary);
            font-weight: 500;
        }
        .chart-date-range input[type="date"] {
            padding: 6px 10px;
            border: 1px solid var(--border-color);
            border-radius: 6px;
            font-size: 12px;
            background: var(--ap-white);
            color: var(--text-primary);
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .chart-date-range input[type="date"]:hover {
            border-color: var(--pacific-blue);
        }
        .chart-date-range input[type="date"]:focus {
            outline: none;
            border-color: var(--pacific-blue);
            box-shadow: 0 0 0 3px rgba(0, 112, 184, 0.1);
        }
        .chart-date-range .date-separator {
            color: var(--text-secondary);
            font-size: 12px;
        }
        .chart-date-range .apply-btn {
            padding: 6px 12px;
            background: var(--pacific-blue);
            color: white;
            border: none;
            border-radius: 6px;
            font-size: 11px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .chart-date-range .apply-btn:hover {
            background: var(--amore-blue);
        }
        .data-period-info {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            padding: 4px 8px;
            background: rgba(0, 112, 184, 0.05);
            border-radius: 4px;
            display: inline-block;
        }
        .data-gap-warning {
            background: rgba(245, 158, 11, 0.1);
            color: #d97706;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            margin-top: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .data-gap-warning i {
            width: 14px;
            height: 14px;
        }

        /* === MISSING DATA ALERT - AMOREPACIFIC Style ===
         * 단아하고 절제된 경고 스타일
         */
        .missing-dates-alert {
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            border-left: 4px solid var(--amore-blue);
            color: var(--pacific-blue);
            padding: 14px 16px;
            border-radius: 0 6px 6px 0;
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 13px;
            display: flex;
            align-items: flex-start;
            gap: 12px;
        }
        .missing-dates-alert .alert-icon {
            width: 20px;
            height: 20px;
            color: var(--amore-blue);
            flex-shrink: 0;
            margin-top: 0;
        }
        .missing-dates-alert .alert-content {
            flex: 1;
        }
        .missing-dates-alert .alert-title {
            font-weight: 600;
            font-size: 13px;
            color: var(--pacific-blue);
            margin-bottom: 6px;
            letter-spacing: -0.02em;
        }
        .missing-dates-alert .alert-dates {
            font-family: 'SF Mono', 'Consolas', monospace;
            font-size: 12px;
            color: var(--amore-blue);
            background: rgba(31, 87, 149, 0.06);
            padding: 6px 10px;
            border-radius: 4px;
            display: inline-block;
            margin-bottom: 6px;
        }
        .missing-dates-alert .alert-hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 0;
            font-weight: 400;
        }
        .empty-cell {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 8px;
            background: var(--bg-subtle);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 11px;
            cursor: help;
            transition: background 0.15s ease;
        }
        .empty-cell:hover {
            background: var(--border-light);
        }
        .empty-cell .dot {
            width: 5px;
            height: 5px;
            background: var(--text-secondary);
            border-radius: 50%;
            opacity: 0.5;
        }
        .table-empty-state {
            padding: 48px 24px;
            text-align: center;
        }
        .table-empty-state .empty-icon {
            width: 48px;
            height: 48px;
            color: var(--text-secondary);
            opacity: 0.4;
            margin-bottom: 12px;
        }
        .table-empty-state .empty-title {
            font-size: 14px;
            font-weight: 500;
            color: var(--text-primary);
            margin-bottom: 6px;
        }
        .table-empty-state .empty-desc {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .tooltip-period-info {
            margin-top: 12px;
            padding-top: 10px;
            border-top: 1px solid var(--border-light);
            font-size: 11px;
            color: var(--text-secondary);
        }

        /* === GRID & CARDS - Clean Professional Style === */
        .content-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 24px;
        }
        .content-grid.single { grid-template-columns: 1fr; }
        .card {
            background: var(--ap-white);
            border-radius: var(--radius-lg);
            border: 1px solid var(--border-light);
            overflow: visible;
            transition: all 0.2s ease;
            position: relative;
        }
        /* 카드 내부 컨텐츠만 overflow 처리 (액센트 라인 가림 방지) */
        .card-body { overflow: hidden; }
        .card-header { overflow: visible; }
        /* ARITA: 호버 시 왼쪽 Amore Blue 액센트 라인 */
        .card::before {
            content: '';
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            width: 3px;
            background: linear-gradient(180deg,
                var(--amore-blue) 0%,
                rgba(31, 87, 149, 0.3) 100%
            );
            opacity: 0;
            transition: opacity 0.25s ease;
            z-index: 1;
        }
        .card:hover {
            box-shadow: var(--shadow-md);
            border-color: rgba(31, 87, 149, 0.2);
        }
        .card:hover::before {
            opacity: 1;
        }
        .card-header {
            padding: var(--space-4) var(--space-5);
            border-bottom: 1px solid rgba(0, 28, 88, 0.06);
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: linear-gradient(90deg,
                var(--bg-subtle) 0%,
                rgba(31, 87, 149, 0.015) 100%
            );
        }
        .card-title {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 13px;
            font-weight: 600;
            color: var(--pacific-blue);
        }
        .card-title-icon {
            width: 28px; height: 28px;
            background: var(--amore-blue);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .card-badge {
            font-size: 10px;
            padding: 4px 8px;
            border-radius: 4px;
            font-weight: 500;
        }
        .card-badge.danger {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }
        .card-body { padding: 20px; overflow: visible; }

        /* 브랜드 분석 그리드 - 카드 높이 및 해석 가이드 정렬 */
        .content-grid.brand-analysis-grid .card { display: flex; flex-direction: column; height: 100%; }
        .content-grid.brand-analysis-grid .card-body {
            flex: 1;
            display: flex !important;
            flex-direction: column !important;
        }
        .content-grid.brand-analysis-grid .card-body .chart-guide { margin-top: auto !important; }
        .content-grid.brand-analysis-grid .card-body .action-table { flex: 1; }

        /* === DATE RANGE SELECTOR === */
        .date-range-selector {
            display: flex;
            gap: 4px;
            background: var(--bg-subtle);
            padding: 3px;
            border-radius: 6px;
        }
        .date-range-selector .date-btn {
            padding: 5px 10px;
            font-size: 11px;
            font-weight: 500;
            border: none;
            background: transparent;
            color: var(--ap-gray);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.15s ease;
        }
        .date-range-selector .date-btn:hover {
            color: var(--pacific-blue);
            background: rgba(31, 87, 149, 0.05);
        }
        .date-range-selector .date-btn.active {
            background: var(--amore-blue);
            color: white;
        }
        .date-range-selector .date-btn.loading {
            opacity: 0.6;
            cursor: wait;
        }

        /* === ACTION TABLE - ARITA: 지적이고 절제된 데이터 표현 === */
        .action-table { width: 100%; border-collapse: collapse; overflow: visible; }
        .action-table th {
            text-align: left;
            padding: var(--space-3) var(--space-4);
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: var(--tracking-wide);
            color: var(--ap-gray);
            font-weight: 600;
            border-bottom: 1px solid rgba(0, 28, 88, 0.06);
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(31, 87, 149, 0.02) 50%,
                transparent 100%
            );
        }
        .action-table td {
            padding: var(--space-3) var(--space-4);
            border-bottom: 1px solid rgba(0, 28, 88, 0.04);
            font-size: var(--font-base);
            vertical-align: middle;
            overflow: visible;
            position: relative;
        }
        .action-table tr { transition: background 0.2s ease; }
        .action-table tr:hover { background: rgba(31, 87, 149, 0.03); }
        .action-table tr.highlight-row { background: rgba(31, 87, 149, 0.05); }
        .action-table tr.highlight-row:hover { background: rgba(31, 87, 149, 0.08); }

        /* 경쟁사 비교 테이블 - 행 간격 확대 */
        #competitor-table td { padding: 20px 16px; }
        #competitor-table th { padding: 16px 16px; }

        /* Product Name Truncation with Custom Tooltip */
        .product-name-wrapper {
            position: relative;
            display: inline-block;
            max-width: 320px;
        }
        .product-name-truncate {
            max-width: 320px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            vertical-align: middle;
            cursor: help;
        }
        .product-name-truncate:hover {
            color: var(--amore-blue);
        }
        .product-name-tooltip {
            position: fixed;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            line-height: 1.6;
            min-width: 240px;
            max-width: 320px;
            white-space: normal;
            word-break: keep-all;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s ease, visibility 0.2s ease;
            z-index: 99999;
            pointer-events: none;
            overflow: hidden;
        }
        .product-name-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .product-name-tooltip .tooltip-header {
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            color: var(--amore-blue);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid var(--border-light);
        }
        .product-name-tooltip .tooltip-list {
            list-style: none;
            margin: 0;
            padding: 0;
        }
        .product-name-tooltip .tooltip-list li {
            padding: 4px 0;
            display: flex;
            align-items: flex-start;
            gap: 8px;
            font-size: 12px;
            color: var(--text-secondary);
        }
        .product-name-tooltip .tooltip-list li::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--amore-blue);
            border-radius: 50%;
            flex-shrink: 0;
            margin-top: 6px;
        }
        .product-name-wrapper:hover .product-name-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Competitor Table Styles */
        .rank-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 28px;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            background: var(--bg-subtle);
            color: var(--text-primary);
        }
        .vs-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }
        .vs-badge.baseline {
            background: rgba(31, 87, 149, 0.1);
            color: var(--amore-blue);
        }
        .vs-badge.ahead {
            background: rgba(16, 185, 129, 0.1);
            color: #059669;
        }
        .vs-badge.behind {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }

        .priority-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }
        .priority-badge.p1 {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }
        .priority-badge.p2 {
            background: rgba(196, 169, 98, 0.15);
            color: #9A7D2E;
        }
        .action-tag {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }
        .action-tag.monitor {
            background: rgba(31, 87, 149, 0.1);
            color: var(--amore-blue);
        }
        .action-tag.risk {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }
        .action-tag.deep {
            background: rgba(196, 169, 98, 0.15);
            color: #9A7D2E;
        }
        .product-info { display: flex; align-items: center; gap: 12px; }
        .product-avatar {
            width: 32px; height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 11px;
            color: var(--ap-white);
            background: var(--amore-blue);
        }
        .product-name {
            font-weight: 500;
            color: var(--pacific-blue);
        }
        .product-brand {
            font-size: 11px;
            color: var(--ap-gray);
        }
        .link-action {
            color: var(--amore-blue);
            font-size: 12px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 4px;
            transition: color 0.15s;
        }
        .link-action:hover { color: var(--pacific-blue); }

        /* === KPI CARDS - Minimal Professional === */
        .kpi-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }
        .kpi-card {
            position: relative;
            background: var(--ap-white);
            border-radius: var(--radius-lg);
            padding: var(--space-5);
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
            overflow: visible;
        }
        /* ARITA: KPI 카드 상단 액센트 라인 */
        .kpi-card::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--amore-blue) 50%,
                transparent 100%
            );
            opacity: 0;
            transition: opacity 0.25s ease;
        }
        .kpi-card:hover {
            border-color: rgba(31, 87, 149, 0.2);
            box-shadow: var(--shadow-md);
        }
        .kpi-card:hover::after {
            opacity: 1;
        }
        .kpi-label {
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--ap-gray);
            font-weight: 500;
            margin-bottom: 8px;
        }
        .kpi-value {
            font-size: 28px;
            font-weight: 600;
            color: var(--pacific-blue);
            margin-bottom: 6px;
            display: flex;
            align-items: baseline;
            gap: 4px;
        }
        .kpi-value .unit {
            font-size: 14px;
            font-weight: 400;
            color: var(--ap-gray);
        }
        .kpi-delta {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
        }
        .kpi-delta.up {
            background: rgba(31, 87, 149, 0.1);
            color: var(--amore-blue);
        }
        .kpi-delta.down {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }

        /* === RESPONSIVE LAYOUT === */

        /* 태블릿 가로 (1200px 이하) */
        @media (max-width: 1200px) {
            .kpi-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            .content-grid {
                grid-template-columns: 1fr;
            }
            .chatbot-panel.open {
                width: 360px;
                min-width: 280px;
            }
        }

        /* 태블릿 세로 (992px 이하) */
        @media (max-width: 992px) {
            .sidebar {
                width: 200px;
            }
            .chatbot-panel.open {
                position: fixed;
                right: 0;
                top: 0;
                height: 100vh;
                width: 380px;
                z-index: 1000;
                box-shadow: -4px 0 20px rgba(0,0,0,0.15);
            }
            .chatbot-overlay {
                display: block;
                position: fixed;
                inset: 0;
                background: rgba(0,0,0,0.4);
                z-index: 999;
                opacity: 0;
                visibility: hidden;
                transition: all 0.25s ease;
            }
            .chatbot-overlay.active {
                opacity: 1;
                visibility: visible;
            }
        }

        /* 모바일 가로 / 작은 태블릿 (768px 이하) - 기본 레이아웃 조정 */
        @media (max-width: 768px) {
            .kpi-grid {
                grid-template-columns: 1fr;
            }
            .category-header-row {
                flex-direction: column;
                gap: 12px;
                align-items: flex-start !important;
            }
            .chart-date-range {
                width: 100%;
                flex-wrap: wrap;
                justify-content: flex-start;
            }
            .category-tabs {
                flex-wrap: wrap;
            }
            .page-header {
                flex-direction: column;
                align-items: flex-start !important;
                gap: 12px;
            }
            .page-header h2 {
                font-size: 18px;
            }
            .view-header {
                flex-direction: column;
                gap: 12px;
            }
            .header-controls {
                width: 100%;
                flex-wrap: wrap;
            }
            .growth-type-container {
                flex-direction: column;
            }
        }

        /* 모바일 세로 (576px 이하) - 추가 조정 */
        @media (max-width: 576px) {
            .kpi-card {
                padding: 16px;
            }
            .kpi-value {
                font-size: 24px;
            }
            .chart-date-range input[type="date"] {
                width: 110px;
                font-size: 11px;
            }
            .chart-date-range select {
                font-size: 11px;
                padding: 4px 8px;
            }
            .apply-btn {
                padding: 4px 8px;
                font-size: 10px;
            }
            .chatbot-input-area {
                padding: 12px;
            }
            .chatbot-input-area textarea {
                font-size: 14px;
            }
            .chat-message {
                max-width: 95%;
                font-size: 13px;
            }
            .suggestion-chips {
                flex-direction: column;
            }
            .suggestion-chip {
                width: 100%;
                text-align: left;
            }
            .data-table {
                font-size: 11px;
            }
            .data-table th, .data-table td {
                padding: 8px 6px;
            }
        }

        /* 매우 작은 화면 (400px 이하) */
        @media (max-width: 400px) {
            .page-header h2 {
                font-size: 16px;
            }
            .kpi-grid {
                gap: 8px;
            }
            .kpi-card {
                padding: 12px;
            }
            .kpi-value {
                font-size: 20px;
            }
            .kpi-label {
                font-size: 10px;
            }
            .chart-container {
                height: 200px;
            }
        }

        /* 모바일 헤더 기본 숨김 */
        .mobile-header {
            display: none;
        }

        /* 사이드바/챗봇 오버레이 기본 숨김 */
        .sidebar-overlay,
        .chatbot-overlay {
            display: none;
        }

        /* ========================================
           ENHANCED MOBILE RESPONSIVE (2026 업데이트)
           ======================================== */

        /* 앱 컨테이너 - 모바일에서 column 레이아웃 */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }

            /* 모바일 헤더 - 최상단 고정 */
            .mobile-header {
                display: flex !important;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                height: 56px;
                background: linear-gradient(135deg, var(--pacific-blue), var(--amore-blue));
                padding: 0 16px;
                align-items: center;
                justify-content: space-between;
                z-index: 1002;
                box-shadow: 0 2px 8px rgba(0, 28, 88, 0.15);
            }

            .mobile-header .menu-btn {
                width: 40px;
                height: 40px;
                background: rgba(255, 255, 255, 0.1);
                border: none;
                border-radius: 8px;
                color: white;
                font-size: 20px;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
                transition: background 0.2s;
            }

            .mobile-header .menu-btn:active {
                background: rgba(255, 255, 255, 0.2);
            }

            .mobile-header .mobile-logo {
                display: flex;
                align-items: center;
                gap: 8px;
            }

            .mobile-header .mobile-logo img {
                height: 24px;
                filter: brightness(0) invert(1);
            }

            .mobile-header .logo-text {
                color: white;
                font-size: 14px;
                font-weight: 600;
                letter-spacing: 0.3px;
            }

            .mobile-header .chat-toggle-btn {
                background: rgba(255, 255, 255, 0.15);
                border: none;
                color: white;
                padding: 8px 14px;
                border-radius: 8px;
                font-size: 12px;
                font-weight: 500;
                cursor: pointer;
                display: flex;
                align-items: center;
                gap: 6px;
                transition: background 0.2s;
            }

            .mobile-header .chat-toggle-btn:active {
                background: rgba(255, 255, 255, 0.25);
            }

            /* 메인 래퍼 - 모바일 헤더 아래로 */
            .main-wrapper {
                margin-top: 56px;
                height: calc(100vh - 56px);
            }

            /* 데스크톱 헤더 숨김 */
            .header {
                display: none !important;
            }

            /* 사이드바 오버레이 */
            .sidebar-overlay {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 28, 88, 0.5);
                z-index: 1000;
                opacity: 0;
                visibility: hidden;
                transition: all 0.3s ease;
                backdrop-filter: blur(2px);
            }

            .sidebar-overlay.active {
                opacity: 1;
                visibility: visible;
            }

            /* 사이드바 - 좌측 슬라이드 */
            .sidebar {
                position: fixed;
                left: -280px;
                top: 0;
                height: 100vh;
                width: 280px;
                z-index: 1001;
                transition: left 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                box-shadow: 4px 0 20px rgba(0, 28, 88, 0.2);
            }

            .sidebar.open {
                left: 0;
            }

            /* 사이드바 닫기 버튼 */
            .sidebar .mobile-close-btn {
                display: flex !important;
                position: absolute;
                top: 16px;
                right: 16px;
                width: 32px;
                height: 32px;
                background: rgba(255, 255, 255, 0.1);
                border: none;
                border-radius: 6px;
                color: white;
                font-size: 18px;
                cursor: pointer;
                align-items: center;
                justify-content: center;
            }

            /* 콘텐츠 영역 패딩 */
            .content-area {
                padding: 16px !important;
            }

            /* 챗봇 패널 - 전체 화면 */
            .chatbot-panel.open {
                position: fixed;
                top: 56px;
                left: 0;
                right: 0;
                bottom: 0;
                width: 100% !important;
                max-width: 100% !important;
                min-width: 100% !important;
                height: calc(100vh - 56px) !important;
                z-index: 999;
                border-radius: 0;
            }
        }

        /* 576px 이하 추가 최적화 */
        @media (max-width: 576px) {
            .mobile-header {
                padding: 0 12px;
            }

            .mobile-header .logo-text {
                font-size: 13px;
            }

            .mobile-header .chat-toggle-btn {
                padding: 6px 10px;
                font-size: 11px;
            }

            .content-area {
                padding: 12px !important;
            }

            /* 상태 그리드 1열 */
            .status-grid {
                grid-template-columns: 1fr !important;
                gap: 12px !important;
            }

            /* 카드 패딩 축소 */
            .card {
                border-radius: 10px !important;
            }

            .card-header {
                padding: 14px 16px !important;
            }

            .card-body {
                padding: 14px 16px !important;
            }

            /* 테이블 스크롤 */
            .table-container {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            /* 인사이트 배너 - 모바일 */
            .insight-banner {
                flex-direction: column !important;
            }

            .insight-content {
                flex-direction: column !important;
            }

            .insight-brand-area {
                padding: 12px 16px !important;
                flex-direction: row !important;
                justify-content: center !important;
                gap: 12px !important;
                min-width: auto !important;
            }

            .insight-brand-wordmark {
                flex-direction: row !important;
                gap: 4px !important;
            }

            .insight-brand-divider {
                width: 1px !important;
                height: 16px !important;
                margin: 0 !important;
            }

            .insight-text {
                padding: 16px !important;
                text-align: center !important;
            }

            .insight-message {
                font-size: 13px !important;
                line-height: 1.6 !important;
            }
        }

        /* 400px 이하 - 아주 작은 화면 */
        @media (max-width: 400px) {
            .mobile-header {
                height: 52px;
            }

            .mobile-header .menu-btn {
                width: 36px;
                height: 36px;
                font-size: 18px;
            }

            .mobile-header .logo-text {
                font-size: 12px;
            }

            .main-wrapper {
                margin-top: 52px;
                height: calc(100vh - 52px);
            }

            .content-area {
                padding: 8px !important;
            }

            .status-card {
                padding: 14px !important;
            }

            .status-value {
                font-size: 22px !important;
            }
        }

        /* 사이드바 닫기 버튼 - 데스크톱에서 숨김 */
        .sidebar .mobile-close-btn {
            display: none;
        }

        /* === CHARTS === */
        .chart-container { position: relative; height: 260px; overflow: visible !important; }
        .chart-container-large { height: 420px; }

        /* Chart.js 툴팁 캐럿(세모 화살표)이 잘리지 않도록 모든 상위 요소 overflow visible */
        .content-card:has(.chart-container),
        .card:has(.chart-container) {
            overflow: visible !important;
        }
        .content-card:has(.chart-container) .card-body,
        .card:has(.chart-container) .card-body {
            overflow: visible !important;
        }
        .content-card:has(.chart-container) .card-body > div,
        .card:has(.chart-container) .card-body > div {
            overflow: visible !important;
        }
        /* 차트 캔버스 자체도 overflow visible */
        .chart-container canvas {
            overflow: visible !important;
        }
        /* 차트 카드가 hover 시 다른 카드 위에 표시 */
        .content-card:has(.chart-container:hover),
        .card:has(.chart-container:hover) {
            z-index: 100;
        }
        .chart-guide {
            margin-top: 12px;
            padding: 12px 16px;
            background: var(--bg-subtle);
            border-left: 3px solid var(--amore-blue);
            border-radius: 0 6px 6px 0;
            font-size: 12px;
            line-height: 1.6;
            color: var(--ap-gray);
        }
        .chart-guide strong { color: var(--pacific-blue); }

        /* === GROWTH TYPE CLASSIFICATION === */
        .growth-type-container {
            display: flex;
            gap: 16px;
        }
        .growth-type-box {
            flex: 1;
            padding: 24px;
            border-radius: 8px;
            text-align: center;
            background: var(--bg-card);
            border: 1px solid var(--border-light);
            transition: all 0.2s ease;
        }
        .growth-type-box:hover {
            border-color: var(--amore-blue);
            box-shadow: var(--shadow-md);
        }
        .growth-type-icon-wrapper {
            width: 48px;
            height: 48px;
            margin: 0 auto 12px;
            background: rgba(31, 87, 149, 0.08);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .growth-type-box.organic .growth-type-icon-wrapper {
            background: rgba(31, 87, 149, 0.08);
        }
        .growth-type-box.discount .growth-type-icon-wrapper {
            background: rgba(0, 28, 88, 0.08);
        }
        .growth-type-label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }
        .growth-type-value {
            font-size: 32px;
            font-weight: 700;
            color: var(--pacific-blue);
            margin-bottom: 8px;
        }
        .growth-type-desc {
            font-size: 11px;
            color: var(--text-secondary);
            line-height: 1.5;
        }

        /* === ENHANCED COMPETITOR COMPARISON === */
        .competitor-section {
            margin-top: 20px;
        }

        .competitor-selector {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }

        .competitor-label {
            font-size: 12px;
            font-weight: 500;
            color: var(--text-secondary);
        }

        .competitor-dropdown {
            padding: 8px 14px;
            border-radius: 6px;
            border: 1px solid var(--border-light);
            background: var(--bg-card);
            color: var(--text-primary);
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s ease;
            min-width: 180px;
        }

        .competitor-dropdown:hover {
            border-color: var(--amore-blue);
        }

        .competitor-dropdown:focus {
            outline: none;
            border-color: var(--amore-blue);
            box-shadow: 0 0 0 3px rgba(31, 87, 149, 0.1);
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .comparison-table thead {
            background: var(--bg-subtle);
        }

        .comparison-table th {
            padding: 12px 16px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-light);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .comparison-table th:first-child {
            border-radius: 6px 0 0 0;
        }

        .comparison-table th:last-child {
            border-radius: 0 6px 0 0;
        }

        .comparison-table td {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border-light);
            color: var(--text-primary);
        }

        .comparison-table tbody tr:hover {
            background: var(--bg-subtle);
        }

        .comparison-table .metric-label {
            font-weight: 500;
            color: var(--text-primary);
        }

        .comparison-table .better {
            color: #10b981;
            font-weight: 600;
        }

        .comparison-table .worse {
            color: #ef4444;
            font-weight: 600;
        }

        .comparison-table .same {
            color: var(--text-secondary);
        }

        .comparison-table .value-cell {
            text-align: center;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 13px;
        }

        /* === PROMO COMPARISON TABLE === */
        .promo-table-container {
            max-height: 280px;
            overflow-y: auto;
        }
        .promo-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .promo-table thead {
            position: sticky;
            top: 0;
            background: var(--bg-card);
            z-index: 1;
        }
        .promo-table th {
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            color: var(--text-secondary);
            border-bottom: 2px solid var(--border-light);
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .promo-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border-light);
            color: var(--text-primary);
        }
        .promo-table tr:hover {
            background: var(--bg-subtle);
        }
        .promo-table tr.is-laneige {
            background: rgba(31, 87, 149, 0.08);
        }
        .promo-table tr.is-laneige:hover {
            background: rgba(31, 87, 149, 0.12);
        }
        .promo-table .brand-name {
            font-weight: 500;
            max-width: 100px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .promo-table .brand-name.laneige {
            color: var(--amore-blue);
            font-weight: 600;
        }
        .promo-table .num-cell {
            text-align: center;
            font-family: 'SF Mono', 'Monaco', monospace;
        }
        .promo-table .discount-cell {
            color: #ef4444;
            font-weight: 500;
        }
        .promo-table .no-data-dash {
            cursor: help;
            color: var(--text-secondary);
            transition: color 0.2s ease;
        }
        .promo-table .no-data-dash:hover {
            color: var(--amore-blue);
        }

        /* === DISCOUNT & PRICE BADGES === */
        .discount-badge {
            display: inline-block;
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            margin-left: 6px;
            vertical-align: middle;
            box-shadow: 0 2px 4px rgba(255, 107, 107, 0.2);
        }

        .coupon-badge {
            display: inline-block;
            background: rgba(196, 169, 98, 0.15);
            color: #92400E;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 500;
            margin-left: 6px;
            vertical-align: middle;
            border: 1px solid rgba(196, 169, 98, 0.3);
        }

        .deal-badge {
            display: inline-block;
            background: linear-gradient(135deg, #f59e0b, #d97706);
            color: white;
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            margin-left: 6px;
            vertical-align: middle;
        }

        .price-original {
            text-decoration: line-through;
            color: #999;
            font-size: 11px;
            margin-right: 6px;
        }

        .price-current {
            color: #e74c3c;
            font-weight: 600;
            font-size: 13px;
        }

        .price-container {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 4px;
        }

        /* === QUICK ACTIONS === */
        .quick-actions {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 24px;
        }
        .quick-action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: var(--space-2);
            padding: var(--space-3) var(--space-5);
            border-radius: var(--radius-md);
            font-size: var(--font-base);
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            border: none;
            position: relative;
            overflow: hidden;
        }
        /* ARITA: Primary 버튼 - 강함(Pacific)에서 부드러움(Amore)으로 그라데이션 */
        .quick-action-btn.primary {
            background: linear-gradient(135deg,
                var(--pacific-blue) 0%,
                var(--amore-blue) 100%
            );
            color: var(--ap-white);
        }
        .quick-action-btn.primary:hover {
            box-shadow: 0 4px 16px rgba(31, 87, 149, 0.35);
            transform: translateY(-1px);
        }
        .quick-action-btn.secondary {
            background: var(--ap-white);
            color: var(--pacific-blue);
            border: 1px solid var(--amore-blue);
        }
        .quick-action-btn.secondary:hover {
            background: rgba(31, 87, 149, 0.08);
            border-color: var(--pacific-blue);
            color: var(--pacific-blue);
        }
        .quick-action-btn.accent {
            background: var(--amore-blue);
            color: var(--ap-white);
        }
        .quick-action-btn.accent:hover {
            background: var(--pacific-blue);
            box-shadow: 0 4px 12px rgba(0, 28, 88, 0.25);
            transform: translateY(-1px);
        }

        /* === PERIOD SELECTOR === */
        .period-selector {
            display: flex;
            gap: 4px;
        }
        .period-btn {
            padding: 4px 10px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border-light);
            background: var(--ap-white);
            color: var(--ap-gray);
        }
        .period-btn:hover {
            border-color: var(--amore-blue);
            color: var(--amore-blue);
        }
        .period-btn.active {
            background: var(--amore-blue);
            color: var(--ap-white);
            border-color: var(--amore-blue);
        }

        /* === CATEGORY TABS - Minimal === */
        .category-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .category-tab {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
            border: 1px solid var(--border-light);
            background: var(--ap-white);
            color: var(--ap-gray);
        }
        .category-tab:hover {
            border-color: var(--amore-blue);
            color: var(--amore-blue);
        }
        .category-tab.active {
            background: var(--pacific-blue);
            border-color: var(--pacific-blue);
            color: var(--ap-white);
        }

        /* === PRODUCT SELECTOR === */
        .selector-group {
            display: flex;
            gap: 12px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }
        .selector-label {
            font-size: 11px;
            font-weight: 500;
            color: var(--ap-gray);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .selector-dropdown {
            padding: 10px 16px;
            border-radius: 6px;
            border: 1px solid var(--border-light);
            font-size: 13px;
            font-weight: 400;
            cursor: pointer;
            background: var(--ap-white);
            min-width: 200px;
            outline: none;
            transition: border-color 0.15s;
            color: var(--pacific-blue);
        }
        .selector-dropdown:focus {
            border-color: var(--amore-blue);
        }

        /* === CATEGORY HIERARCHY TREE (카테고리 계층 트리) === */
        .category-tree {
            font-size: 12px;
            line-height: 1.4;
        }
        .category-tree-item {
            margin: 0;
            padding: 0;
        }
        .category-tree-node {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 2px 0;
            background: white;
            border: 1px solid var(--border-light);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .category-tree-node:hover {
            background: rgba(31, 87, 149, 0.05);
            border-color: var(--amore-blue);
        }
        .category-tree-node.has-laneige {
            border-left: 3px solid var(--amore-blue);
        }
        .category-tree-node.no-laneige {
            border-left: 3px solid #D0D0D0;
            opacity: 0.7;
        }
        .category-tree-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 8px;
            color: var(--text-secondary);
            font-size: 10px;
            transition: transform 0.2s ease;
        }
        .category-tree-toggle.expanded {
            transform: rotate(90deg);
        }
        .category-tree-toggle.empty {
            visibility: hidden;
        }
        .category-tree-content {
            flex: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .category-tree-name {
            font-weight: 500;
            color: var(--pacific-blue);
        }
        .category-tree-level {
            font-size: 10px;
            color: var(--text-secondary);
            margin-left: 6px;
            padding: 2px 6px;
            background: rgba(0, 28, 88, 0.06);
            border-radius: 4px;
        }
        .category-tree-stats {
            text-align: right;
            font-size: 11px;
        }
        .category-tree-sos {
            font-weight: 600;
            color: var(--amore-blue);
        }
        .category-tree-count {
            color: var(--text-secondary);
            font-size: 10px;
        }
        .category-tree-children {
            margin-left: 28px;
            padding-left: 12px;
            border-left: 1px dashed var(--border-light);
            overflow: hidden;
            max-height: 0;
            transition: max-height 0.3s ease;
        }
        .category-tree-children.expanded {
            max-height: 500px;
        }
        /* 중간 카테고리 (모니터링 안함) */
        .category-tree-node.intermediate {
            background: rgba(0, 0, 0, 0.02);
            border-style: dashed;
            opacity: 0.6;
        }
        .category-tree-node.intermediate .category-tree-name {
            font-style: italic;
            color: var(--text-secondary);
        }

        /* === SELECTOR TOOLTIP (카테고리/제품 선택 툴팁) === */
        .selector-wrapper {
            position: relative;
            display: inline-block;
        }
        .selector-wrapper .selector-tooltip {
            position: absolute;
            bottom: calc(100% + 12px);
            left: 0;
            transform: none;
            background: var(--ap-white);
            color: var(--pacific-blue);
            padding: 16px 20px;
            border-radius: 8px;
            border: 1px solid var(--border-light);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            line-height: 1.6;
            min-width: 280px;
            max-width: 360px;
            box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
            z-index: 1000;
            pointer-events: none;
            overflow: hidden;
        }
        .selector-wrapper .selector-tooltip::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            border-radius: 8px 0 0 8px;
        }
        .selector-wrapper .selector-tooltip::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 24px;
            border: 8px solid transparent;
            border-top-color: var(--ap-white);
            filter: drop-shadow(0 2px 2px rgba(0, 28, 88, 0.05));
        }
        .selector-wrapper:hover .selector-tooltip {
            opacity: 1;
            visibility: visible;
        }

        /* Selector 툴팁 동적 위치 조정: 아래쪽에 표시될 때 */
        .selector-tooltip.position-below {
            bottom: auto !important;
            top: calc(100% + 12px) !important;
        }
        .selector-tooltip.position-below::after {
            top: auto !important;
            bottom: 100% !important;
            border: 8px solid transparent !important;
            border-top-color: transparent !important;
            border-bottom-color: var(--ap-white) !important;
            filter: drop-shadow(0 -2px 2px rgba(0, 28, 88, 0.05));
        }

        .selector-tooltip-header {
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            font-size: 11px;
            color: var(--amore-blue);
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            align-items: center;
            gap: 6px;
            border-bottom: 1px solid var(--border-light);
        }
        .selector-tooltip-content p {
            margin: 8px 0;
            color: var(--text-secondary);
        }
        .selector-tooltip-content strong {
            color: var(--pacific-blue);
            font-weight: 600;
        }
        .selector-tooltip-content ul {
            margin: 6px 0 6px 0;
            padding: 0;
            list-style: none;
        }
        .selector-tooltip-content li {
            margin: 4px 0;
            color: var(--text-secondary);
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .selector-tooltip-content li::before {
            content: '';
            width: 6px;
            height: 6px;
            background: var(--amore-blue);
            border-radius: 50%;
            flex-shrink: 0;
        }

        /* === PRODUCT PAGE HEADER ROW === */
        .product-header-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 16px;
        }
        .product-header-row .selector-group {
            margin-bottom: 0;
        }
        .product-header-row .chart-date-range {
            margin-left: 0;
        }

        /* 고정 기간 배지 (최근 7일) */
        .fixed-date-badge {
            font-size: 11px;
            font-weight: 400;
            color: var(--text-secondary);
            background: rgba(0, 28, 88, 0.06);
            padding: 4px 10px;
            border-radius: 4px;
            white-space: nowrap;
        }

        /* === TEXT TRUNCATION FIX - 제품명 전체 표시 === */
        .promo-table .brand-name {
            max-width: none !important;
            overflow: visible !important;
            text-overflow: clip !important;
            white-space: normal !important;
            word-break: keep-all;
        }
        .selector-dropdown {
            min-width: 220px;
            max-width: 300px;
        }
        .action-table td,
        .promo-table td {
            white-space: normal;
            word-break: keep-all;
        }
        /* 제품명/브랜드명 컬럼 최소 너비 확보 */
        .action-table td:nth-child(2),
        .promo-table td:first-child {
            min-width: 120px;
        }
        /* 차트 범례 텍스트 잘림 방지 */
        .chart-container canvas {
            max-width: 100%;
        }

        /* === CHATBOT - Clean Professional with Resize === */
        .chatbot-panel {
            width: 0;
            min-width: 0;
            background: var(--ap-white);
            border-left: 1px solid var(--border-light);
            display: flex;
            flex-direction: column;
            transition: width 0.25s ease;
            overflow: hidden;
            position: relative;
        }
        .chatbot-panel.open {
            width: 420px;
            min-width: 320px;
            max-width: 600px;
        }
        .chatbot-panel.resizing {
            transition: none;
            user-select: none;
        }
        /* 드래그 핸들 (왼쪽 경계) */
        .chat-resize-handle {
            position: absolute;
            left: 0;
            top: 0;
            width: 6px;
            height: 100%;
            cursor: ew-resize;
            background: transparent;
            z-index: 10;
            transition: background 0.15s;
        }
        .chat-resize-handle:hover,
        .chat-resize-handle.active {
            background: var(--amore-blue);
        }
        .chat-header {
            padding: 12px 16px;
            background: linear-gradient(135deg, var(--pacific-blue) 0%, var(--amore-blue) 100%);
            color: var(--ap-white);
            flex-shrink: 0;
        }
        .chat-header-top {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 2px;
        }
        .chat-header h3 {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 14px;
            font-weight: 600;
        }
        .chat-close {
            width: 28px;
            height: 28px;
            background: rgba(255,255,255,0.15);
            border: none;
            border-radius: 6px;
            color: var(--ap-white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.15s;
        }
        .chat-close:hover { background: rgba(255,255,255,0.25); }
        .chat-subtitle {
            font-size: 11px;
            opacity: 0.7;
        }
        .chat-body {
            flex: 1;
            padding: 16px;
            overflow-y: auto;
            background: var(--bg-subtle);
        }
        .chat-message { margin-bottom: 12px; }
        .chat-message.bot .bubble {
            background: var(--ap-white);
            border: 1px solid rgba(0, 28, 88, 0.08);
            border-radius: var(--radius-xl) var(--radius-xl) var(--radius-xl) var(--radius-sm);
            padding: var(--space-3) var(--space-4);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: var(--font-base);
            line-height: 1.8;
            color: var(--pacific-blue);
            box-shadow: 0 1px 4px rgba(0, 28, 88, 0.08);
        }
        .chat-message.user .bubble {
            background: var(--pacific-blue);
            color: var(--ap-white);
            border-radius: var(--radius-xl) var(--radius-xl) var(--radius-sm) var(--radius-xl);
            padding: var(--space-3) var(--space-4);
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: var(--font-base);
            margin-left: auto;
            max-width: 85%;
            box-shadow: 0 2px 8px rgba(0, 28, 88, 0.15);
        }
        .chat-message.bot .bubble strong { color: var(--amore-blue); }
        /* 인사이트 스타일 재정의 (채팅 버블 내부) */
        .chat-message.bot .bubble .insight-section-header {
            margin: 16px 0 12px 0;
            font-size: 15px;
        }
        .chat-message.bot .bubble .insight-section-header:first-child {
            margin-top: 0;
        }
        .chat-message.bot .bubble .insight-layer-header {
            margin: 12px 0 6px 0;
            font-size: 13px;
        }

        /* === 스트리밍 커서 애니메이션 === */
        .streaming-cursor {
            display: inline-block;
            color: var(--amore-blue);
            animation: blink 0.7s infinite;
            font-weight: bold;
        }
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        .streaming-text {
            white-space: pre-wrap;
        }

        /* === AI 경고 문구 === */
        .ai-disclaimer {
            margin-top: 10px;
            padding-top: 8px;
            border-top: 1px dashed var(--border-light);
            color: var(--ap-gray);
            font-size: 10px;
            font-style: italic;
        }

        /* === 추천 질문 - 접기/펼치기 === */
        .chat-suggestions {
            border-top: 1px solid var(--border-light);
            background: var(--ap-white);
            flex-shrink: 0;
        }
        .suggestions-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            cursor: pointer;
            transition: background 0.15s;
        }
        .suggestions-header:hover {
            background: var(--bg-subtle);
        }
        .suggestions-label {
            font-size: 10px;
            color: var(--ap-gray);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
            margin: 0;
        }
        .suggestions-toggle {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--ap-gray);
            transition: transform 0.2s;
        }
        .chat-suggestions.collapsed .suggestions-toggle {
            transform: rotate(-90deg);
        }
        .suggestion-chips {
            display: flex;
            flex-direction: column;
            gap: 6px;
            padding: 0 16px 12px 16px;
            max-height: 200px;
            overflow: hidden;
            transition: max-height 0.25s ease, padding 0.25s ease, opacity 0.2s ease;
        }
        .chat-suggestions.collapsed .suggestion-chips {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
            opacity: 0;
        }
        .suggestion-chip {
            padding: 10px 14px;
            background: var(--bg-subtle);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.15s;
            text-align: left;
            color: var(--pacific-blue);
        }
        .suggestion-chip:hover {
            background: rgba(31, 87, 149, 0.08);
            border-color: var(--amore-blue);
            color: var(--amore-blue);
        }
        .chat-input-area {
            padding: 12px 16px;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 10px;
            background: var(--ap-white);
        }
        .chat-input {
            flex: 1;
            padding: var(--space-3) var(--space-4);
            border: 1px solid rgba(0, 28, 88, 0.1);
            background: var(--bg-subtle);
            border-radius: var(--radius-md);
            font-size: var(--font-base);
            outline: none;
            transition: all 0.2s ease;
            color: var(--pacific-blue);
        }
        .chat-input::placeholder {
            color: rgba(0, 28, 88, 0.4);
        }
        .chat-input:focus {
            border-color: var(--amore-blue);
            background: var(--ap-white);
            box-shadow: 0 0 0 3px rgba(31, 87, 149, 0.1);
        }
        .chat-send {
            width: 42px;
            height: 42px;
            background: var(--amore-blue);
            border: none;
            border-radius: var(--radius-md);
            color: var(--ap-white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            flex-shrink: 0;
        }
        .chat-send:hover {
            background: var(--pacific-blue);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(0, 28, 88, 0.2);
        }

        .chat-fab {
            position: fixed;
            bottom: 24px;
            right: 24px;
            width: 56px;
            height: 56px;
            background: var(--pacific-blue);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: var(--shadow-lg);
            z-index: 100;
            transition: all 0.2s;
            border: none;
        }
        .chat-fab:hover {
            background: var(--amore-blue);
        }
        .chat-fab.hidden { opacity: 0; pointer-events: none; transform: scale(0.9); }

        /* === AI DRAWER - Professional === */
        .ai-drawer {
            position: fixed;
            top: 0;
            right: 0;
            width: 480px;
            height: 100vh;
            background: var(--ap-white);
            border-left: 1px solid var(--border-light);
            box-shadow: var(--shadow-lg);
            z-index: 200;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            display: flex;
            flex-direction: column;
        }
        .ai-drawer.open { transform: translateX(0); }
        /* === DRAWER HEADER - ARITA Design Philosophy ===
         * "단아하고 지적이며, 건강한 아름다움"
         * Amore (부드러움) + Pacific (강함)의 조화
         */
        .drawer-header {
            padding: 0;
            background: var(--ap-white);
            color: var(--pacific-blue);
            display: flex;
            flex-direction: column;
            border-bottom: 1px solid var(--border-light);
        }
        .drawer-header-top {
            padding: 24px 24px 20px 24px;
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
        }
        .drawer-header-left {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        /* AMOREPACIFIC 스타일 워드마크 */
        .drawer-wordmark {
            display: flex;
            align-items: baseline;
            gap: 0;
            margin-bottom: 8px;
        }
        .drawer-wordmark-amore {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 11px;
            font-weight: 600;
            color: var(--pacific-blue);
            letter-spacing: 2.5px;
        }
        .drawer-wordmark-pacific {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 11px;
            font-weight: 300;
            color: var(--pacific-blue);
            letter-spacing: 2.5px;
        }
        /* 타이틀 영역 */
        .drawer-title-area {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }
        .drawer-header h3 {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 18px;
            font-weight: 700;
            color: var(--pacific-blue);
            letter-spacing: -0.02em;
        }
        .drawer-header p {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            font-weight: 400;
            color: var(--text-secondary);
            letter-spacing: 0.5px;
        }
        /* 구분선 - 섬세한 그라데이션 */
        .drawer-divider {
            width: 100%;
            height: 3px;
            background: linear-gradient(90deg,
                var(--pacific-blue) 0%,
                var(--amore-blue) 50%,
                transparent 100%
            );
        }
        .drawer-close {
            width: 32px; height: 32px;
            background: transparent;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            color: var(--text-secondary);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }
        .drawer-close:hover {
            background: var(--bg-subtle);
            border-color: var(--pacific-blue);
            color: var(--pacific-blue);
        }
        .drawer-content { flex: 1; padding: 24px; overflow-y: auto; }
        .insight-section { margin-bottom: 28px; }
        .insight-section-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 16px;
            padding-left: 14px;
            border-left: 4px solid var(--amore-blue);
        }
        .insight-section-header h4 {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--amore-blue);
        }
        .insight-box {
            background: var(--bg-subtle);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            padding: 20px;
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 14px;
            line-height: 1.8;
            color: var(--pacific-blue);
        }
        .insight-box strong { color: var(--amore-blue); font-weight: 700; }
        .insight-box em { color: var(--pacific-blue); font-style: normal; font-weight: 600; }
        .insight-box .highlight-text {
            color: var(--amore-blue);
            font-weight: 700;
            text-decoration: underline;
            text-decoration-color: rgba(31, 87, 149, 0.3);
            text-underline-offset: 3px;
        }
        /* KPI 하이라이트 */
        .insight-kpi-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
            margin-top: 16px;
        }
        .insight-kpi-item {
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            border-radius: 6px;
            padding: 12px;
            text-align: center;
        }
        .insight-kpi-value {
            font-size: 20px;
            font-weight: 700;
            color: var(--pacific-blue);
        }
        .insight-kpi-value.positive { color: var(--amore-blue); }
        .insight-kpi-value.negative { color: var(--danger); }
        .insight-kpi-label {
            font-size: 10px;
            color: var(--text-secondary);
            margin-top: 4px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        /* Inference Path 개선 */
        .inference-path {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 24px 16px;
            background: var(--bg-subtle);
            border-radius: 8px;
            flex-wrap: wrap;
        }
        .path-node {
            padding: 10px 16px;
            background: var(--ap-white);
            border: 2px solid var(--border-light);
            border-radius: 20px;
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--ap-gray);
            transition: all 0.2s;
        }
        .path-node.highlight {
            border-color: var(--amore-blue);
            color: var(--ap-white);
            background: var(--amore-blue);
        }
        .path-arrow {
            color: var(--text-secondary);
            font-size: 18px;
        }
        /* Recommended Actions 개선 */
        .action-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        .action-item {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            padding: 14px 16px;
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            border-radius: 8px;
            transition: all 0.15s;
        }
        .action-item:hover {
            border-color: var(--amore-blue);
            box-shadow: 0 2px 8px rgba(31, 87, 149, 0.1);
        }
        .action-number {
            width: 24px;
            height: 24px;
            background: var(--amore-blue);
            color: var(--ap-white);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            flex-shrink: 0;
        }
        .action-content {
            flex: 1;
        }
        .action-title {
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 13px;
            font-weight: 600;
            color: var(--pacific-blue);
            margin-bottom: 4px;
        }
        .action-description {
            font-size: 12px;
            color: var(--text-secondary);
            line-height: 1.5;
        }
        .action-tag {
            display: inline-block;
            padding: 2px 8px;
            background: rgba(31, 87, 149, 0.1);
            color: var(--amore-blue);
            border-radius: 3px;
            font-size: 10px;
            font-weight: 500;
            margin-right: 6px;
        }
        .action-tag.urgent {
            background: rgba(139, 38, 53, 0.1);
            color: var(--danger);
        }
        /* Loading State */
        .drawer-loading {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }
        .drawer-loading-spinner {
            width: 40px;
            height: 40px;
            border: 3px solid var(--border-light);
            border-top-color: var(--amore-blue);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 16px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .drawer-actions {
            padding: 16px 24px;
            border-top: 1px solid var(--border-light);
            display: flex;
            gap: 10px;
        }
        .drawer-btn {
            flex: 1;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
            font-size: 12px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.15s;
        }
        .drawer-btn.primary {
            background: var(--pacific-blue);
            border: none;
            color: var(--ap-white);
        }
        .drawer-btn.primary:hover { background: var(--amore-blue); }
        .drawer-btn.secondary {
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            color: var(--pacific-blue);
        }
        .drawer-btn.secondary:hover { border-color: var(--amore-blue); }

        /* === EXPORT MODAL - Clean Professional === */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 28, 88, 0.5);
            z-index: 300;
            display: none;
            align-items: center;
            justify-content: center;
        }
        .modal-overlay.open { display: flex; }
        .modal-content {
            background: var(--ap-white);
            border-radius: 12px;
            width: 400px;
            padding: 28px;
            box-shadow: var(--shadow-lg);
        }
        .modal-header {
            display: flex;
            align-items: center;
            gap: 14px;
            margin-bottom: 24px;
        }
        .modal-icon {
            width: 44px; height: 44px;
            background: var(--amore-blue);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .modal-header h3 {
            font-size: 16px;
            font-weight: 600;
            color: var(--pacific-blue);
        }
        .modal-header p {
            font-size: 12px;
            color: var(--ap-gray);
            margin-top: 2px;
        }
        .form-group { margin-bottom: 20px; }
        .form-label {
            display: block;
            font-size: 10px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--ap-gray);
            margin-bottom: 8px;
        }
        .date-inputs { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
        .date-input {
            padding: 12px 14px;
            border: 1px solid var(--border-light);
            border-radius: 6px;
            font-size: 13px;
            outline: none;
            background: var(--ap-white);
            color: var(--pacific-blue);
        }
        .date-input:focus { border-color: var(--amore-blue); }
        .platform-fixed {
            padding: 12px 16px;
            background: var(--pacific-blue);
            color: var(--ap-white);
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            text-align: center;
        }
        .modal-actions { display: flex; gap: 10px; margin-top: 24px; }
        .modal-btn {
            flex: 1;
            padding: 12px;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.15s;
        }
        .modal-btn.cancel {
            background: var(--bg-subtle);
            border: none;
            color: var(--ap-gray);
        }
        .modal-btn.cancel:hover { background: var(--border-light); }
        .modal-btn.confirm {
            background: var(--amore-blue);
            border: none;
            color: var(--ap-white);
        }
        .modal-btn.confirm:hover { background: var(--pacific-blue); }

        .typing-indicator {
            display: flex;
            gap: 4px;
            padding: 12px 16px;
            background: var(--ap-white);
            border: 1px solid var(--border-light);
            border-radius: 12px 12px 12px 4px;
            width: fit-content;
        }
        .typing-indicator span {
            width: 6px; height: 6px;
            background: var(--amore-blue);
            border-radius: 50%;
            animation: typing 1s infinite;
        }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }
        @keyframes typing { 0%, 100% { opacity: 0.3; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">데이터를 불러오는 중...</div>
    </div>

    <div class="app-container">
        <!-- MOBILE HEADER (768px 이하에서 표시) -->
        <div class="mobile-header">
            <button class="menu-btn" onclick="toggleMobileSidebar()" aria-label="메뉴 열기">
                <i data-lucide="menu" style="width: 20px; height: 20px;"></i>
            </button>
            <div class="mobile-logo">
                <!-- AMOREPACIFIC 로고 (흰색 버전) -->
                <svg viewBox="0 0 200 24" height="20" fill="white" xmlns="http://www.w3.org/2000/svg">
                    <text x="0" y="18" font-family="'Noto Sans KR', sans-serif" font-size="14" font-weight="600" letter-spacing="1">AMORE</text>
                    <text x="58" y="18" font-family="'Noto Sans KR', sans-serif" font-size="14" font-weight="300" letter-spacing="1">PACIFIC</text>
                </svg>
            </div>
            <button class="chat-toggle-btn" onclick="toggleChatbot()" aria-label="AI 챗봇">
                <i data-lucide="message-circle" style="width: 16px; height: 16px;"></i>
                <span>AI</span>
            </button>
        </div>

        <!-- SIDEBAR OVERLAY (모바일용) -->
        <div class="sidebar-overlay" onclick="toggleMobileSidebar()"></div>

        <!-- CHATBOT OVERLAY (태블릿/모바일용) -->
        <div class="chatbot-overlay" onclick="toggleChatbot()"></div>

        <!-- SIDEBAR -->
        <aside class="sidebar" id="sidebar">
            <!-- 모바일 닫기 버튼 -->
            <button class="mobile-close-btn" onclick="toggleMobileSidebar()" aria-label="메뉴 닫기">
                <i data-lucide="x" style="width: 18px; height: 18px;"></i>
            </button>
            <div class="logo-section">
                <div class="logo-section-inner">
                    <!-- AMOREPACIFIC Wordmark - 우아하고 단아한 타이포그래피 -->
                    <div class="ap-wordmark">
                        <span class="ap-wordmark-amore">AMORE</span><span class="ap-wordmark-pacific">PACIFIC</span>
                    </div>
                    <!-- Subtle Divider - 섬세한 구분선 -->
                    <div class="ap-divider-line"></div>
                    <!-- AI Intelligence Label - 지적이고 절제된 -->
                    <div class="ai-label">AI Intelligence</div>
                </div>
                <div class="logo-nav-divider"></div>
            </div>
            <nav class="nav-section">
                <div class="nav-label">Main Views</div>
                <div class="nav-item active" onclick="switchPage('home')" data-page="home"><i data-lucide="home" style="width: 18px; height: 18px;"></i>Home</div>
                <div class="nav-item" onclick="switchPage('brand')" data-page="brand"><i data-lucide="building-2" style="width: 18px; height: 18px;"></i>Brand View (L1)</div>
                <div class="nav-item" onclick="switchPage('category')" data-page="category"><i data-lucide="layers" style="width: 18px; height: 18px;"></i>Category View (L2)</div>
                <div class="nav-item" onclick="switchPage('product')" data-page="product"><i data-lucide="box" style="width: 18px; height: 18px;"></i>Product View (L3)</div>
                <div class="nav-divider"></div>
                <div class="nav-label">Settings</div>
                <div class="nav-item" onclick="openAlertSettings()"><i data-lucide="bell" style="width: 18px; height: 18px;"></i>Alert Settings</div>
                <div class="nav-divider"></div>
                <div class="nav-label">Market Channel</div>
                <div class="channel-item"><span>🇺🇸 Amazon US</span><span class="channel-badge">Active</span></div>
            </nav>
        </aside>

        <!-- MAIN -->
        <div class="main-wrapper">
            <header class="header">
                <div class="header-left">
                    <div class="page-info"><h2 id="page-title">Home</h2><div class="breadcrumb" id="breadcrumb">Daily Insight & Action Board</div></div>
                </div>
                <div class="header-right">
                    <div class="time-display-group">
                        <div class="date-display" id="date-display">
                            <i data-lucide="database" class="date-icon"></i>
                            <span class="date-label">데이터</span>
                            <span class="date-value" id="date-value">로딩중...</span>
                        </div>
                        <div class="date-display current-time" id="current-time">
                            <i data-lucide="clock" class="date-icon"></i>
                            <span class="date-label">현재</span>
                            <span class="date-value" id="time-value">--:--:--</span>
                        </div>
                    </div>
                    <div class="platform-badge">🇺🇸 Amazon US</div>
                    <div class="currency-selector">
                        <button class="currency-btn active" data-currency="USD" onclick="changeCurrency('USD')">$ USD</button>
                        <button class="currency-btn" data-currency="KRW" onclick="changeCurrency('KRW')">₩ KRW</button>
                    </div>
                    <div class="exchange-rate-info" id="exchangeRateInfo"></div>
                    <button class="export-btn" onclick="openExportModal()"><i data-lucide="download" style="width: 16px; height: 16px;"></i>Export</button>
                </div>
            </header>

            <div class="content-wrapper">
                <main class="content-area">
                    <!-- HOME PAGE -->
                    <div id="page-home" class="page-view active">
                        <div class="insight-banner">
                            <div class="insight-content">
                                <div class="insight-brand-area">
                                    <div class="insight-brand-wordmark">
                                        <span class="amore">AMORE</span>
                                        <span class="pacific">PACIFIC</span>
                                    </div>
                                    <div class="insight-brand-divider"></div>
                                    <div class="insight-brand-label">AI Insight</div>
                                </div>
                                <div class="insight-text">
                                    <div class="insight-label">Daily AI Insight — LANEIGE</div>
                                    <div class="insight-message">Amazon US 내 <strong>라네즈</strong> 브랜드는 안정적인 상위권을 유지 중입니다. <strong>Lip Sleeping Mask</strong>가 상승세를 보이고 있으며, Water Bank Cream의 평점 변동에 주의가 필요합니다.</div>
                                </div>
                            </div>
                        </div>
                        <div class="status-grid">
                            <div class="status-card success" id="exposureStatusCard">
                                <div class="status-label">LANEIGE 노출 상태</div>
                                <div class="status-value"><i data-lucide="trending-up" style="width: 24px; height: 24px;"></i><span id="exposureStatusValue">Stable Up</span></div>
                                <div class="status-card-tooltip exposure-status-tooltip" id="exposureStatusTooltip">
                                    <div class="tooltip-title">노출 상태 기준</div>
                                    <div class="tooltip-criteria">
                                        <div class="criteria-item stable"><span class="criteria-dot"></span><span class="criteria-label">Stable Up</span><span class="criteria-desc">Top 10 내 3개 이상</span></div>
                                        <div class="criteria-item moderate"><span class="criteria-dot"></span><span class="criteria-label">Moderate</span><span class="criteria-desc">Top 10 내 1~2개</span></div>
                                        <div class="criteria-item attention"><span class="criteria-dot"></span><span class="criteria-label">Needs Attention</span><span class="criteria-desc">Top 10 내 0개</span></div>
                                    </div>
                                    <div class="tooltip-status">
                                        <div class="tooltip-status-label">현재 상태</div>
                                        <ul id="exposureStatusList">
                                            <li><span>Top 10 내 LANEIGE 제품: 로딩중...</span></li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            <div class="status-card info" id="categoryPositionCard">
                                <div class="status-label">카테고리 포지션</div>
                                <div class="status-value"><i data-lucide="bar-chart-3" style="width: 24px; height: 24px;"></i><span id="categoryPositionValue">Top 3</span></div>
                                <div class="status-card-tooltip category-position-tooltip" id="categoryPositionTooltip">
                                    <div class="tooltip-title">카테고리별 Top 순위</div>
                                    <ul id="categoryPositionList">
                                        <li><span>Lip Sleeping Mask - Lip Care 4위</span></li>
                                        <li><span>Lip Glowy Balm - Lip Makeup 12위</span></li>
                                    </ul>
                                </div>
                            </div>
                            <div class="status-card danger" id="warningProductsCard">
                                <div class="status-label">주의 제품</div>
                                <div class="status-value"><i data-lucide="alert-octagon" style="width: 24px; height: 24px;"></i><span id="warningCount">2개</span></div>
                                <div class="status-card-tooltip warning-tooltip align-right" id="warningTooltip">
                                    <div class="tooltip-title">주의 필요 제품</div>
                                    <div class="tooltip-criteria" style="font-size: 11px; margin-bottom: 12px;">
                                        <div class="criteria-item attention"><span class="criteria-dot"></span><span class="criteria-desc">순위 10위↓ / 평점 4.0↓ / 변동폭 20위↑</span></div>
                                    </div>
                                    <ul id="warningProductsList">
                                        <li><span>Water Bank Cream - 평점 하락</span></li>
                                        <li><span>Lip Glowy Balm - 순위 변동성</span></li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="content-grid single">
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title" style="position: relative;">
                                        <div class="card-title-icon"><i data-lucide="zap" style="color: white; width: 16px; height: 16px;"></i></div>
                                        Laneige 액션 보드
                                        <span class="help-icon-wrapper" style="margin-left: 6px; cursor: help; display: inline-flex; align-items: center;"
                                              onmouseenter="document.getElementById('actionBoardTooltip').style.display='block'"
                                              onmouseleave="document.getElementById('actionBoardTooltip').style.display='none'">
                                            <i data-lucide="help-circle" style="width: 14px; height: 14px; opacity: 0.6;"></i>
                                        </span>
                                        <div id="actionBoardTooltip" style="display: none; position: absolute; left: 0; top: 100%; margin-top: 12px; width: 320px; background: var(--ap-white); color: var(--pacific-blue); padding: 16px 20px; border-radius: 8px; border: 1px solid var(--border-light); font-size: 12px; z-index: 100; box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12); overflow: hidden;">
                                            <div style="position: absolute; top: 0; left: 0; width: 4px; height: 100%; background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%); border-radius: 8px 0 0 8px;"></div>
                                            <div style="font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-light); font-size: 11px; color: var(--amore-blue); text-transform: uppercase; letter-spacing: 1px;">액션 보드 선정 기준</div>
                                            <div style="line-height: 1.6; color: var(--text-secondary);">
                                                <p style="margin-bottom: 10px;"><strong style="color: var(--pacific-blue);">P1 (긴급)</strong><br>
                                                <span style="font-size: 11px;">• 순위 10위 이상 급락<br>• 평점 4.0 미만 하락<br>• Top 10 진입/이탈</span></p>
                                                <p style="margin-bottom: 10px;"><strong style="color: var(--pacific-blue);">P2 (주의)</strong><br>
                                                <span style="font-size: 11px;">• 순위 변동성 높음 (7일간 20위↑)<br>• 경쟁사 가격/프로모션 변화<br>• 리뷰 수 급증/급감</span></p>
                                                <p style="margin-bottom: 0; background: rgba(31, 87, 149, 0.06); padding: 10px 12px; border-radius: 6px; border-left: 3px solid var(--amore-blue);">
                                                <strong style="color: var(--pacific-blue);">액션 태그</strong><br>
                                                <span style="font-size: 11px;">CHECK: 즉시 확인 | MONITOR: 모니터링<br>DEEP DIVE: 심층 분석 필요</span></p>
                                            </div>
                                        </div>
                                    </div>
                                    <span class="card-badge danger" id="actionBoardBadge">4건 대기</span>
                                </div>
                                <div class="card-body" style="padding: 0;">
                                    <table class="action-table">
                                        <thead><tr><th>우선순위</th><th>제품</th><th>문제 신호</th><th>액션 태그</th><th>상세 분석</th></tr></thead>
                                        <tbody>
                                            <tr onclick="goToProductDetail('', 'Lip Sleeping Mask')"><td><span class="priority-badge p1">🔴 P1</span></td><td><div class="product-info"><div class="product-avatar">LN</div><div><div class="product-name">Lip Sleeping Mask</div><div class="product-brand">Berry</div></div></div></td><td>순위 3→2 (상향)</td><td><span class="action-tag monitor">MONITOR</span></td><td><a href="#" class="link-action" onclick="event.stopPropagation(); goToProductDetail('', 'Lip Sleeping Mask');">상세 분석 →</a></td></tr>
                                            <tr onclick="goToProductDetail('', 'Water Bank Cream')"><td><span class="priority-badge p1">🔴 P1</span></td><td><div class="product-info"><div class="product-avatar">LN</div><div><div class="product-name">Water Bank Cream</div><div class="product-brand">Blue Hyaluronic</div></div></div></td><td>평점 3.98 (하락)</td><td><span class="action-tag risk">CHECK</span></td><td><a href="#" class="link-action" onclick="event.stopPropagation(); goToProductDetail('', 'Water Bank Cream');">상세 분석 →</a></td></tr>
                                            <tr onclick="goToProductDetail('', 'Lip Glowy Balm')"><td><span class="priority-badge p2">🟠 P2</span></td><td><div class="product-info"><div class="product-avatar">LN</div><div><div class="product-name">Lip Glowy Balm</div><div class="product-brand">Berry</div></div></div></td><td>순위 변동성 높음</td><td><span class="action-tag deep">DEEP DIVE</span></td><td><a href="#" class="link-action" onclick="event.stopPropagation(); goToProductDetail('', 'Lip Glowy Balm');">상세 분석 →</a></td></tr>
                                            <tr onclick="goToProductDetail('', 'Cream Skin Toner')"><td><span class="priority-badge p2">🟠 P2</span></td><td><div class="product-info"><div class="product-avatar">LN</div><div><div class="product-name">Cream Skin Toner</div><div class="product-brand">Refiner</div></div></div></td><td>경쟁사 가격 하락</td><td><span class="action-tag monitor">MONITOR</span></td><td><a href="#" class="link-action" onclick="event.stopPropagation(); goToProductDetail('', 'Cream Skin Toner');">상세 분석 →</a></td></tr>
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        </div>
                        <div class="content-grid">
                            <!-- 카테고리별 시장점유율 막대그래프 -->
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title" style="position: relative;">
                                        <div class="card-title-icon"><i data-lucide="bar-chart-2" style="color: white; width: 16px; height: 16px;"></i></div>
                                        카테고리별 시장점유율 비교
                                        <span id="sosChartHelpIcon" class="help-icon-wrapper" style="margin-left: 6px; cursor: help; display: inline-flex; align-items: center;" onmouseenter="document.getElementById('sosChartTooltip').style.display='block'" onmouseleave="document.getElementById('sosChartTooltip').style.display='none'">
                                            <i data-lucide="help-circle" style="width: 14px; height: 14px; opacity: 0.6;"></i>
                                        </span>
                                        <div id="sosChartTooltip" class="sos-chart-tooltip" style="display: none; position: absolute; left: 0; top: 100%; margin-top: 12px; width: 340px; background: var(--ap-white); color: var(--pacific-blue); padding: 16px 20px; border-radius: 8px; border: 1px solid var(--border-light); font-size: 12px; z-index: 100; box-shadow: 0 8px 32px rgba(0, 28, 88, 0.12); overflow: hidden;">
                                            <div style="position: absolute; top: 0; left: 0; width: 4px; height: 100%; background: linear-gradient(180deg, var(--pacific-blue) 0%, var(--amore-blue) 100%); border-radius: 8px 0 0 8px;"></div>
                                            <div style="font-weight: 600; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid var(--border-light); font-size: 11px; color: var(--amore-blue); text-transform: uppercase; letter-spacing: 1px;">계산 기준 안내</div>
                                            <div style="line-height: 1.6; color: var(--text-secondary);">
                                                <p style="margin-bottom: 12px;"><strong style="color: var(--pacific-blue);">SoS (%)</strong><br>
                                                선택 기간의 <u>일 평균</u> 점유율입니다.<br>
                                                <span style="font-size: 11px; opacity: 0.8;">계산: (브랜드 제품 수 ÷ Top 100) × 100의 일 평균</span></p>
                                                <p style="margin-bottom: 12px;"><strong style="color: var(--pacific-blue);">제품 수</strong><br>
                                                선택 기간의 <u>일 평균</u> 개수입니다.<br>
                                                <span style="font-size: 11px; opacity: 0.8;">계산: 기간 내 총 출현 횟수 ÷ 기간 일수</span></p>
                                                <p style="margin-bottom: 12px;"><strong style="color: var(--pacific-blue);">출현율</strong><br>
                                                Top 100에 <u>진입한 날짜</u> 비율입니다.<br>
                                                <span style="font-size: 11px; opacity: 0.8;">계산: (진입 일수 ÷ 선택 기간) × 100%</span></p>
                                                <p style="margin-bottom: 0; background: rgba(31, 87, 149, 0.06); padding: 10px 12px; border-radius: 6px; border-left: 3px solid var(--amore-blue);">
                                                <strong style="color: var(--pacific-blue);">TIP</strong><br>
                                                출현율이 낮으면 간헐적 Top 100 진입,<br>
                                                출현율이 100%면 매일 안정적 진입을 의미합니다.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <!-- 필터 영역 -->
                                    <div class="sos-filters" style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap; align-items: center;">
                                        <div class="filter-group" style="display: flex; align-items: center; gap: 8px;">
                                            <label style="font-size: 12px; color: var(--text-secondary);">기간:</label>
                                            <input type="date" id="sosStartDate" style="padding: 6px 10px; border: 1px solid var(--border-light); border-radius: 6px; font-size: 12px;">
                                            <span style="color: var(--text-secondary);">~</span>
                                            <input type="date" id="sosEndDate" style="padding: 6px 10px; border: 1px solid var(--border-light); border-radius: 6px; font-size: 12px;">
                                        </div>
                                        <div class="filter-group" style="display: flex; align-items: center; gap: 8px; position: relative;">
                                            <label style="font-size: 12px; color: var(--text-secondary);">비교:</label>
                                            <div class="brand-dropdown-container" style="position: relative;">
                                                <button type="button" id="brandDropdownBtn" onclick="toggleBrandDropdown()" style="padding: 6px 12px; border: 1px solid var(--border-light); border-radius: 6px; font-size: 12px; background: white; cursor: pointer; display: flex; align-items: center; gap: 6px; min-width: 140px;">
                                                    <span id="brandDropdownLabel">브랜드 선택</span>
                                                    <i data-lucide="chevron-down" style="width: 14px; height: 14px;"></i>
                                                </button>
                                                <div id="brandDropdownMenu" style="display: none; position: absolute; top: 100%; left: 0; margin-top: 4px; background: white; border: 1px solid var(--border-light); border-radius: 8px; box-shadow: var(--shadow-lg); z-index: 1000; min-width: 200px; max-height: 250px; overflow-y: auto;">
                                                    <div style="padding: 8px; border-bottom: 1px solid var(--border-light);">
                                                        <input type="text" id="brandSearchInput" placeholder="브랜드 검색..." oninput="filterBrandList()" style="width: 100%; padding: 6px 10px; border: 1px solid var(--border-light); border-radius: 4px; font-size: 12px; box-sizing: border-box;">
                                                    </div>
                                                    <div id="brandCheckboxList" style="padding: 8px;">
                                                        <!-- 브랜드 체크박스 목록 -->
                                                    </div>
                                                </div>
                                            </div>
                                            <div id="selectedBrandTags" style="display: flex; gap: 4px; flex-wrap: wrap; max-width: 200px;">
                                                <!-- 선택된 브랜드 태그 -->
                                            </div>
                                        </div>
                                        <button onclick="updateSosChart()" style="padding: 6px 16px; background: var(--amore-blue); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer;">적용</button>
                                    </div>
                                    <div class="chart-container" style="height: 280px;">
                                        <canvas id="sosChart"></canvas>
                                    </div>
                                    <div id="sosNoDataMessage" style="display: none; text-align: center; padding: 40px; color: var(--text-secondary);">
                                        <i data-lucide="alert-circle" style="width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.5;"></i>
                                        <p>해당 기간에 데이터가 없습니다.</p>
                                    </div>
                                    <!-- 카테고리별 상세 정보 (계층적 트리) -->
                                    <div id="sosCategoryDetail" style="margin-top: 12px; padding: 12px; background: rgba(0, 28, 88, 0.03); border-radius: 8px;">
                                        <div style="font-size: 11px; color: var(--text-secondary); margin-bottom: 8px; display: flex; align-items: center; gap: 6px;">
                                            <i data-lucide="git-branch" style="width: 14px; height: 14px;"></i>
                                            카테고리 계층 구조 (클릭하여 펼치기/접기)
                                        </div>
                                        <div class="category-tree" id="sosCategoryDetailContent">
                                            <!-- 동적으로 채워짐 -->
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <!-- SoS 추이 차트 -->
                            <div class="card">
                                <div class="card-header" style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 8px;">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="trending-up" style="color: white; width: 16px; height: 16px;"></i></div>
                                        <span>Laneige 시장점유율 추이</span>
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip sos-trend-tooltip">
                                            <div class="tooltip-header">📊 시장점유율 (Share of Shelf)</div>
                                            <div class="tooltip-content">
                                                <p><strong>계산 방식</strong><br>해당 일자 Amazon Best Sellers Top 100 중<br>LANEIGE 제품 수 ÷ 100 × 100%</p>
                                                <p><strong>경쟁사 평균</strong><br>Top 10 브랜드(LANEIGE 제외)의<br>평균 시장점유율</p>
                                                <p class="tooltip-insight"><strong>해석</strong><br>• LANEIGE가 평균선 위 → 시장 우위<br>• 추이 상승 → 점유율 확대 중</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="sos-trend-date-range" style="display: flex; align-items: center; gap: 8px; font-size: 12px;">
                                        <label style="color: var(--text-secondary);">기간:</label>
                                        <input type="date" id="sosTrendStartDate" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                        <span style="color: var(--text-secondary);">~</span>
                                        <input type="date" id="sosTrendEndDate" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                        <button onclick="applySosTrendDateRange()" style="padding: 4px 12px; background: var(--amore-blue); color: white; border: none; border-radius: 4px; font-size: 11px; cursor: pointer;">적용</button>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <!-- 누락 날짜 안내 -->
                                    <div id="sosTrendMissingDates" class="missing-dates-alert" style="display: none; margin-bottom: 8px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="sosTrendMissingDatesText"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="chart-container"><canvas id="trendChart"></canvas></div>
                                </div>
                            </div>
                        </div>
                        <div class="quick-actions">
                            <button class="quick-action-btn secondary" onclick="switchPage('category')"><i data-lucide="layers" style="width: 18px; height: 18px;"></i>카테고리별 분석</button>
                            <button class="quick-action-btn secondary" onclick="switchPage('product')"><i data-lucide="box" style="width: 18px; height: 18px;"></i>제품 상세 분석</button>
                            <button class="quick-action-btn primary" onclick="toggleChatbot()"><i data-lucide="message-square" style="width: 18px; height: 18px;"></i>AI에게 질문하기</button>
                        </div>
                    </div>

                    <!-- BRAND PAGE (L1) -->
                    <div id="page-brand" class="page-view">
                        <div class="kpi-grid">
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">Laneige 시장점유율 <i data-lucide="help-circle" class="help-icon"></i></div>
                                <div class="kpi-value">44.0<span class="unit">%</span></div>
                                <span class="kpi-delta up">▲ 2.1%p</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📊 시장점유율 (SoS: Share of Shelf)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>전체 Top 100 중 LANEIGE 제품이 차지하는 비율</p>
                                        <p><strong>계산</strong><br>LANEIGE 제품 수 ÷ 100 × 100%</p>
                                        <p><strong>해석</strong><br>• 높을수록 진열 점유율 우수<br>• %p 변화는 전일 대비 변동</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">Top10 제품수 <i data-lucide="help-circle" class="help-icon"></i></div>
                                <div class="kpi-value">4<span class="unit">개</span></div>
                                <span class="kpi-delta up">+1 증가</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">🏆 Top10 제품수</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>베스트셀러 Top 10 내 LANEIGE 제품 수</p>
                                        <p><strong>중요성</strong><br>상위권 노출이 브랜드 인지도와 매출에 직결</p>
                                        <p><strong>해석</strong><br>• 숫자가 높을수록 상위권 장악력 우수<br>• 증감은 전일 대비 변화</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">평균순위 <i data-lucide="help-circle" class="help-icon"></i></div>
                                <div class="kpi-value">53.6<span class="unit">위</span></div>
                                <span class="kpi-delta up">▼ 2.3위 개선</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📈 평균순위 (Avg Rank)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>LANEIGE 모든 제품의 평균 베스트셀러 순위</p>
                                        <p><strong>계산</strong><br>각 제품 순위의 합 ÷ 제품 수</p>
                                        <p><strong>해석</strong><br>• 숫자가 낮을수록 상위권<br>• ▼ 는 순위 상승 (개선)</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">시장집중도 (HHI) <i data-lucide="help-circle" class="help-icon"></i></div>
                                <div class="kpi-value">0.35</div>
                                <span class="kpi-delta">중간 집중도</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📉 시장집중도 (HHI: Herfindahl Index)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>시장 집중도를 측정하는 경제학 지표</p>
                                        <p><strong>계산</strong><br>각 브랜드 SoS(%)² 의 합</p>
                                        <p><strong>해석</strong><br>• 0.25 이상: 고집중 시장<br>• 0.15~0.25: 중간 집중<br>• 0.15 미만: 분산 시장<br>• 높을수록 소수 브랜드 독점</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="content-grid brand-analysis-grid">
                            <div class="card">
                                <div class="card-header" style="flex-wrap: wrap; gap: 8px;">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="scatter-chart" style="color: white; width: 16px; height: 16px;"></i></div>
                                        <span>Laneige vs 경쟁사 시장점유율 × 평균순위</span>
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">📊 지표 설명</div>
                                            <div class="tooltip-content">
                                                <p><strong>시장점유율 (SoS)</strong><br>Top 100 중 해당 브랜드 제품 비율 (%)<br>예: 5% = Top 100 중 5개 제품 보유</p>
                                                <p><strong>평균순위 (Avg Rank)</strong><br>해당 브랜드 제품들의 평균 순위<br>숫자가 낮을수록 상위권</p>
                                                <p><strong>해석</strong><br>• 우측 하단: 점유율 高 + 순위 高 (이상적)<br>• 좌측 상단: 점유율 低 + 순위 低 (개선 필요)</p>
                                            </div>
                                            <div class="tooltip-period-info" id="brandMatrixPeriodInfo">
                                                📅 분석 기간: 로딩 중...
                                            </div>
                                        </div>
                                    </div>
                                    <div class="chart-date-range" id="brandMatrixDateRange">
                                        <label>기간:</label>
                                        <input type="date" id="brandMatrixStartDate" />
                                        <span class="date-separator">~</span>
                                        <input type="date" id="brandMatrixEndDate" />
                                        <button class="apply-btn" onclick="applyBrandMatrixDateRange()">적용</button>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <!-- 데이터 요약 카드 -->
                                    <div class="data-summary-card" id="brandMatrixSummary">
                                        <div class="data-summary-icon">
                                            <i data-lucide="bar-chart-2" style="width: 16px; height: 16px; color: white;"></i>
                                        </div>
                                        <div class="data-summary-content">
                                            <div class="data-summary-item">
                                                <span class="data-summary-label">📅 분석 기간:</span>
                                                <span class="data-summary-value" id="brandMatrixPeriodText">-</span>
                                            </div>
                                            <div class="data-summary-item">
                                                <span class="data-summary-label">브랜드 수:</span>
                                                <span class="data-summary-value" id="brandMatrixBrandCount">-</span>
                                            </div>
                                            <div class="data-summary-item">
                                                <span class="data-summary-label">데이터 포인트:</span>
                                                <span class="data-summary-value" id="brandMatrixDataPoints">-</span>
                                            </div>
                                            <span class="data-summary-timestamp" id="brandMatrixTimestamp">업데이트: -</span>
                                        </div>
                                    </div>
                                    <div class="chart-container chart-container-large" id="brandMatrixChartContainer">
                                        <canvas id="brandMatrixChart"></canvas>
                                        <!-- 차트 로딩 오버레이 -->
                                        <div class="chart-loading-overlay" id="brandMatrixLoadingOverlay">
                                            <div class="chart-loading-wave">
                                                <span></span><span></span><span></span><span></span><span></span>
                                            </div>
                                            <div class="chart-loading-text">데이터 분석 중...</div>
                                        </div>
                                    </div>
                                    <div class="chart-guide" style="margin-top: 16px;"><strong>해석 가이드:</strong> 우측 하단 = 물량 多 + 상위권 강함 (정상 성장) / 우측 상단 = 물량 多 + 상위권 약함 (효율 악화)</div>
                                    <div class="data-gap-warning" id="brandMatrixDataGap" style="display: none;">
                                        <i data-lucide="alert-triangle"></i>
                                        <span id="brandMatrixDataGapText">데이터 없는 기간이 있습니다.</span>
                                    </div>
                                </div>
                            </div>
                            <!-- 경쟁사 비교 테이블 -->
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="users" style="color: white; width: 16px; height: 16px;"></i></div>
                                        경쟁사 비교 분석
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">📊 경쟁사 선정 기준</div>
                                            <div class="tooltip-content">
                                                <p><strong>선정 기준</strong><br>모니터링 중인 5개 카테고리 Top 100 내 제품 보유 브랜드</p>
                                                <p><strong>SoS 기준 정렬</strong><br>Share of Shelf(진열 점유율) 높은 순서로 Top 5 표시</p>
                                                <p><strong>모니터링 카테고리</strong><br>• Beauty & Personal Care (L0)<br>&nbsp;&nbsp;└ Skin Care (L1) → Lip Care (L2)<br>&nbsp;&nbsp;└ Make Up → Lip Makeup (L2), Face Powder (L3)</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="chart-date-range" id="competitorDateRange">
                                        <label>기간:</label>
                                        <input type="date" id="competitorStartDate">
                                        <span class="date-separator">~</span>
                                        <input type="date" id="competitorEndDate">
                                        <button class="apply-btn" onclick="applyCompetitorDateRange()">적용</button>
                                    </div>
                                    <span class="card-badge" id="competitor-period-badge" style="background: rgba(31, 87, 149, 0.1); color: var(--amore-blue);">최근 7일</span>
                                </div>
                                <div class="card-body" style="padding: 0;">
                                    <div id="competitor-table-missing-dates" class="missing-dates-alert" style="display: none; margin: 12px 16px 0 16px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="competitor-table-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <table class="action-table" id="competitor-table">
                                        <thead>
                                            <tr>
                                                <th class="has-tooltip">
                                                    <span class="th-content">순위 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip">시장점유율 기준 순위입니다. 1위가 가장 높은 점유율을 보유합니다.</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">브랜드 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip">Top 100 내 제품을 보유한 브랜드입니다. LANEIGE가 기준점으로 표시됩니다.</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">점유율 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip"><strong>시장점유율 (SoS)</strong><br>Top 100 중 해당 브랜드 제품 비율(%). 예: 5% = 100개 중 5개 제품 보유</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">제품수 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip">해당 브랜드가 Top 100 내에 보유한 제품 개수입니다.</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">평균순위 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip">해당 브랜드 모든 제품의 평균 베스트셀러 순위입니다. 숫자가 낮을수록 상위권입니다.</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">평균가격 <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip"><strong>평균 판매가</strong><br>해당 브랜드 Top 100 제품들의 평균 판매 가격(USD)입니다.</div>
                                                </th>
                                                <th class="has-tooltip">
                                                    <span class="th-content">vs Laneige <i data-lucide="help-circle" class="help-icon"></i></span>
                                                    <div class="th-tooltip">LANEIGE 대비 점유율 차이(%p)입니다.<br>• 양수(+): LANEIGE보다 높음<br>• 음수(-): LANEIGE보다 낮음</div>
                                                </th>
                                            </tr>
                                        </thead>
                                        <tbody id="competitor-tbody">
                                            <tr class="highlight-row">
                                                <td><span class="rank-badge">#1</span></td>
                                                <td><strong>LANEIGE</strong></td>
                                                <td>4.0%</td>
                                                <td>8개</td>
                                                <td>25.3위</td>
                                                <td>$26.89</td>
                                                <td><span class="vs-badge baseline">기준</span></td>
                                            </tr>
                                            <tr>
                                                <td><span class="rank-badge">#2</span></td>
                                                <td>COSRX</td>
                                                <td>3.8%</td>
                                                <td>12개</td>
                                                <td>32.1위</td>
                                                <td>$19.85</td>
                                                <td><span class="vs-badge behind">-0.2%p</span></td>
                                            </tr>
                                            <tr>
                                                <td><span class="rank-badge">#3</span></td>
                                                <td>Summer Fridays</td>
                                                <td>3.2%</td>
                                                <td>4개</td>
                                                <td>15.8위</td>
                                                <td>$41.99</td>
                                                <td><span class="vs-badge behind">-0.8%p</span></td>
                                            </tr>
                                            <tr>
                                                <td><span class="rank-badge">#4</span></td>
                                                <td>e.l.f.</td>
                                                <td>2.9%</td>
                                                <td>18개</td>
                                                <td>45.2위</td>
                                                <td>$8.50</td>
                                                <td><span class="vs-badge behind">-1.1%p</span></td>
                                            </tr>
                                            <tr>
                                                <td><span class="rank-badge">#5</span></td>
                                                <td>Rare Beauty</td>
                                                <td>2.5%</td>
                                                <td>6개</td>
                                                <td>28.4위</td>
                                                <td>$24.00</td>
                                                <td><span class="vs-badge behind">-1.5%p</span></td>
                                            </tr>
                                        </tbody>
                                    </table>
                                    <div class="chart-guide" style="margin: 16px;"><strong>해석 가이드:</strong> 점유율 高 = 시장점유율 우위 / 평균순위 低 = 상위권 집중 / vs LANEIGE (+)%p = LANEIGE보다 점유율 높음</div>
                                </div>
                            </div>
                        </div>

                        <!-- Enhanced Competitor Comparison Section -->
                        <div class="content-grid single">
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="target" style="color: white; width: 16px; height: 16px;"></i></div>
                                        상세 경쟁사 비교
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">🎯 상세 경쟁사 비교</div>
                                            <div class="tooltip-content">
                                                <p><strong>기능</strong><br>선택한 경쟁사와 LANEIGE의 핵심 지표를 1:1 비교 분석합니다.</p>
                                                <p><strong>비교 항목</strong><br>• 시장점유율 차이<br>• 평균 순위 비교<br>• 제품 수량 대비<br>• 평균 가격 비교</p>
                                                <p><strong>활용법</strong><br>드롭다운에서 경쟁사를 선택하면 상세 비교 정보가 표시됩니다.</p>
                                            </div>
                                        </div>
                                    </div>
                                    <!-- 기간 선택 추가 -->
                                    <div class="chart-date-range" id="detailedComparisonDateRange">
                                        <label>기간:</label>
                                        <input type="date" id="detailedCompStartDate">
                                        <span class="date-separator">~</span>
                                        <input type="date" id="detailedCompEndDate">
                                        <button class="apply-btn" onclick="applyDetailedComparisonDateRange()">적용</button>
                                    </div>
                                    <span class="card-badge" id="detailed-comparison-period-badge" style="background: rgba(31, 87, 149, 0.1); color: var(--amore-blue);">최근 7일</span>
                                    <div class="competitor-selector">
                                        <span class="competitor-label">비교 대상:</span>
                                        <select id="competitor-select" class="competitor-dropdown" onchange="updateCompetitorComparison()">
                                            <option value="">선택하세요</option>
                                            <option value="Summer Fridays">Summer Fridays (프리미엄 경쟁사)</option>
                                            <!-- 나머지 옵션은 동적으로 추가됨 -->
                                        </select>
                                    </div>
                                </div>
                                <div class="card-body" id="detailed-comparison-body">
                                    <div style="text-align: center; padding: 40px 0; color: var(--text-secondary);">
                                        <i data-lucide="users" style="width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.3;"></i>
                                        <p>비교할 경쟁사를 선택하세요</p>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="quick-actions"><button class="quick-action-btn accent" onclick="openAIDrawer()"><i data-lucide="sparkles" style="width: 18px; height: 18px;"></i>AI 전략 인사이트</button></div>
                    </div>

                    <!-- CATEGORY PAGE (L2) -->
                    <div id="page-category" class="page-view">
                        <!-- 카테고리 계층 구조:
                             Beauty & Personal Care (L0)
                             ├── Skin Care (L1)
                             │   └── Lip Care (L2)
                             └── Make Up (L1)
                                 ├── Lip Makeup (L2)
                                 └── Face (L2)
                                     └── Face Powder (L3)
                        -->
                        <div class="category-header-row" style="display: flex; align-items: center; margin-bottom: 16px;">
                            <div class="section-title" style="font-size: 14px; font-weight: 600; color: var(--pacific-blue); display: flex; align-items: center;">
                                <i data-lucide="bar-chart-2" style="width: 16px; height: 16px; margin-right: 6px;"></i>
                                카테고리별 KPI 현황
                                <span style="margin-left: 12px; font-size: 11px; font-weight: 400; color: var(--text-secondary); background: rgba(0, 28, 88, 0.06); padding: 3px 8px; border-radius: 4px;">
                                    최근 7일
                                </span>
                            </div>
                        </div>
                        <div class="category-tabs">
                            <div class="category-tab active" onclick="selectCategory('beauty', this)" title="Amazon Best Sellers in Beauty & Personal Care (전체 뷰티 랭킹, Level 0)" data-level="0" data-parent="">Beauty & Personal Care</div>
                            <div class="category-tab" onclick="selectCategory('skin', this)" title="Beauty > Skin Care (Node ID: 11060451, Level 1)" data-level="1" data-parent="beauty">Skin Care</div>
                            <div class="category-tab" onclick="selectCategory('lip', this)" title="Beauty > Skin Care > Lip Care (Node ID: 3761351, Level 2)" data-level="2" data-parent="skin_care">Lip Care</div>
                            <div class="category-tab" onclick="selectCategory('lip_makeup', this)" title="Beauty > Makeup > Lips (Node ID: 11059031, Level 2)" data-level="2" data-parent="makeup">Lip Makeup</div>
                            <div class="category-tab" onclick="selectCategory('face_powder', this)" title="Beauty > Makeup > Face > Powder (Node ID: 11058971, Level 3)" data-level="3" data-parent="face_makeup">Face Powder</div>
                        </div>
                        <div class="kpi-grid">
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">카테고리 점유율 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="cat-sos">18.5<span class="unit">%</span></div>
                                <span class="kpi-delta up" id="cat-sos-badge">Category Leader</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📊 카테고리 점유율 (SoS)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>해당 카테고리 Top 100 중 Laneige 제품이 차지하는 비율</p>
                                        <p><strong>해석 기준</strong><br>• 15% 이상: Category Leader<br>• 10~15%: 점유율 확대 필요<br>• 10% 미만: 점유율 확대 시급</p>
                                        <p><strong>의미</strong><br>높을수록 카테고리 내 존재감이 크며, 소비자 선택 가능성이 높음</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">Laneige Rank <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="cat-rank">#2</div>
                                <span class="kpi-delta up" id="cat-rank-badge">1위 근접</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">🏆 Laneige Rank</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>Laneige 제품 중 해당 카테고리에서 가장 높은 순위</p>
                                        <p><strong>해석 기준</strong><br>• 1~3위: 1위 근접 (우수)<br>• 4~10위: Top 10 (양호)<br>• 11위 이하: 순위 개선 필요</p>
                                        <p><strong>의미</strong><br>숫자가 낮을수록 좋으며, 카테고리 내 경쟁력을 나타냄</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">가격경쟁력 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="cat-cpi">44<span class="unit">점</span></div>
                                <span class="kpi-delta down" id="cat-cpi-badge">가격 경쟁력 하락</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">💰 가격경쟁력 점수</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>경쟁사 대비 Laneige 가격 경쟁력 (100점 만점)</p>
                                        <p><strong>해석 기준</strong><br>• 100점 = 가격 경쟁력 최고 (경쟁사보다 저가)<br>• 50점 = 경쟁사와 동일 가격<br>• 0점 = 가격 경쟁력 최저 (경쟁사 대비 2배 고가)</p>
                                        <p><strong>상태 분류</strong><br>• 90점 이상: 가격 경쟁력 우위<br>• 50~90점: 적정 가격<br>• 50점 미만: 가격 경쟁력 하락</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">신규 경쟁자 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="cat-new">18<span class="unit">개</span></div>
                                <span class="kpi-delta down" id="cat-new-badge">경쟁 심화</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">🆕 신규 경쟁자</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>최근 7일 내 Top 100에 새로 진입한 경쟁 브랜드/제품 수</p>
                                        <p><strong>해석 기준</strong><br>• 15개 이상: 경쟁 심화<br>• 5~15개: 보통<br>• 5개 미만: 안정적</p>
                                        <p><strong>의미</strong><br>많을수록 시장 경쟁이 치열하며, 순위 변동 가능성 높음</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="content-grid single">
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="bar-chart" style="color: white; width: 16px; height: 16px;"></i></div>
                                        가격경쟁력 점수 추이
                                        <div class="period-selector" id="cpiPeriodSelector" style="margin-left: 12px;">
                                            <button class="period-btn active" data-days="7">7일</button>
                                            <button class="period-btn" data-days="14">14일</button>
                                            <button class="period-btn" data-days="30">30일</button>
                                            <button class="period-btn" data-days="custom">직접설정</button>
                                        </div>
                                        <div id="cpiCustomDateRange" class="chart-date-range" style="display: none; margin-left: 8px;">
                                            <input type="date" id="cpiCustomStartDate" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                            <span class="date-separator">~</span>
                                            <input type="date" id="cpiCustomEndDate" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 11px;">
                                            <button class="apply-btn" onclick="applyCpiCustomDateRange()" style="padding: 4px 10px; font-size: 11px;">적용</button>
                                        </div>
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">📈 가격경쟁력 점수 추이</div>
                                            <div class="tooltip-content">
                                                <p><strong>차트 설명</strong><br>LANEIGE 가격 경쟁력을 100점 만점으로 일별 추적합니다.</p>
                                                <p><strong>기준선 해석</strong><br>• 파란 실선: LANEIGE 가격경쟁력 점수<br>• 점선 (50): 경쟁사 동일 가격 기준</p>
                                                <p><strong>활용법</strong><br>점수가 높을수록 가격 경쟁력 우위, 50점 미만이면 경쟁력 하락</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <!-- 누락 날짜 안내 -->
                                    <div id="cpiMissingDates" class="missing-dates-alert" style="display: none; margin-bottom: 8px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="cpiMissingDatesText"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="chart-container" style="height: 350px;"><canvas id="cpiChart"></canvas></div>
                                    <div class="chart-guide">
                                        <strong>CPI (Competitive Price Index):</strong> LANEIGE 평균가 / 경쟁사 Top 100 평균가 × 100<br>
                                        <span style="color: var(--text-secondary); font-size: 11px; margin-top: 4px; display: inline-block;">
                                            100 이상 = 프리미엄 포지셔닝 / 100 미만 = 가격 경쟁력 우위
                                        </span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- PRODUCT PAGE (L3) -->
                    <div id="page-product" class="page-view">
                        <div class="product-header-row">
                            <div class="selector-group">
                                <span class="selector-label">카테고리</span>
                                <div class="selector-wrapper">
                                    <select class="selector-dropdown" id="productCategory" onchange="updateProductList()">
                                        <option value="beauty">Beauty & Personal Care</option>
                                        <option value="skin_care">Skin Care</option>
                                        <option value="lip_care">Lip Care</option>
                                        <option value="lip_makeup">Lip Makeup</option>
                                        <option value="face_powder">Face Powder</option>
                                    </select>
                                    <div class="selector-tooltip">
                                        <div class="selector-tooltip-header">📁 카테고리 선택</div>
                                        <div class="selector-tooltip-content">
                                            <p><strong>기능</strong><br>분석할 Amazon 베스트셀러 카테고리를 선택합니다.</p>
                                            <p><strong>카테고리 계층</strong></p>
                                            <ul>
                                                <li>Beauty & Personal Care (전체)</li>
                                                <li>↳ Skin Care → Lip Care</li>
                                                <li>↳ Makeup → Lip Makeup, Face Powder</li>
                                            </ul>
                                            <p><strong>선택 시</strong><br>해당 카테고리 내 LANEIGE 제품 목록이 업데이트됩니다.</p>
                                        </div>
                                    </div>
                                </div>
                                <span class="selector-label">제품</span>
                                <div class="selector-wrapper">
                                    <select class="selector-dropdown" id="productSelect" onchange="updateProductView()">
                                        <option value="lip-mask-berry">Lip Sleeping Mask (Berry)</option>
                                        <option value="lip-mask-original">Lip Sleeping Mask (Original)</option>
                                        <option value="lip-glowy">Lip Glowy Balm</option>
                                    </select>
                                    <div class="selector-tooltip">
                                        <div class="selector-tooltip-header">📦 제품 선택</div>
                                        <div class="selector-tooltip-content">
                                            <p><strong>선택 기준</strong><br>선택한 카테고리의 Top 100 내 LANEIGE 제품이 표시됩니다.</p>
                                            <p><strong>정렬 방식</strong><br>베스트셀러 순위가 높은 제품이 먼저 표시됩니다.</p>
                                            <p><strong>대시보드 정보</strong></p>
                                            <ul>
                                                <li>현재순위: 베스트셀러 순위</li>
                                                <li>순위변동성: 7일간 순위 변동 폭</li>
                                                <li>고객평점: Amazon 평점</li>
                                                <li>순위고착도: Top 100 연속 등장 일수</li>
                                            </ul>
                                            <p><strong>차트</strong><br>순위/가격 추이, 제품 매트릭스, 할인율 분석</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="fixed-date-badge" style="margin-left: 16px;">최근 7일</div>
                            </div>
                            <!-- 숨겨진 날짜 필드 (JS에서 사용) -->
                            <input type="hidden" id="productStartDate">
                            <input type="hidden" id="productEndDate">
                        </div>
                        <div class="kpi-grid">
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">현재순위 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="prod-rank">#2</div>
                                <span class="kpi-delta up" id="prod-rank-delta">▲ 1위 상승</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">🏆 현재순위</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>선택한 제품의 현재 베스트셀러 순위</p>
                                        <p><strong>해석</strong><br>• 1~10위: 최상위권<br>• 11~50위: 상위권<br>• 51~100위: 중위권</p>
                                        <p><strong>변동</strong><br>전일 대비 순위 변화를 함께 표시</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">순위변동성 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="prod-vol">12<span class="unit">pt</span></div>
                                <span class="kpi-delta" id="prod-vol-delta">안정적</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📊 순위변동성 (Volatility)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>최근 7일간 순위 변동 표준편차</p>
                                        <p><strong>해석 기준</strong><br>• 10pt 미만: 매우 안정<br>• 10~20pt: 안정적<br>• 20~30pt: 변동성 높음<br>• 30pt 이상: 불안정</p>
                                        <p><strong>의미</strong><br>낮을수록 순위가 안정적으로 유지됨</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">고객평점 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="prod-rating">4.5<span class="unit">★</span></div>
                                <span class="kpi-delta up" id="prod-rating-delta">상위 10%</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">⭐ 고객평점</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>Amazon 고객 평점 (5.0 만점)</p>
                                        <p><strong>해석 기준</strong><br>• 4.5 이상: 상위 10%<br>• 4.0~4.5: 양호<br>• 4.0 미만: 개선 필요</p>
                                        <p><strong>의미</strong><br>고객 만족도와 제품 품질 지표</p>
                                    </div>
                                </div>
                            </div>
                            <div class="kpi-card has-tooltip">
                                <div class="kpi-label">순위고착도 <i data-lucide="help-circle" class="help-icon" style="width: 12px; height: 12px;"></i></div>
                                <div class="kpi-value" id="prod-stick">92<span class="unit">pt</span></div>
                                <span class="kpi-delta up" id="prod-stick-delta">고착화 높음</span>
                                <div class="kpi-tooltip">
                                    <div class="tooltip-header">📌 순위고착도 (Stickiness)</div>
                                    <div class="tooltip-content">
                                        <p><strong>정의</strong><br>Top 100 내 연속 등장 일수 기반 점수</p>
                                        <p><strong>해석 기준</strong><br>• 90pt 이상: 고착화 높음<br>• 70~90pt: 중간<br>• 70pt 미만: 불안정</p>
                                        <p><strong>의미</strong><br>높을수록 베스트셀러 지위가 안정적</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="content-grid">
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="line-chart" style="color: white; width: 16px; height: 16px;"></i></div>
                                        순위 & 가격 추이 (vs 카테고리 1위)
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">📈 순위 & 가격 추이</div>
                                            <div class="tooltip-content">
                                                <p><strong>차트 설명</strong><br>Laneige 제품과 카테고리 1위 제품의 순위/가격을 비교합니다.</p>
                                                <p><strong>라인 구분</strong><br>• 실선: Laneige 제품<br>• 점선: 카테고리 1위 비교 대상</p>
                                                <p><strong>활용법</strong><br>경쟁사 대비 순위 추세와 가격 변동 패턴을 파악</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="chart-date-range" id="rankTrendDateRange">
                                        <label>기간:</label>
                                        <input type="date" id="rankTrendStartDate">
                                        <span class="date-separator">~</span>
                                        <input type="date" id="rankTrendEndDate">
                                        <button class="apply-btn" onclick="applyRankTrendDateRange()">적용</button>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div class="product-selector-row" style="margin-bottom: 12px; display: flex; align-items: center; gap: 12px;">
                                        <label style="font-weight: 500; color: var(--text-secondary); white-space: nowrap;">제품 선택:</label>
                                        <div class="custom-dropdown" id="productDropdown" style="position: relative; min-width: 280px;">
                                            <button type="button" class="dropdown-toggle" id="productDropdownToggle" onclick="toggleProductDropdown()" style="width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 6px; background: white; cursor: pointer; display: flex; justify-content: space-between; align-items: center; font-size: 13px;">
                                                <span id="productDropdownLabel">전체 제품</span>
                                                <i data-lucide="chevron-down" style="width: 16px; height: 16px; opacity: 0.6;"></i>
                                            </button>
                                            <div class="dropdown-menu" id="productDropdownMenu" style="display: none; position: absolute; top: 100%; left: 0; right: 0; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; max-height: 300px; overflow-y: auto; margin-top: 4px;">
                                                <div class="dropdown-item" style="padding: 8px 12px; border-bottom: 1px solid #eee;">
                                                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 13px;">
                                                        <input type="checkbox" id="productSelectAll" checked onchange="toggleAllProducts(this.checked)" style="width: 16px; height: 16px;">
                                                        <span style="font-weight: 500;">전체 선택</span>
                                                    </label>
                                                </div>
                                                <div id="productCheckboxList"></div>
                                            </div>
                                        </div>
                                    </div>
                                    <div id="rank-missing-dates" class="missing-dates-alert" style="display: none; margin-bottom: 12px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="rank-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <!-- 하위권 순위 정보 표시 컨테이너 -->
                                    <div id="outlier-info" style="display: none; margin-bottom: 12px;"></div>
                                    <div class="chart-container"><canvas id="rankTrendChart"></canvas></div>
                                    <div class="chart-guide"><strong>비교 대상:</strong> Summer Fridays Lip Butter Balm (현재 카테고리 1위)</div>
                                </div>
                            </div>
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="grid-3x3" style="color: white; width: 16px; height: 16px;"></i></div>
                                        Laneige 제품 매트릭스
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">🎯 Laneige 제품 매트릭스</div>
                                            <div class="tooltip-content">
                                                <p><strong>차트 설명</strong><br>X축(순위)과 Y축(변동성)으로 제품 포지션을 시각화합니다.</p>
                                                <p><strong>4분면 해석</strong><br>• 좌하단(King): 안정적 상위권<br>• 좌상단(Rising): 급부상 중<br>• 우하단(Lagging): 정체<br>• 우상단(Risk): 위험</p>
                                                <p><strong>버블 크기</strong><br>제품의 리뷰 수 또는 중요도 반영</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="chart-date-range" id="matrixDateRange">
                                        <label>기간:</label>
                                        <input type="date" id="matrixStartDate">
                                        <span class="date-separator">~</span>
                                        <input type="date" id="matrixEndDate">
                                        <button class="apply-btn" onclick="applyMatrixDateRange()">적용</button>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div id="matrix-missing-dates" class="missing-dates-alert" style="display: none; margin-bottom: 12px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="matrix-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="chart-container"><canvas id="productMatrixChart"></canvas></div>
                                    <div class="chart-guide"><strong>4분면 해석:</strong> 좌하단(King) = 안정적 상위권 / 좌상단(Rising) = 급부상 / 우하단(Lagging) = 정체 / 우상단(Risk) = 위험</div>
                                </div>
                            </div>
                        </div>
                        <!-- 할인율 추이 그래프 -->
                        <div class="content-grid single">
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="percent" style="color: white; width: 16px; height: 16px;"></i></div>
                                        가격 & 할인율 추이
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">💵 가격 & 할인율 추이</div>
                                            <div class="tooltip-content">
                                                <p><strong>차트 설명</strong><br>제품의 판매가와 할인율을 일별로 추적합니다.</p>
                                                <p><strong>라인 구분</strong><br>• 파란 실선: 판매가 ($)<br>• 노란 점선: 할인율 (%)</p>
                                                <p><strong>해석 가이드</strong><br>• 할인율↑: 프로모션 강화<br>• 가격↓: 가격 경쟁력 확보</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <label style="font-size: 12px; color: #666;">제품:</label>
                                            <select id="discountProductSelect" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; max-width: 200px;">
                                                <option value="">제품 선택...</option>
                                            </select>
                                        </div>
                                        <div class="chart-date-range" id="discountDateRange">
                                            <label>기간:</label>
                                            <input type="date" id="discountStartDate">
                                            <span class="date-separator">~</span>
                                            <input type="date" id="discountEndDate">
                                            <button class="apply-btn" onclick="applyDiscountDateRange()">적용</button>
                                        </div>
                                        <span class="card-badge" id="discount-badge" style="background: rgba(31, 87, 149, 0.1); color: var(--amore-blue);">현재 할인율: --%</span>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div id="discount-missing-dates" class="missing-dates-alert" style="display: none; margin-bottom: 12px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="discount-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="chart-container"><canvas id="discountTrendChart"></canvas></div>
                                    <div class="chart-guide">
                                        <strong>해석 가이드:</strong> 할인율 상승 = 프로모션 강화 / 가격 하락 = 가격 경쟁력 확보
                                        <span id="discount-insight" style="color: var(--amore-blue); margin-left: 12px;"></span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- 성장 유형 분류 & 경쟁사 프로모션 비교 -->
                        <div class="content-grid">
                            <!-- 성장 유형 분류 -->
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="trending-up" style="color: white; width: 16px; height: 16px;"></i></div>
                                        제품 성장 유형 분류
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">📊 성장 유형 분류</div>
                                            <div class="tooltip-content">
                                                <p><strong>분류 기준</strong><br>제품의 순위 상승이 자연적인지, 할인에 의존하는지 분석</p>
                                                <p><strong>오가닉 성장</strong><br>할인/프로모션 없이 순위 상승 (건강한 성장)</p>
                                                <p><strong>할인 기반 성장</strong><br>15%↑ 할인, 쿠폰, 딜 활용 시 (주의 필요)</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <label style="font-size: 12px; color: #666;">제품:</label>
                                            <select id="growthTypeProductSelect" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; max-width: 200px;">
                                                <option value="">전체 LANEIGE 제품</option>
                                            </select>
                                        </div>
                                        <div class="chart-date-range" id="growthTypeDateRange">
                                            <label>기간:</label>
                                            <input type="date" id="growthTypeStartDate">
                                            <span class="date-separator">~</span>
                                            <input type="date" id="growthTypeEndDate">
                                            <button class="apply-btn" onclick="applyGrowthTypeDateRange()">적용</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div id="growth-missing-dates" class="missing-dates-alert" style="display: none; margin-bottom: 12px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="growth-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="growth-type-container" id="growth-type-container">
                                        <div class="growth-type-box organic" id="organic-box">
                                            <div class="growth-type-icon-wrapper">
                                                <i data-lucide="trending-up" style="width: 24px; height: 24px; color: var(--amore-blue);"></i>
                                            </div>
                                            <div class="growth-type-label">오가닉 성장</div>
                                            <div class="growth-type-value" id="organic-count">-</div>
                                            <div class="growth-type-desc">할인/프로모션 없이 순위 상승</div>
                                        </div>
                                        <div class="growth-type-box discount" id="discount-box">
                                            <div class="growth-type-icon-wrapper">
                                                <i data-lucide="tag" style="width: 24px; height: 24px; color: var(--pacific-blue);"></i>
                                            </div>
                                            <div class="growth-type-label">할인 기반 성장</div>
                                            <div class="growth-type-value" id="discount-count">-</div>
                                            <div class="growth-type-desc">15%↑ 할인 또는 쿠폰/딜 활용</div>
                                        </div>
                                    </div>
                                    <div class="chart-guide" style="margin-top: 16px;">
                                        <strong>분류 기준:</strong> 할인율 15% 초과, 쿠폰 적용, Lightning/Limited Deal 중 하나라도 해당 시 "할인 기반"으로 분류
                                    </div>
                                </div>
                            </div>
                            <!-- 경쟁사 프로모션 비교 -->
                            <div class="card">
                                <div class="card-header">
                                    <div class="card-title has-tooltip">
                                        <div class="card-title-icon"><i data-lucide="users" style="color: white; width: 16px; height: 16px;"></i></div>
                                        경쟁사 프로모션 비교
                                        <i data-lucide="help-circle" class="help-icon" style="width: 14px; height: 14px; margin-left: 6px; opacity: 0.6;"></i>
                                        <div class="chart-title-tooltip">
                                            <div class="tooltip-header">🏷️ 경쟁사 프로모션 비교</div>
                                            <div class="tooltip-content">
                                                <p><strong>분석 대상</strong><br>카테고리 Top 10 브랜드의 프로모션 현황을 비교합니다.</p>
                                                <p><strong>항목 설명</strong><br>• 평균할인: 제품별 평균 할인율<br>• 쿠폰: 쿠폰 적용 제품 수<br>• 딜: Lightning/Limited Deal 수<br>• S&S: Subscribe & Save 제품 수</p>
                                            </div>
                                        </div>
                                    </div>
                                    <div style="display: flex; align-items: center; gap: 12px; flex-wrap: wrap;">
                                        <div style="display: flex; align-items: center; gap: 8px;">
                                            <label style="font-size: 12px; color: #666;">제품:</label>
                                            <select id="competitorProductSelect" style="padding: 4px 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px; max-width: 200px;">
                                                <option value="">제품 선택...</option>
                                            </select>
                                        </div>
                                        <div class="chart-date-range" id="competitorPromoDateRange">
                                            <label>기간:</label>
                                            <input type="date" id="competitorPromoStartDate">
                                            <span class="date-separator">~</span>
                                            <input type="date" id="competitorPromoEndDate">
                                            <button class="apply-btn" onclick="applyCompetitorPromoDateRange()">적용</button>
                                        </div>
                                    </div>
                                </div>
                                <div class="card-body">
                                    <div id="competitor-missing-dates" class="missing-dates-alert" style="display: none; margin-bottom: 12px;">
                                        <i data-lucide="calendar-x" class="alert-icon"></i>
                                        <div class="alert-content">
                                            <div class="alert-title">일부 날짜 데이터 없음</div>
                                            <div class="alert-dates" id="competitor-missing-dates-text"></div>
                                            <div class="alert-hint">매일 22:00 KST 자동 수집</div>
                                        </div>
                                    </div>
                                    <div class="promo-table-container">
                                        <table class="promo-table" id="competitor-promo-table">
                                            <thead>
                                                <tr>
                                                    <th>제품명</th>
                                                    <th>브랜드</th>
                                                    <th>평균순위</th>
                                                    <th>할인율</th>
                                                    <th>쿠폰</th>
                                                    <th>S&S</th>
                                                </tr>
                                            </thead>
                                            <tbody id="competitor-promo-tbody">
                                                <tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">데이터 로딩 중...</td></tr>
                                            </tbody>
                                        </table>
                                    </div>
                                    <div class="chart-guide" style="margin-top: 12px;">
                                        <strong>S&S:</strong> Subscribe & Save 제품 수 | <strong>딜:</strong> Lightning/Limited Time Deal
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </main>

                <!-- CHATBOT -->
                <aside class="chatbot-panel" id="chatbotPanel">
                    <!-- 드래그 핸들 (크기 조절용) -->
                    <div class="chat-resize-handle" id="chatResizeHandle"></div>

                    <div class="chat-header">
                        <div class="chat-header-top"><h3><i data-lucide="bot" style="width: 20px; height: 20px;"></i>AI Insight Agent</h3><button class="chat-close" onclick="toggleChatbot()"><i data-lucide="x" style="width: 18px; height: 18px;"></i></button></div>
                        <div class="chat-subtitle">Laneige 브랜드 맞춤 인사이트</div>
                    </div>
                    <div class="chat-body" id="chatBody">
                        <div class="chat-message bot"><div class="bubble">안녕하세요!<br><br>오늘 <strong>Laneige Lip Sleeping Mask</strong>가 2위로 상승했습니다. 경쟁사 대비 가격 경쟁력이 좋은 상황이에요.<br><br>궁금한 점을 물어보세요!</div></div>
                    </div>
                    <div class="chat-suggestions" id="chatSuggestions">
                        <div class="suggestions-header" onclick="toggleSuggestions()">
                            <div class="suggestions-label">추천 질문</div>
                            <div class="suggestions-toggle"><i data-lucide="chevron-down" style="width: 14px; height: 14px;"></i></div>
                        </div>
                        <div class="suggestion-chips">
                            <div class="suggestion-chip" onclick="sendChatMessage('Lip Sleeping Mask 상승 원인 분석해줘')">Lip Mask 상승 원인</div>
                            <div class="suggestion-chip" onclick="sendChatMessage('Water Bank Cream 평점 하락 대응 전략은?')">Water Bank 평점 대응</div>
                            <div class="suggestion-chip" onclick="sendChatMessage('오늘 가장 시급한 액션은?')">시급한 액션</div>
                        </div>
                    </div>
                    <div class="chat-input-area">
                        <input type="text" class="chat-input" id="chatInput" placeholder="질문을 입력하세요..." onkeypress="handleChatKeypress(event)">
                        <button class="chat-send" onclick="sendChatFromInput()"><i data-lucide="send" style="width: 18px; height: 18px;"></i></button>
                    </div>
                </aside>
            </div>
        </div>

        <div class="chat-fab" id="chatFab" onclick="toggleChatbot()"><i data-lucide="message-square" style="color: white; width: 28px; height: 28px;"></i></div>

        <!-- AI DRAWER -->
        <div class="ai-drawer" id="aiDrawer">
            <div class="drawer-header">
                <div class="drawer-header-top">
                    <div class="drawer-header-left">
                        <!-- AMOREPACIFIC 워드마크 -->
                        <div class="drawer-wordmark">
                            <span class="drawer-wordmark-amore">AMORE</span><span class="drawer-wordmark-pacific">PACIFIC</span>
                        </div>
                        <!-- 타이틀 -->
                        <div class="drawer-title-area">
                            <h3>AI 전략 인사이트</h3>
                            <p id="drawer-subtitle">라네즈 Amazon US 분석</p>
                        </div>
                    </div>
                    <button class="drawer-close" onclick="closeAIDrawer()"><i data-lucide="x" style="width: 18px; height: 18px;"></i></button>
                </div>
                <!-- 그라데이션 구분선 -->
                <div class="drawer-divider"></div>
            </div>
            <div class="drawer-content" id="drawer-content">
                <!-- Loading State -->
                <div class="drawer-loading" id="drawer-loading" style="display: none;">
                    <div class="drawer-loading-spinner"></div>
                    <p>AI 전략 분석 중...</p>
                </div>

                <!-- Strategy Summary Section -->
                <div class="insight-section" id="section-summary">
                    <div class="insight-section-header">
                        <i data-lucide="chart-bar" style="width: 16px; height: 16px; color: var(--amore-blue);"></i>
                        <h4>Strategy Summary</h4>
                    </div>
                    <div class="insight-box" id="strategy-summary-content">
                        <strong>라네즈</strong> 브랜드는 Amazon US Lip Care 카테고리에서 <span class="highlight-text">"Price-Quality Leader"</span> 포지션을 확보하고 있습니다.
                        <br><br>
                        현재 Lip Sleeping Mask의 가격 경쟁력과 높은 평점을 활용한 <strong>SKU 확장 전략</strong>이 권장됩니다.
                    </div>
                    <!-- KPI Grid -->
                    <div class="insight-kpi-grid" id="strategy-kpi-grid">
                        <div class="insight-kpi-item">
                            <div class="insight-kpi-value positive" id="kpi-sos">8.2%</div>
                            <div class="insight-kpi-label">SoS</div>
                        </div>
                        <div class="insight-kpi-item">
                            <div class="insight-kpi-value" id="kpi-rank">#2</div>
                            <div class="insight-kpi-label">Best Rank</div>
                        </div>
                        <div class="insight-kpi-item">
                            <div class="insight-kpi-value" id="kpi-rating">4.5</div>
                            <div class="insight-kpi-label">Avg Rating</div>
                        </div>
                    </div>
                </div>

                <!-- Inference Path Section -->
                <div class="insight-section" id="section-inference">
                    <div class="insight-section-header">
                        <i data-lucide="git-branch" style="width: 16px; height: 16px; color: var(--amore-blue);"></i>
                        <h4>Inference Path</h4>
                    </div>
                    <div class="inference-path" id="inference-path-container">
                        <div class="path-node highlight">라네즈</div>
                        <span class="path-arrow">→</span>
                        <div class="path-node">Top 2 Position</div>
                        <span class="path-arrow">→</span>
                        <div class="path-node highlight">SKU 확장</div>
                    </div>
                </div>

                <!-- Recommended Actions Section -->
                <div class="insight-section" id="section-actions">
                    <div class="insight-section-header">
                        <i data-lucide="target" style="width: 16px; height: 16px; color: var(--warning);"></i>
                        <h4>Recommended Actions</h4>
                    </div>
                    <div class="action-list" id="action-list">
                        <div class="action-item">
                            <div class="action-number">1</div>
                            <div class="action-content">
                                <div class="action-title"><span class="action-tag urgent">즉시</span>Lip Sleeping Mask 신규 플레이버 출시 검토</div>
                                <div class="action-description">Mango, Vanilla 등 신규 플레이버로 SKU 확장</div>
                            </div>
                        </div>
                        <div class="action-item">
                            <div class="action-number">2</div>
                            <div class="action-content">
                                <div class="action-title"><span class="action-tag">모니터링</span>Water Bank Cream 리뷰 분석</div>
                                <div class="action-description">부정 키워드 대응 전략 수립</div>
                            </div>
                        </div>
                        <div class="action-item">
                            <div class="action-number">3</div>
                            <div class="action-content">
                                <div class="action-title"><span class="action-tag">검토</span>번들 프로모션 기획</div>
                                <div class="action-description">객단가 상승 및 교차 판매 유도</div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="drawer-actions">
                <button class="drawer-btn secondary" onclick="copyStrategyReport()"><i data-lucide="copy" style="width: 16px; height: 16px;"></i>복사</button>
                <button class="drawer-btn primary" onclick="shareStrategyReport()"><i data-lucide="mail" style="width: 16px; height: 16px;"></i>공유</button>
            </div>
        </div>

        <!-- EXPORT MODAL -->
        <div class="modal-overlay" id="exportModal">
            <div class="modal-content">
                <div class="modal-header"><div class="modal-icon"><i data-lucide="file-spreadsheet" style="color: white; width: 26px; height: 26px;"></i></div><div><h3>데이터 내보내기</h3><p>Amazon US 데이터 추출</p></div></div>
                <div class="form-group"><label class="form-label">내보내기 형식</label>
                    <div style="display: flex; gap: 12px; margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 10px 16px; border: 2px solid var(--border-light); border-radius: 8px; transition: all 0.15s;">
                            <input type="radio" name="exportFormat" value="docx" checked style="accent-color: var(--amore-blue);">
                            <span>📄 DOCX (인사이트 리포트)</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 10px 16px; border: 2px solid var(--border-light); border-radius: 8px; transition: all 0.15s;">
                            <input type="radio" name="exportFormat" value="excel" style="accent-color: var(--amore-blue);">
                            <span>📊 Excel (원본 데이터)</span>
                        </label>
                    </div>
                </div>
                <div class="form-group"><label class="form-label">분석 기간</label><div class="date-inputs"><input type="date" class="date-input" id="exportStartDate"><input type="date" class="date-input" id="exportEndDate"></div></div>
                <div class="form-group"><label class="form-label">대상 플랫폼</label><div class="platform-fixed">🇺🇸 Amazon US (고정)</div></div>
                <div class="modal-actions"><button class="modal-btn cancel" onclick="closeExportModal()">취소</button><button class="modal-btn confirm" onclick="executeExport()">📥 다운로드</button></div>
            </div>
        </div>
    </div>

    <script>
        lucide.createIcons();
        let currentPage = 'home', chatbotOpen = false, charts = {};

        // Chart.js 전역 툴팁 설정 - 잘림 방지 및 caret(세모 화살표) 표시
        Chart.defaults.plugins.tooltip.yAlign = 'top';  // 툴팁이 포인터 아래에 표시
        Chart.defaults.plugins.tooltip.caretPadding = 10;
        Chart.defaults.plugins.tooltip.caretSize = 6;  // 세모 화살표 크기

        // 차트 캔버스가 툴팁을 자르지 않도록 overflow 허용
        Chart.defaults.layout = Chart.defaults.layout || {};
        Chart.defaults.layout.padding = { top: 20, bottom: 10, left: 10, right: 10 };

        // Dashboard Data (loaded from JSON)
        let dashboardData = null;

        // Product Data - API에서 로드 (하드코딩 fallback 제거)
        let productData = {};

        // Category Products - API에서 로드 (하드코딩 fallback 제거)
        let categoryProducts = {
            'beauty': [],
            'skin_care': [],
            'lip_care': [],
            'lip_makeup': [],
            'face_powder': []
        };

        let lastDataDate = null;  // 마지막 데이터 날짜 추적

        // ARITA 디자인 토스트 알림 - "단아하고 지적이며, 건강한 아름다움"
        function showToast(message, type = 'info') {
            // 기존 토스트 제거
            const existing = document.getElementById('toast-notification');
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.id = 'toast-notification';

            // ARITA 컬러 시스템
            let bgStyle, borderStyle, iconSvg;
            if (type === 'success') {
                bgStyle = 'background: linear-gradient(135deg, #1F5795, #2d6cb3);';
                borderStyle = 'border-left: 3px solid #7db8f7;';
                iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="20 6 9 17 4 12"></polyline></svg>';
            } else if (type === 'error') {
                bgStyle = 'background: linear-gradient(135deg, #8B2635, #a33344);';
                borderStyle = 'border-left: 3px solid #f5a5a5;';
                iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
            } else {
                bgStyle = 'background: linear-gradient(135deg, #001C58, #1F5795);';
                borderStyle = 'border-left: 3px solid rgba(255,255,255,0.3);';
                iconSvg = '<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
            }

            toast.style.cssText = `
                position: fixed; bottom: 24px; right: 24px; z-index: 10000;
                padding: 14px 20px; border-radius: 8px;
                font-size: 13px; font-weight: 500; letter-spacing: -0.02em;
                box-shadow: 0 8px 32px rgba(0, 28, 88, 0.3);
                animation: slideIn 0.3s ease;
                display: flex; align-items: center; gap: 12px;
                color: white;
                font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
                ${bgStyle}
                ${borderStyle}
            `;
            toast.innerHTML = `
                <span style="display: flex; opacity: 0.95;">${iconSvg}</span>
                <span>${message}</span>
            `;
            document.body.appendChild(toast);

            // 5초 후 제거
            setTimeout(() => {
                toast.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => toast.remove(), 300);
            }, 5000);
        }

        // 대시보드 데이터 새로고침 (API에서 로드)
        async function refreshDashboardData() {
            try {
                // API에서 최신 데이터 가져오기
                const response = await fetch(`${API_BASE}/api/data`);
                if (!response.ok) {
                    console.warn('API data not available, falling back to JSON file');
                    return await loadDashboardData();
                }

                dashboardData = await response.json();
                window.dashboardData = dashboardData;  // 전역으로 접근 가능하게
                console.log('Dashboard data refreshed from API:', dashboardData.metadata);

                // UI 업데이트 (애니메이션 효과)
                highlightUpdatedElements();
                updateDashboardFromData();
                initChartsForPage(currentPage);

                return true;
            } catch (error) {
                console.warn('Failed to refresh from API:', error);
                return await loadDashboardData();
            }
        }

        // 업데이트된 요소 하이라이트 효과
        function highlightUpdatedElements() {
            const elements = document.querySelectorAll('.kpi-value, .insight-message, .metric-card');
            elements.forEach(el => {
                el.style.transition = 'background-color 0.5s ease';
                el.style.backgroundColor = 'rgba(16, 185, 129, 0.2)';
                setTimeout(() => {
                    el.style.backgroundColor = '';
                }, 2000);
            });

            // 차트 컨테이너도 하이라이트
            const chartContainers = document.querySelectorAll('.chart-container, canvas');
            chartContainers.forEach(el => {
                el.style.transition = 'box-shadow 0.5s ease';
                el.style.boxShadow = '0 0 20px rgba(16, 185, 129, 0.4)';
                setTimeout(() => {
                    el.style.boxShadow = '';
                }, 2000);
            });
        }

        // Loading State Management
        function showLoading(show = true, message = '데이터를 불러오는 중...') {
            const overlay = document.getElementById('loadingOverlay');
            const textEl = overlay?.querySelector('.loading-text');
            if (overlay) {
                if (show) {
                    overlay.classList.add('show');
                    if (textEl) textEl.textContent = message;
                } else {
                    overlay.classList.remove('show');
                }
            }
        }

        function hideLoading() { showLoading(false); }

        // 경쟁사 프로모션 테이블 스켈레톤 로딩
        function showCompetitorPromoSkeleton() {
            const container = document.querySelector('#competitor-promo-table')?.closest('.promo-table-container');
            const tbody = document.getElementById('competitor-promo-tbody');
            if (!container || !tbody) return;

            container.classList.add('loading');

            // 4개 행의 스켈레톤 표시
            tbody.innerHTML = Array(4).fill(0).map(() => `
                <tr class="skeleton-row">
                    <td><div class="skeleton-cell" style="width: 120px;"></div></td>
                    <td><div class="skeleton-cell" style="width: 60px;"></div></td>
                    <td><div class="skeleton-cell" style="width: 40px;"></div></td>
                    <td><div class="skeleton-cell" style="width: 40px;"></div></td>
                    <td><div class="skeleton-cell" style="width: 30px;"></div></td>
                    <td><div class="skeleton-cell" style="width: 30px;"></div></td>
                </tr>
            `).join('');
        }

        function hideCompetitorPromoSkeleton() {
            const container = document.querySelector('#competitor-promo-table')?.closest('.promo-table-container');
            if (container) container.classList.remove('loading');
        }

        // Brand Matrix 차트 개선된 로딩 UX
        let brandMatrixLoadingTimer = null;
        const MIN_LOADING_TIME = 300; // 최소 로딩 표시 시간 (ms)

        function showBrandMatrixLoading() {
            const container = document.getElementById('brandMatrixChartContainer');
            const overlay = document.getElementById('brandMatrixLoadingOverlay');
            const summary = document.getElementById('brandMatrixSummary');

            if (container) {
                container.classList.add('loading-fade');
                container.classList.remove('loading-complete');
            }
            if (overlay) {
                overlay.classList.add('show');
            }
            if (summary) {
                summary.classList.add('updating');
            }

            // 로딩 시작 시간 기록
            brandMatrixLoadingTimer = Date.now();
        }

        function hideBrandMatrixLoading() {
            const container = document.getElementById('brandMatrixChartContainer');
            const overlay = document.getElementById('brandMatrixLoadingOverlay');
            const summary = document.getElementById('brandMatrixSummary');

            // 최소 로딩 시간 보장 (깜빡임 방지)
            const elapsed = Date.now() - (brandMatrixLoadingTimer || 0);
            const remainingTime = Math.max(0, MIN_LOADING_TIME - elapsed);

            setTimeout(() => {
                if (overlay) {
                    overlay.classList.remove('show');
                }
                if (container) {
                    container.classList.remove('loading-fade');
                    container.classList.add('loading-complete');
                }
                if (summary) {
                    summary.classList.remove('updating');
                }
            }, remainingTime);
        }

        // 데이터 요약 카드 업데이트
        function updateBrandMatrixSummary(data) {
            const summary = document.getElementById('brandMatrixSummary');
            const periodText = document.getElementById('brandMatrixPeriodText');
            const brandCount = document.getElementById('brandMatrixBrandCount');
            const dataPoints = document.getElementById('brandMatrixDataPoints');
            const timestamp = document.getElementById('brandMatrixTimestamp');

            if (!summary) return;

            // 요약 카드 표시
            summary.classList.add('show');

            // 기간 표시
            if (periodText && data.startDate && data.endDate) {
                const start = new Date(data.startDate);
                const end = new Date(data.endDate);
                const days = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
                const formatDate = (d) => `${d.getMonth() + 1}.${d.getDate()}`;
                periodText.textContent = `${formatDate(start)} ~ ${formatDate(end)} (${days}일)`;
            }

            // 브랜드 수
            if (brandCount && data.brandCount !== undefined) {
                brandCount.textContent = `${data.brandCount}개`;
            }

            // 데이터 포인트
            if (dataPoints && data.dataPoints !== undefined) {
                dataPoints.textContent = `${data.dataPoints}개`;
            }

            // 업데이트 시간
            if (timestamp) {
                const now = new Date();
                timestamp.textContent = `업데이트: ${now.getHours()}:${String(now.getMinutes()).padStart(2, '0')}`;
            }

            // 아이콘 새로고침
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Load Dashboard Data (API 우선, JSON fallback)
        async function loadDashboardData() {
            showLoading(true, '대시보드 데이터 로딩 중...');
            try {
                // 1. 먼저 API에서 시도
                let response = await fetch(`${API_BASE}/api/data`);

                // API 실패 시 JSON 파일로 폴백
                if (!response.ok) {
                    console.warn('API not available, trying JSON file');
                    response = await fetch('../data/dashboard_data.json');
                }

                if (!response.ok) {
                    console.warn('Dashboard data not found');
                    return false;
                }

                dashboardData = await response.json();
                window.dashboardData = dashboardData;  // 전역으로 접근 가능하게
                console.log('Dashboard data loaded:', dashboardData.metadata);

                // 마지막 데이터 날짜 저장 (새로고침 감지용)
                lastDataDate = dashboardData.metadata?.data_date;

                // Update UI with loaded data
                updateDashboardFromData();

                hideLoading();
                return true;
            } catch (error) {
                console.warn('Failed to load dashboard data:', error);
                hideLoading();
                // 데이터 로드 실패 시 현재 날짜 표시
                const dateDisplay = document.getElementById('date-display');
                if (dateDisplay) {
                    dateDisplay.textContent = '📅 ' + new Date().toISOString().split('T')[0];
                }
                showToast('데이터 로드에 실패했습니다. 페이지를 새로고침해주세요.', 'error');
                return false;
            }
        }

        // Update Dashboard UI from loaded data
        function updateDashboardFromData() {
            if (!dashboardData) return;

            // Update date display - 데이터 날짜 또는 현재 날짜 표시
            const dateDisplay = document.getElementById('date-display');
            if (dateDisplay) {
                const dataDate = dashboardData.metadata?.data_date;
                const today = new Date().toISOString().split('T')[0];
                dateDisplay.textContent = '📅 ' + (dataDate || today);
            }

            // Update Home page insight
            if (dashboardData.home?.insight_message) {
                const insightEl = document.querySelector('.insight-message');
                if (insightEl) insightEl.innerHTML = dashboardData.home.insight_message;
            }

            // Update status cards
            if (dashboardData.home?.status) {
                const status = dashboardData.home.status;
                const statusCards = document.querySelectorAll('.status-card');
                if (statusCards[0]) {
                    statusCards[0].querySelector('.status-value span').textContent = status.exposure || 'Stable';
                }
                if (statusCards[1]) {
                    statusCards[1].querySelector('.status-value span').textContent = status.position || 'Top 5';
                }
                if (statusCards[2]) {
                    statusCards[2].querySelector('.status-value span').textContent = (status.warning_count || 0) + '개';
                }
            }

            // Update action items
            if (dashboardData.home?.action_items) {
                updateActionTable(dashboardData.home.action_items);
            }

            // Update exposure status tooltip
            updateExposureStatusTooltip(dashboardData.home, dashboardData.home?.action_items);

            // 경쟁사 드롭다운 동적 생성
            populateCompetitorDropdown();

            // 상세 경쟁사 비교 기간 선택 초기화
            initDetailedComparisonDateRange();

            // Update Brand KPIs
            if (dashboardData.brand?.kpis) {
                const kpis = dashboardData.brand.kpis;
                const kpiCards = document.querySelectorAll('#page-brand .kpi-card');

                // SoS 처리: 객체인 경우 평균값 계산, 숫자면 그대로 사용
                let sosValue = kpis.sos;
                if (typeof sosValue === 'object' && sosValue !== null) {
                    const sosValues = Object.values(sosValue).filter(v => typeof v === 'number' && v > 0);
                    sosValue = sosValues.length > 0
                        ? (sosValues.reduce((a, b) => a + b, 0) / sosValues.length).toFixed(1)
                        : 0;
                }

                // Top 10 제품 수: laneige_products에서 계산
                let top10Count = kpis.top10_count;
                if (top10Count === undefined && dashboardData.laneige_products) {
                    top10Count = dashboardData.laneige_products.filter(p => p.rank <= 10).length;
                }

                // 평균 순위: laneige_products에서 계산
                let avgRank = kpis.avg_rank;
                if (avgRank === undefined && dashboardData.laneige_products?.length > 0) {
                    const ranks = dashboardData.laneige_products.map(p => p.rank);
                    avgRank = (ranks.reduce((a, b) => a + b, 0) / ranks.length).toFixed(1);
                }

                // HHI: 기본값 설정
                let hhi = kpis.hhi ?? '중간 집중도';

                if (kpiCards[0]) kpiCards[0].querySelector('.kpi-value').innerHTML = sosValue + '<span class="unit">%</span>';
                if (kpiCards[1]) kpiCards[1].querySelector('.kpi-value').innerHTML = (top10Count ?? 0) + '<span class="unit">개</span>';
                if (kpiCards[2]) kpiCards[2].querySelector('.kpi-value').innerHTML = (avgRank ?? '-') + '<span class="unit">위</span>';
                if (kpiCards[3]) kpiCards[3].querySelector('.kpi-value').textContent = hhi;
            }

            // Update Competitor Table
            if (dashboardData.brand?.competitors) {
                updateCompetitorTable(dashboardData.brand.competitors);
            }

            // Update product data from loaded data
            if (dashboardData.products) {
                productData = {};
                categoryProducts = {
                    'beauty': [],
                    'skin_care': [],
                    'lip_care': [],
                    'lip_makeup': [],
                    'face_powder': []
                };

                for (const [asin, product] of Object.entries(dashboardData.products)) {
                    const key = asin.toLowerCase().replace(/[^a-z0-9]/g, '-');
                    productData[key] = {
                        rank: '#' + product.rank,
                        rankDelta: product.rank_delta,
                        vol: String(product.volatility),
                        volDelta: product.volatility_status,
                        rating: String(product.rating),
                        ratingDelta: product.rating_delta,
                        stick: '85',
                        stickDelta: '높음'
                    };

                    // Add to category (매핑: thresholds.json 카테고리 키)
                    const cat = product.category || 'lip_care';
                    let catKey = 'beauty';
                    if (cat.includes('lip_care') || cat === 'lip') catKey = 'lip_care';
                    else if (cat.includes('lip_makeup')) catKey = 'lip_makeup';
                    else if (cat.includes('skin_care') || cat === 'skin') catKey = 'skin_care';
                    else if (cat.includes('face_powder') || cat === 'face') catKey = 'face_powder';
                    else catKey = 'beauty';

                    if (categoryProducts[catKey]) {
                        categoryProducts[catKey].push([key, product.name]);
                    }
                    // Also add to beauty (top level) for visibility
                    if (catKey !== 'beauty' && categoryProducts['beauty']) {
                        categoryProducts['beauty'].push([key, product.name]);
                    }
                }
            }

            console.log('Dashboard UI updated from data');

            // Initialize date range pickers
            initDateRangePickers();
        }

        // ============== DATE RANGE PICKER FUNCTIONS ==============

        // ===== 글로벌 날짜 범위 상태 관리 =====
        const globalDateRange = {
            startDate: null,
            endDate: null,
            availableDateRange: null,  // API에서 받은 사용 가능한 날짜 범위

            // 초기화: localStorage에서 복원 또는 기본값 설정
            init() {
                const saved = localStorage.getItem('dashboardDateRange');
                if (saved) {
                    try {
                        const parsed = JSON.parse(saved);
                        this.startDate = parsed.startDate;
                        this.endDate = parsed.endDate;
                        console.log('[GlobalDateRange] Restored from localStorage:', this.startDate, '~', this.endDate);
                    } catch (e) {
                        console.warn('[GlobalDateRange] Failed to parse localStorage, using defaults');
                        this.setDefaultRange();
                    }
                } else {
                    this.setDefaultRange();
                }
            },

            // 기본값 설정: dashboardData에서 사용 가능한 날짜 범위 추출
            setDefaultRange() {
                // API 메타데이터에서 날짜 범위 가져오기 시도
                if (dashboardData?.metadata?.available_date_range) {
                    const range = dashboardData.metadata.available_date_range;
                    this.startDate = range.min;
                    this.endDate = range.max;
                    console.log('[GlobalDateRange] Default from metadata:', this.startDate, '~', this.endDate);
                } else if (dashboardData?.charts?.sos_trend?.["30d"]?.labels) {
                    // 폴백: SoS 트렌드 30일 데이터에서 추출
                    const labels = dashboardData.charts.sos_trend["30d"].labels;
                    // MM-DD 또는 MM/DD 형식을 YYYY-MM-DD로 변환
                    this.startDate = this.convertLabelToDate(labels[0]);
                    this.endDate = this.convertLabelToDate(labels[labels.length - 1]);
                    console.log('[GlobalDateRange] Default from sos_trend:', this.startDate, '~', this.endDate);
                } else {
                    // 최후 폴백: 최근 30일
                    const end = new Date();
                    const start = new Date();
                    start.setDate(start.getDate() - 30);
                    this.startDate = start.toISOString().split('T')[0];
                    this.endDate = end.toISOString().split('T')[0];
                    console.log('[GlobalDateRange] Default fallback (30 days):', this.startDate, '~', this.endDate);
                }
            },

            // MM-DD 또는 MM/DD 형식의 레이블을 YYYY-MM-DD로 변환
            convertLabelToDate(label) {
                const now = new Date();
                // 이미 YYYY-MM-DD 형식이면 그대로 반환
                if (/^\d{4}-\d{2}-\d{2}$/.test(label)) {
                    return label;
                }
                // MM-DD 또는 MM/DD 형식 처리
                const parts = label.split(/[-\/]/);
                if (parts.length === 2) {
                    const month = parseInt(parts[0], 10);
                    const day = parseInt(parts[1], 10);
                    let year = now.getFullYear();
                    // 현재 월보다 미래 월이면 작년 데이터로 간주
                    if (month > now.getMonth() + 1 + 2) {  // 2달 여유
                        year -= 1;
                    }
                    return `${year}-${String(month).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
                }
                // 변환 실패시 오늘 날짜 반환
                console.warn('[GlobalDateRange] Failed to parse label:', label);
                return now.toISOString().split('T')[0];
            },

            // 날짜 범위 설정 및 저장
            set(start, end) {
                // 유효성 검사
                if (new Date(start) > new Date(end)) {
                    console.warn('[GlobalDateRange] Invalid range: start > end');
                    return false;
                }

                this.startDate = start;
                this.endDate = end;

                // localStorage에 저장
                localStorage.setItem('dashboardDateRange', JSON.stringify({
                    startDate: start,
                    endDate: end,
                    savedAt: new Date().toISOString()
                }));

                console.log('[GlobalDateRange] Set:', start, '~', end);

                // 모든 차트에 날짜 변경 이벤트 발송
                this.notifyCharts();
                return true;
            },

            // 모든 차트에 날짜 변경 이벤트 발송
            notifyCharts() {
                console.log('[GlobalDateRange] Dispatching dateRangeChanged event');
                document.dispatchEvent(new CustomEvent('dateRangeChanged', {
                    detail: {
                        startDate: this.startDate,
                        endDate: this.endDate
                    }
                }));
            },

            // 날짜 범위 가져오기
            get() {
                return {
                    startDate: this.startDate,
                    endDate: this.endDate
                };
            },

            // 일수 계산
            getDays() {
                if (!this.startDate || !this.endDate) return 30;
                const start = new Date(this.startDate);
                const end = new Date(this.endDate);
                return Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;
            }
        };

        // Date range state (기존 호환성 유지)
        let chartDateRanges = {
            brandMatrix: { startDate: null, endDate: null, availableDates: [] }
        };

        // Initialize date range pickers with current data
        function initDateRangePickers() {
            // 글로벌 날짜 범위 초기화
            globalDateRange.init();

            const startDate = globalDateRange.startDate;
            const endDate = globalDateRange.endDate;

            console.log('[initDateRangePickers] Using global date range:', startDate, '~', endDate);

            // Brand Matrix chart date picker
            const brandMatrixStart = document.getElementById('brandMatrixStartDate');
            const brandMatrixEnd = document.getElementById('brandMatrixEndDate');

            if (brandMatrixStart && brandMatrixEnd) {
                // 글로벌 날짜 범위 적용
                brandMatrixStart.value = startDate;
                brandMatrixEnd.value = endDate;

                // Store initial range
                chartDateRanges.brandMatrix.startDate = startDate;
                chartDateRanges.brandMatrix.endDate = endDate;

                // Update tooltip with period info
                updateChartPeriodTooltip('brandMatrix', startDate, endDate);
            }

            // 모든 날짜 입력창에 글로벌 날짜 범위 동기화
            syncAllDateInputsToGlobal();
        }

        // 모든 날짜 입력창을 글로벌 날짜 범위와 동기화
        function syncAllDateInputsToGlobal() {
            const { startDate, endDate } = globalDateRange.get();

            // 동기화할 날짜 입력창 ID 목록
            const dateInputPairs = [
                ['sosTrendStartDate', 'sosTrendEndDate'],
                ['cpiStartDate', 'cpiEndDate'],
                // categoryStartDate/EndDate 제거됨 (최근 7일 고정)
                ['productStartDate', 'productEndDate'],
                ['rankTrendStartDate', 'rankTrendEndDate'],
                ['matrixStartDate', 'matrixEndDate'],
                ['discountStartDate', 'discountEndDate'],
                ['growthTypeStartDate', 'growthTypeEndDate'],
                ['competitorPromoStartDate', 'competitorPromoEndDate'],
                ['sosStartDate', 'sosEndDate']
            ];

            dateInputPairs.forEach(([startId, endId]) => {
                const startInput = document.getElementById(startId);
                const endInput = document.getElementById(endId);

                if (startInput && endInput) {
                    startInput.value = startDate;
                    endInput.value = endDate;
                }
            });

            console.log('[syncAllDateInputsToGlobal] Synced all date inputs to:', startDate, '~', endDate);
        }

        // Update chart tooltip with period info
        function updateChartPeriodTooltip(chartId, startDate, endDate, missingDates = []) {
            const periodInfoEl = document.getElementById(`${chartId}PeriodInfo`);
            if (periodInfoEl) {
                let periodText = `📅 분석 기간: ${startDate} ~ ${endDate}`;
                if (missingDates.length > 0) {
                    periodText += `<br>⚠️ 데이터 없는 날짜: ${missingDates.length}일`;
                }
                periodInfoEl.innerHTML = periodText;
            }
        }

        // Apply date range for Brand Matrix chart (글로벌 상태 업데이트 포함)
        async function applyBrandMatrixDateRange() {
            const startDate = document.getElementById('brandMatrixStartDate').value;
            const endDate = document.getElementById('brandMatrixEndDate').value;

            console.log('[DateRange] applyBrandMatrixDateRange called:', { startDate, endDate });

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (startDate > endDate) {
                showToast('시작일은 종료일보다 이전이어야 합니다.', 'error');
                return;
            }

            // 글로벌 날짜 범위 업데이트 (모든 차트 자동 업데이트)
            globalDateRange.set(startDate, endDate);
            return;

            // 아래 코드는 이제 globalDateRange.set() 호출 시 dateRangeChanged 이벤트로 처리됨
            showToast('데이터 로딩 중...', 'info');

            try {
                // Fetch historical data for the selected range
                const url = `${API_BASE}/api/historical?start_date=${startDate}&end_date=${endDate}`;
                console.log('[DateRange] Fetching:', url);

                const response = await fetch(url);
                console.log('[DateRange] Response status:', response.status);

                if (!response.ok) {
                    throw new Error(`Historical data fetch failed: ${response.status}`);
                }

                const histData = await response.json();
                console.log('[DateRange] Response data:', {
                    success: histData.success,
                    available_dates: histData.available_dates?.length,
                    brand_metrics: histData.brand_metrics?.length,
                    available_date_range: histData.available_date_range,
                    data_source: histData.data_source
                });

                // Find missing dates in the range
                const missingDates = findMissingDates(startDate, endDate, histData.available_dates || []);
                console.log('[DateRange] Missing dates:', missingDates.length);

                // Update chart date range state
                if (typeof chartDateRanges !== 'undefined' && chartDateRanges.brandMatrix) {
                    chartDateRanges.brandMatrix.startDate = startDate;
                    chartDateRanges.brandMatrix.endDate = endDate;
                    chartDateRanges.brandMatrix.availableDates = histData.available_dates || [];
                    chartDateRanges.brandMatrix.availableDateRange = histData.available_date_range || {};
                }

                // Update tooltip with period info
                updateChartPeriodTooltip('brandMatrix', startDate, endDate, missingDates);

                // Show data gap warning if there are missing dates (with available range hint)
                showDataGapWarning('brandMatrix', missingDates, histData.available_date_range);

                // Update the chart with new data
                if (histData.brand_metrics && histData.brand_metrics.length > 0) {
                    updateBrandMatrixChart(histData.brand_metrics);
                    const sourceInfo = histData.data_source ? ` (${histData.data_source})` : '';
                    showToast(`${startDate} ~ ${endDate} 기간 데이터 적용됨 (${histData.brand_metrics.length}개 브랜드)${sourceInfo}`, 'success');
                } else {
                    const rangeHint = histData.available_date_range?.min && histData.available_date_range?.max
                        ? ` (사용 가능: ${histData.available_date_range.min} ~ ${histData.available_date_range.max})`
                        : '';
                    showToast(`해당 기간에 브랜드 데이터가 없습니다.${rangeHint}`, 'warning');
                }

            } catch (error) {
                console.error('[DateRange] Error:', error);
                showToast('데이터를 불러오는데 실패했습니다: ' + error.message, 'error');
            }
        }

        // Find missing dates in a range
        function findMissingDates(startDate, endDate, availableDates) {
            const missing = [];
            // UTC 변환 방지: 로컬 시간대로 날짜 파싱
            const [startY, startM, startD] = startDate.split('-').map(Number);
            const [endY, endM, endD] = endDate.split('-').map(Number);
            const start = new Date(startY, startM - 1, startD);
            const end = new Date(endY, endM - 1, endD);
            const availableSet = new Set(availableDates);

            for (let d = new Date(start); d <= end; d.setDate(d.getDate() + 1)) {
                // UTC 변환 방지: 로컬 시간대 기준 날짜 문자열 생성
                const y = d.getFullYear();
                const m = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                const dateStr = `${y}-${m}-${day}`;
                if (!availableSet.has(dateStr)) {
                    missing.push(dateStr);
                }
            }

            return missing;
        }

        // Show data gap warning
        function showDataGapWarning(chartId, missingDates, availableDateRange = null) {
            const warningEl = document.getElementById(`${chartId}DataGap`);
            const textEl = document.getElementById(`${chartId}DataGapText`);

            if (!warningEl || !textEl) return;

            if (missingDates.length === 0) {
                warningEl.style.display = 'none';
                return;
            }

            // Group consecutive missing dates into ranges
            const ranges = groupConsecutiveDates(missingDates);
            let warningText = '';

            if (ranges.length === 1 && ranges[0].start === ranges[0].end) {
                warningText = `${ranges[0].start}: 데이터 없음`;
            } else if (ranges.length === 1) {
                warningText = `${ranges[0].start} ~ ${ranges[0].end}: 데이터 없음`;
            } else {
                const rangeStrs = ranges.slice(0, 3).map(r =>
                    r.start === r.end ? r.start : `${r.start}~${r.end}`
                );
                warningText = `데이터 없는 기간: ${rangeStrs.join(', ')}`;
                if (ranges.length > 3) {
                    warningText += ` 외 ${ranges.length - 3}개 구간`;
                }
            }

            // Add available date range hint if provided
            if (availableDateRange && availableDateRange.min && availableDateRange.max) {
                warningText += ` (사용 가능: ${availableDateRange.min} ~ ${availableDateRange.max})`;
            }

            textEl.textContent = warningText;
            warningEl.style.display = 'flex';

            // Refresh lucide icons for the warning icon
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Group consecutive dates into ranges
        function groupConsecutiveDates(dates) {
            if (dates.length === 0) return [];

            const sorted = dates.sort();
            const ranges = [];
            let rangeStart = sorted[0];
            let rangeEnd = sorted[0];

            for (let i = 1; i < sorted.length; i++) {
                const prevDate = new Date(rangeEnd);
                const currDate = new Date(sorted[i]);
                const diffDays = (currDate - prevDate) / (1000 * 60 * 60 * 24);

                if (diffDays === 1) {
                    rangeEnd = sorted[i];
                } else {
                    ranges.push({ start: rangeStart, end: rangeEnd });
                    rangeStart = sorted[i];
                    rangeEnd = sorted[i];
                }
            }

            ranges.push({ start: rangeStart, end: rangeEnd });
            return ranges;
        }

        // Update Brand Matrix chart with new data
        function updateBrandMatrixChart(brandMetrics) {
            console.log('[DateRange] updateBrandMatrixChart called', {
                hasChart: !!charts.brandMatrix,
                metricsCount: brandMetrics?.length
            });

            if (!brandMetrics || brandMetrics.length === 0) {
                console.warn('[DateRange] No brand metrics data');
                return;
            }

            // 차트가 아직 초기화되지 않았으면 Brand 페이지로 이동 필요
            if (!charts.brandMatrix) {
                console.warn('[DateRange] brandMatrix chart not initialized - may need to be on Brand page');
                showToast('Brand 페이지에서 차트를 확인하세요.', 'info');
                return;
            }

            const colors = {
                laneige: '#1F5795',
                competitor: '#7D7D7D'
            };
            const brandColors = ['#1F5795', '#001C58', '#7D7D7D', '#4A7DB8', '#A0A0A0', '#2E4A6E', '#5C5C5C', '#3D6B99', '#8B8B8B', '#1A3D66'];

            // Convert metrics to chart datasets
            const brandDatasets = brandMetrics.map((brand, idx) => ({
                label: brand.brand,
                data: [{ x: brand.sos, y: brand.avg_rank, r: brand.bubble_size || Math.max(5, brand.product_count * 2) }],
                backgroundColor: brand.is_laneige ? colors.laneige : brandColors[idx % brandColors.length]
            }));

            console.log('[DateRange] Updating chart with', brandDatasets.length, 'datasets');

            // Update chart data
            charts.brandMatrix.data.datasets = brandDatasets;

            // Recalculate axis ranges
            const maxBubbleR = Math.max(...brandDatasets.flatMap(d => d.data.map(p => p.r || 10)));
            const allX = brandDatasets.flatMap(d => d.data.map(p => p.x));
            const allY = brandDatasets.flatMap(d => d.data.map(p => p.y));

            const xMin = Math.max(0, Math.min(...allX) - 1);
            const xMax = Math.max(...allX) + 1;
            const yMin = Math.max(1, Math.min(...allY) - 5);
            const yMax = Math.max(...allY) + 5;

            console.log('[DateRange] New axis ranges:', { xMin, xMax, yMin, yMax });

            charts.brandMatrix.options.scales.x.min = xMin;
            charts.brandMatrix.options.scales.x.max = xMax;
            charts.brandMatrix.options.scales.y.min = yMin;
            charts.brandMatrix.options.scales.y.max = yMax;

            charts.brandMatrix.update('none');  // 'none' for immediate update without animation
            console.log('[DateRange] Chart updated successfully');
        }

        // ============== END DATE RANGE PICKER FUNCTIONS ==============

        // Update action table with dynamic data
        function updateActionTable(items) {
            const tbody = document.querySelector('.action-table tbody');
            if (!tbody || !items.length) return;

            tbody.innerHTML = items.map((item, idx) => {
                // Generate discount badges if available
                const discountInfo = item.discount_percent || item.has_coupon || item.is_deal ?
                    generateDiscountBadges(item) : '';

                // 제품명 짧게 표시 (LANEIGE 제거 후 40자)
                // products 데이터에서 전체 이름 가져오기 (action_items의 product_name은 truncate됨)
                const productData = window.dashboardData?.products?.[item.asin];
                const fullName = productData?.name || item.product_name || 'Unknown';
                const shortName = fullName.replace(/^LANEIGE\s+/i, '').substring(0, 40) + (fullName.length > 47 ? '...' : '');

                return `
                <tr onclick="goToProductDetail('${item.asin || ''}', '${item.product_name || ''}')">
                    <td><span class="priority-badge ${item.priority.toLowerCase()}">${item.priority === 'P1' ? '🔴' : '🟠'} ${item.priority}</span></td>
                    <td>
                        <div class="product-info">
                            <div class="product-avatar">LN</div>
                            <div>
                                <div class="product-name">
                                    <span class="product-name-wrapper">
                                        <span class="product-name-truncate">${shortName}</span>
                                        <div class="product-name-tooltip">
                                            <div class="tooltip-header">📦 제품 정보</div>
                                            <ul class="tooltip-list">
                                                <li>${fullName}</li>
                                                <li>ASIN: ${item.asin || '-'}</li>
                                            </ul>
                                        </div>
                                    </span>
                                    ${discountInfo}
                                </div>
                                <div class="product-brand">${item.brand_variant || ''}</div>
                            </div>
                        </div>
                    </td>
                    <td>${item.signal}</td>
                    <td><span class="action-tag ${item.action_tag.toLowerCase()}">${item.action_tag}</span></td>
                    <td><a href="#" class="link-action" onclick="event.stopPropagation(); goToProductDetail('${item.asin || ''}', '${item.product_name || ''}');">상세 분석 →</a></td>
                </tr>
                `;
            }).join('');

            // 주의 제품 툴팁 업데이트
            updateWarningTooltip(items);

            // 카테고리 포지션 툴팁 업데이트
            updateCategoryPositionTooltip(items);

            // 제품명 툴팁 위치 이벤트 바인딩
            bindProductTooltipEvents();
        }

        // 제품명 툴팁 동적 위치 조정 및 표시
        function bindProductTooltipEvents() {
            document.querySelectorAll('.product-name-wrapper').forEach(wrapper => {
                // onmouseenter/onmouseleave로 직접 할당 (중복 방지)
                wrapper.onmouseenter = function() {
                    const tooltip = this.querySelector('.product-name-tooltip');
                    if (!tooltip) return;

                    const rect = this.getBoundingClientRect();
                    const tooltipWidth = 300;
                    const tooltipHeight = 150;
                    const padding = 10;

                    // 기본: 아래쪽에 표시
                    let top = rect.bottom + padding;
                    let left = rect.left;

                    // 오른쪽 화면 경계 체크
                    if (left + tooltipWidth > window.innerWidth) {
                        left = window.innerWidth - tooltipWidth - padding;
                    }

                    // 왼쪽 경계 체크
                    if (left < padding) {
                        left = padding;
                    }

                    // 아래쪽 화면 경계 체크 - 위로 표시
                    if (top + tooltipHeight > window.innerHeight) {
                        top = rect.top - tooltipHeight - padding;
                    }

                    tooltip.style.top = top + 'px';
                    tooltip.style.left = left + 'px';
                    tooltip.style.opacity = '1';
                    tooltip.style.visibility = 'visible';
                };

                wrapper.onmouseleave = function() {
                    const tooltip = this.querySelector('.product-name-tooltip');
                    if (tooltip) {
                        tooltip.style.opacity = '0';
                        tooltip.style.visibility = 'hidden';
                    }
                };
            });
        }

        // 제품명 말줄임 함수 (20자 초과 시 ...)
        function truncateProductName(name, maxLength = 20) {
            if (!name) return '';
            return name.length > maxLength ? name.substring(0, maxLength) + '...' : name;
        }

        // 주의 제품 툴팁 업데이트
        function updateWarningTooltip(items) {
            const warningItems = items.filter(item => item.priority === 'P1' || item.action_tag === 'CHECK' || item.action_tag === 'RISK');
            const tooltipList = document.getElementById('warningProductsList');
            const warningCount = document.getElementById('warningCount');

            if (tooltipList && warningItems.length > 0) {
                tooltipList.innerHTML = warningItems.map(item =>
                    `<li><span title="${item.product_name}">${truncateProductName(item.product_name)} - ${item.signal}</span></li>`
                ).join('');
                if (warningCount) warningCount.textContent = warningItems.length + '개';
            } else if (tooltipList) {
                tooltipList.innerHTML = '<li><span>주의 제품 없음</span></li>';
                if (warningCount) warningCount.textContent = '0개';
            }
        }

        // 카테고리 포지션 툴팁 업데이트
        function updateCategoryPositionTooltip(items) {
            const tooltipList = document.getElementById('categoryPositionList');
            const positionValue = document.getElementById('categoryPositionValue');

            if (!tooltipList || !items || items.length === 0) return;

            // ASIN별로 가장 좋은 순위만 선택 (중복 제거)
            const asinBest = {};
            items.forEach(item => {
                const asin = item.asin;
                if (!asin) return;

                // rank를 숫자로 추출
                const rankMatch = item.signal?.match(/(\d+)위/) || item.signal?.match(/Top (\d+)/);
                const rank = rankMatch ? parseInt(rankMatch[1]) : 999;

                if (!asinBest[asin] || rank < asinBest[asin].rank) {
                    asinBest[asin] = {
                        name: item.product_name,
                        rank: rank,
                        category: item.category_name || '카테고리'
                    };
                }
            });

            // 순위순으로 정렬
            const sortedProducts = Object.values(asinBest)
                .filter(p => p.rank <= 50)  // Top 50 이내만 표시
                .sort((a, b) => a.rank - b.rank)
                .slice(0, 6);  // 최대 6개

            if (sortedProducts.length > 0) {
                tooltipList.innerHTML = sortedProducts.map(p =>
                    `<li><span>${p.name} - ${p.category} ${p.rank}위</span></li>`
                ).join('');

                // 가장 좋은 순위로 표시 업데이트
                const bestRank = sortedProducts[0].rank;
                if (positionValue) {
                    positionValue.textContent = `Top ${bestRank}`;
                }
            }
        }

        // 노출 상태 툴팁 업데이트
        function updateExposureStatusTooltip(homeData, items) {
            const tooltipList = document.getElementById('exposureStatusList');
            const statusValue = document.getElementById('exposureStatusValue');
            const statusCard = document.getElementById('exposureStatusCard');

            if (!tooltipList || !homeData) return;

            const status = homeData.status || {};
            const exposure = status.exposure || 'Stable';
            const top10Count = status.top10_count || 0;

            // 상태 값 업데이트
            if (statusValue) {
                statusValue.textContent = exposure;
            }

            // 카드 클래스 업데이트 (상태에 따라 색상 변경)
            if (statusCard) {
                statusCard.classList.remove('success', 'info', 'danger');
                if (exposure.includes('Up') || exposure.includes('Stable')) {
                    statusCard.classList.add('success');
                } else if (exposure.includes('Moderate')) {
                    statusCard.classList.add('info');
                } else {
                    statusCard.classList.add('danger');
                }
            }

            // 툴팁 내용 생성
            const tooltipItems = [];

            // Top 10 내 제품 수
            tooltipItems.push(`Top 10 내 LANEIGE 제품: <strong>${top10Count}개</strong>`);

            // 상태 판단 기준 설명
            if (top10Count >= 3) {
                tooltipItems.push('판단: 3개 이상 → <strong>Stable Up</strong>');
            } else if (top10Count >= 1) {
                tooltipItems.push('판단: 1~2개 → <strong>Moderate</strong>');
            } else {
                tooltipItems.push('판단: 0개 → <strong>Needs Attention</strong>');
            }

            // 순위 변동 요약 (items에서 추출)
            if (items && items.length > 0) {
                const upItems = items.filter(i => i.signal?.includes('상향')).length;
                const downItems = items.filter(i => i.signal?.includes('하락') && i.signal?.includes('순위')).length;
                if (upItems > 0) tooltipItems.push(`순위 상승 제품: <strong>${upItems}개</strong>`);
                if (downItems > 0) tooltipItems.push(`순위 하락 제품: <strong>${downItems}개</strong>`);
            }

            tooltipList.innerHTML = tooltipItems.map(item => `<li><span>${item}</span></li>`).join('');
        }

        // 경쟁사 테이블 업데이트
        function updateCompetitorTable(competitors) {
            const tbody = document.getElementById('competitor-tbody');
            if (!tbody) return;

            // Empty state 처리
            if (!competitors || !competitors.length) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="7">
                            <div class="table-empty-state">
                                <i data-lucide="users" class="empty-icon"></i>
                                <div class="empty-title">경쟁사 데이터 없음</div>
                                <div class="empty-desc">크롤링 완료 후 표시됩니다 (매일 22:00 KST)</div>
                            </div>
                        </td>
                    </tr>
                `;
                lucide.createIcons();
                return;
            }

            // LANEIGE SoS 찾기 (기준점) - competitors에 없으면 brand.kpis에서 가져옴
            let laneige = competitors.find(c => c.brand.toUpperCase().includes('LANEIGE'));

            // LANEIGE가 competitors에 없으면 brand.kpis에서 구성하여 맨 앞에 추가
            if (!laneige && dashboardData?.brand?.kpis) {
                const kpis = dashboardData.brand.kpis;
                // kpis.sos가 객체인 경우 평균값 계산
                let sosValue = kpis.sos;
                if (typeof sosValue === 'object' && sosValue !== null) {
                    const sosValues = Object.values(sosValue).filter(v => typeof v === 'number' && v > 0);
                    sosValue = sosValues.length > 0
                        ? parseFloat((sosValues.reduce((a, b) => a + b, 0) / sosValues.length).toFixed(1))
                        : 0;
                }

                // product_count 계산: laneige_products 배열 길이 또는 kpis에서 가져옴
                const productCount = dashboardData.laneige_products?.length || kpis.product_count || kpis.top10_count || 0;

                laneige = {
                    brand: 'LANEIGE',
                    sos: sosValue || 0,
                    avg_rank: kpis.avg_rank || 0,
                    product_count: productCount,
                    avg_price: kpis.avg_price || null,
                    is_laneige: true
                };
                // LANEIGE를 배열 맨 앞에 추가 (SoS 순서 유지를 위해 나중에 정렬)
                competitors = [laneige, ...competitors];
                // SoS 기준 내림차순 정렬
                competitors.sort((a, b) => b.sos - a.sos);
            }

            const laneigeSos = laneige ? laneige.sos : 0;

            // 상위 5개 브랜드만 표시
            const top5 = competitors.slice(0, 5);

            // Empty cell helper
            const emptyCell = (tooltip) => `<span class="empty-cell" title="${tooltip}"><span class="dot"></span>미수집</span>`;

            tbody.innerHTML = top5.map((comp, idx) => {
                const isLaneige = comp.brand.toUpperCase().includes('LANEIGE');
                const sosDiff = (comp.sos - laneigeSos).toFixed(1);
                const vsBadgeClass = isLaneige ? 'baseline' : (parseFloat(sosDiff) > 0 ? 'ahead' : 'behind');
                const vsBadgeText = isLaneige ? '기준' : (parseFloat(sosDiff) > 0 ? `+${sosDiff}%p` : `${sosDiff}%p`);
                // 평균 가격 표시 (avg_price 필드 사용) - 통화 변환 지원
                const avgPriceDisplay = comp.avg_price ? formatPrice(comp.avg_price) : emptyCell('해당 기간 가격 정보 미수집');
                const productCountDisplay = (comp.product_count || comp.count) ? `${comp.product_count || comp.count}개` : emptyCell('제품 수 미수집');
                const avgRankDisplay = comp.avg_rank ? `${comp.avg_rank.toFixed(1)}위` : emptyCell('평균 순위 미수집');

                return `
                    <tr class="${isLaneige ? 'highlight-row' : ''}">
                        <td><span class="rank-badge">#${idx + 1}</span></td>
                        <td>${isLaneige ? '<strong>' + comp.brand + '</strong>' : comp.brand}</td>
                        <td>${comp.sos}%</td>
                        <td>${productCountDisplay}</td>
                        <td>${avgRankDisplay}</td>
                        <td>${avgPriceDisplay}</td>
                        <td><span class="vs-badge ${vsBadgeClass}">${vsBadgeText}</span></td>
                    </tr>
                `;
            }).join('');
        }

        // Utility function to generate discount badges HTML
        function generateDiscountBadges(product) {
            let badges = '';

            // Discount percentage badge
            if (product.discount_percent && product.discount_percent > 0) {
                badges += `<span class="discount-badge">-${product.discount_percent}%</span>`;
            }

            // Coupon badge
            if (product.coupon_text || product.has_coupon) {
                const couponText = product.coupon_text || 'Coupon';
                badges += `<span class="coupon-badge">🎟️ ${couponText}</span>`;
            }

            // Deal badge (Lightning Deal, Limited Time Deal, etc.)
            if (product.deal_type || product.is_deal) {
                const dealText = product.deal_type || 'Deal';
                badges += `<span class="deal-badge">⚡ ${dealText}</span>`;
            }

            return badges;
        }

        // Utility function to generate price display HTML
        function generatePriceDisplay(product) {
            if (!product.price && !product.current_price) {
                return '<span style="color: var(--text-secondary);">가격 정보 없음</span>';
            }

            const currentPrice = product.current_price || product.price;
            const originalPrice = product.original_price;

            let priceHtml = '<div class="price-container">';

            // Show original price if there's a discount - 통화 변환 지원
            if (originalPrice && originalPrice > currentPrice) {
                priceHtml += `<span class="price-original">${formatPrice(originalPrice)}</span>`;
            }

            // Current price - 통화 변환 지원
            priceHtml += `<span class="price-current">${formatPrice(currentPrice)}</span>`;

            priceHtml += '</div>';

            return priceHtml;
        }

        // 경쟁사 드롭다운 동적 생성
        function populateCompetitorDropdown() {
            const select = document.getElementById('competitor-select');
            if (!select) return;

            const competitors = dashboardData?.brand?.competitors || [];

            // 기존 동적 옵션 제거 (Summer Fridays는 유지)
            const options = select.querySelectorAll('option:not([value=""]):not([value="Summer Fridays"])');
            options.forEach(opt => opt.remove());

            // 경쟁사 데이터에서 옵션 추가 (Summer Fridays 제외)
            competitors.forEach(comp => {
                if (comp.brand && comp.brand !== 'Summer Fridays') {
                    const option = document.createElement('option');
                    option.value = comp.brand;
                    option.textContent = comp.brand;
                    select.appendChild(option);
                }
            });
        }

        // 상세 경쟁사 비교 기간 상태 관리
        let detailedComparisonDateState = {
            startDate: null,
            endDate: null
        };

        // 상세 경쟁사 비교 기간 선택 초기화
        function initDetailedComparisonDateRange() {
            let { startDate, endDate } = globalDateRange.get();

            // globalDateRange가 초기화되지 않은 경우 fallback
            if (!startDate || !endDate) {
                const today = new Date();
                endDate = today.toISOString().split('T')[0];
                const start = new Date(today);
                start.setDate(start.getDate() - 6);
                startDate = start.toISOString().split('T')[0];
            }

            const startInput = document.getElementById('detailedCompStartDate');
            const endInput = document.getElementById('detailedCompEndDate');
            if (startInput && endInput) {
                startInput.value = startDate;
                endInput.value = endDate;
            }

            detailedComparisonDateState.startDate = startDate;
            detailedComparisonDateState.endDate = endDate;

            // 기간 배지 업데이트
            updateDetailedComparisonPeriodBadge(startDate, endDate);
        }

        // 상세 경쟁사 비교 기간 적용
        async function applyDetailedComparisonDateRange() {
            const startDate = document.getElementById('detailedCompStartDate')?.value;
            const endDate = document.getElementById('detailedCompEndDate')?.value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            detailedComparisonDateState.startDate = startDate;
            detailedComparisonDateState.endDate = endDate;

            // 기간 배지 업데이트
            updateDetailedComparisonPeriodBadge(startDate, endDate);

            // 히스토리컬 데이터 다시 조회
            try {
                const response = await fetch(`${API_BASE}/api/historical?start_date=${startDate}&end_date=${endDate}&brand=LANEIGE`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.success && data.brand_metrics) {
                        // 경쟁사 데이터 업데이트
                        if (dashboardData && dashboardData.brand) {
                            dashboardData.brand.competitors = data.brand_metrics;
                        }
                        // 경쟁사 비교 테이블 및 상세 비교 업데이트
                        updateCompetitorComparison();
                        showToast(`${formatDateRange(startDate, endDate)} 기간 데이터 적용`, 'success');
                    }
                }
            } catch (error) {
                console.error('상세 비교 기간 데이터 로드 실패:', error);
                showToast('데이터 로드에 실패했습니다.', 'error');
            }
        }

        // 기간 배지 업데이트
        function updateDetailedComparisonPeriodBadge(startDate, endDate) {
            const badge = document.getElementById('detailed-comparison-period-badge');
            if (!badge) return;

            const start = new Date(startDate);
            const end = new Date(endDate);
            const diffDays = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            const formatDate = (d) => `${(d.getMonth() + 1).toString().padStart(2, '0')}.${d.getDate().toString().padStart(2, '0')}`;

            if (diffDays <= 7) {
                badge.textContent = `최근 ${diffDays}일 (${formatDate(start)}~${formatDate(end)})`;
            } else if (diffDays <= 14) {
                badge.textContent = `${diffDays}일 (${formatDate(start)}~${formatDate(end)})`;
            } else {
                badge.textContent = `${formatDate(start)}~${formatDate(end)}`;
            }
        }

        // 날짜 범위 포맷
        function formatDateRange(startDate, endDate) {
            const start = new Date(startDate);
            const end = new Date(endDate);
            const formatDate = (d) => `${(d.getMonth() + 1).toString().padStart(2, '0')}.${d.getDate().toString().padStart(2, '0')}`;
            return `${formatDate(start)}~${formatDate(end)}`;
        }

        // Enhanced Competitor Comparison
        function updateCompetitorComparison() {
            const select = document.getElementById('competitor-select');
            const bodyDiv = document.getElementById('detailed-comparison-body');

            if (!select || !bodyDiv) return;

            const competitorName = select.value;

            if (!competitorName) {
                bodyDiv.innerHTML = `
                    <div style="text-align: center; padding: 40px 0; color: var(--text-secondary);">
                        <i data-lucide="users" style="width: 48px; height: 48px; margin-bottom: 12px; opacity: 0.3;"></i>
                        <p>비교할 경쟁사를 선택하세요</p>
                    </div>
                `;
                lucide.createIcons();
                return;
            }

            // LANEIGE 데이터: brand.kpis에서 우선 가져오기 (competitors에 없을 수 있음)
            const kpis = dashboardData?.brand?.kpis || {};
            const competitors = dashboardData?.brand?.competitors || [];

            // LANEIGE 데이터 구성
            const laneige = {
                brand: 'LANEIGE',
                sos: kpis.sos || 0,
                product_count: kpis.top10_count || kpis.product_count || 0,
                avg_rank: kpis.avg_rank || 0,
                avg_price: kpis.avg_price || 0
            };

            // 경쟁사 데이터 찾기
            const competitor = competitors.find(c => c.brand === competitorName) || {
                brand: competitorName,
                sos: 0,
                product_count: 0,
                avg_rank: 0,
                avg_price: 0
            };

            // Helper function to compare values
            function compareValues(val1, val2, lowerIsBetter = false) {
                if (!val1 || !val2) return 'same';
                if (lowerIsBetter) {
                    return val1 < val2 ? 'better' : val1 > val2 ? 'worse' : 'same';
                }
                return val1 > val2 ? 'better' : val1 < val2 ? 'worse' : 'same';
            }

            // Generate comparison table
            bodyDiv.innerHTML = `
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th class="metric-label">지표</th>
                            <th class="value-cell">LANEIGE</th>
                            <th class="value-cell">${competitorName}</th>
                            <th class="value-cell">우위</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td class="metric-label">Share of Shelf (SoS)</td>
                            <td class="value-cell">${laneige.sos ? laneige.sos.toFixed(1) + '%' : '-'}</td>
                            <td class="value-cell">${competitor.sos ? competitor.sos.toFixed(1) + '%' : '-'}</td>
                            <td class="value-cell ${compareValues(laneige.sos, competitor.sos)}">
                                ${laneige.sos > competitor.sos ? '✓ LANEIGE' : laneige.sos < competitor.sos ? competitorName : '동일'}
                            </td>
                        </tr>
                        <tr>
                            <td class="metric-label">제품 수</td>
                            <td class="value-cell">${laneige.product_count || laneige.count || '-'}개</td>
                            <td class="value-cell">${competitor.product_count || competitor.count || '-'}개</td>
                            <td class="value-cell ${compareValues(laneige.product_count, competitor.product_count)}">
                                ${(laneige.product_count || 0) > (competitor.product_count || 0) ? '✓ LANEIGE' :
                                  (laneige.product_count || 0) < (competitor.product_count || 0) ? competitorName : '동일'}
                            </td>
                        </tr>
                        <tr>
                            <td class="metric-label">평균 순위</td>
                            <td class="value-cell">${laneige.avg_rank ? laneige.avg_rank.toFixed(1) + '위' : '-'}</td>
                            <td class="value-cell">${competitor.avg_rank ? competitor.avg_rank.toFixed(1) + '위' : '-'}</td>
                            <td class="value-cell ${compareValues(laneige.avg_rank, competitor.avg_rank, true)}">
                                ${(laneige.avg_rank || 999) < (competitor.avg_rank || 999) ? '✓ LANEIGE' :
                                  (laneige.avg_rank || 999) > (competitor.avg_rank || 999) ? competitorName : '동일'}
                            </td>
                        </tr>
                        <tr>
                            <td class="metric-label">평균 가격</td>
                            <td class="value-cell">${laneige.avg_price ? formatPrice(laneige.avg_price) : '-'}</td>
                            <td class="value-cell">${competitor.avg_price ? formatPrice(competitor.avg_price) : '-'}</td>
                            <td class="value-cell same">
                                ${Math.abs((laneige.avg_price || 0) - (competitor.avg_price || 0)) < 1 ? '비슷함' :
                                  (laneige.avg_price || 0) > (competitor.avg_price || 0) ? 'LANEIGE 고가' : competitorName + ' 고가'}
                            </td>
                        </tr>
                    </tbody>
                </table>
                <div class="chart-guide" style="margin-top: 16px;">
                    <strong>분석:</strong> ${competitorName}과(와) LANEIGE의 핵심 지표 비교.
                    <span class="better" style="display: inline;">✓</span> 표시는 우위를 나타냅니다.
                </div>
            `;
        }

        // 제품 상세 페이지로 이동
        function goToProductDetail(asin, productName) {
            // 제품 페이지로 전환
            switchPage('product');

            // 제품 선택 드롭다운에서 해당 제품 찾기
            const productSelect = document.getElementById('productSelect');
            if (productSelect && productName) {
                // 제품명으로 옵션 찾기
                const options = productSelect.options;
                for (let i = 0; i < options.length; i++) {
                    if (options[i].textContent.includes(productName.split(' ')[0])) {
                        productSelect.selectedIndex = i;
                        updateProductView();
                        break;
                    }
                }
            }

            // 챗봇 열고 해당 제품 분석 요청
            setTimeout(() => {
                const chatInput = document.getElementById('chatInput');
                if (chatInput && productName) {
                    chatInput.value = `${productName} 제품의 상세 분석을 해주세요.`;
                    chatInput.focus();
                }
            }, 300);
        }

        // SoS 추이 차트 날짜 범위 초기화 (글로벌 날짜 범위 사용)
        function initSosTrendDateRange() {
            let { startDate, endDate } = globalDateRange.get();

            // globalDateRange가 아직 초기화되지 않은 경우 fallback
            if (!startDate || !endDate) {
                console.warn('[initSosTrendDateRange] globalDateRange not initialized, using fallback');
                if (dashboardData?.charts?.sos_trend?.['30d']?.labels) {
                    const labels = dashboardData.charts.sos_trend['30d'].labels;
                    if (labels.length > 0) {
                        // globalDateRange의 변환 함수 사용
                        startDate = globalDateRange.convertLabelToDate(labels[0]);
                        endDate = globalDateRange.convertLabelToDate(labels[labels.length - 1]);
                    }
                }
                if (!startDate || !endDate) {
                    const today = new Date();
                    endDate = today.toISOString().split('T')[0];
                    const start = new Date(today);
                    start.setDate(start.getDate() - 13);
                    startDate = start.toISOString().split('T')[0];
                }
            }

            const startInput = document.getElementById('sosTrendStartDate');
            const endInput = document.getElementById('sosTrendEndDate');
            if (startInput && endInput) {
                startInput.value = startDate;
                endInput.value = endDate;
            }
        }

        // SoS 추이 차트 날짜 범위 적용 (글로벌 상태 업데이트 포함)
        async function applySosTrendDateRange() {
            const startDate = document.getElementById('sosTrendStartDate')?.value;
            const endDate = document.getElementById('sosTrendEndDate')?.value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 글로벌 날짜 범위 업데이트 (모든 차트 자동 업데이트)
            globalDateRange.set(startDate, endDate);
        }

        // 기존 호환성 유지용 (사용 안함)
        function updateSosTrendPeriod(days, btnElement) {
            // 날짜 선택기로 대체됨
        }

        function switchPage(pageId) {
            currentPage = pageId;
            document.querySelectorAll('.page-view').forEach(p => p.classList.remove('active'));
            document.getElementById(`page-${pageId}`).classList.add('active');
            document.querySelectorAll('.nav-item').forEach(item => { item.classList.remove('active'); if (item.dataset.page === pageId) item.classList.add('active'); });
            // 모바일에서 페이지 전환 시 사이드바 닫기
            if (window.innerWidth <= 768) {
                const sidebar = document.getElementById('sidebar');
                const overlay = document.querySelector('.sidebar-overlay');
                if (sidebar) sidebar.classList.remove('open');
                if (overlay) overlay.classList.remove('active');
            }
            const titles = {
                home: { title: 'Home', breadcrumb: 'Daily Insight & Action Board' },
                brand: { title: 'Brand View (L1)', breadcrumb: 'Laneige 브랜드 분석' },
                category: { title: 'Category View (L2)', breadcrumb: 'Amazon US 카테고리 분석' },
                product: { title: 'Product View (L3)', breadcrumb: 'Laneige 제품 상세' }
            };
            document.getElementById('page-title').textContent = titles[pageId].title;
            document.getElementById('breadcrumb').textContent = titles[pageId].breadcrumb;
            initChartsForPage(pageId);
            // Brand View 진입 시 경쟁사 테이블 7일 데이터로 업데이트
            if (pageId === 'brand') {
                setTimeout(async () => {
                    const end = new Date();
                    const start = new Date();
                    start.setDate(start.getDate() - 6);  // 7일간 (오늘 포함)
                    const startStr = start.toISOString().split('T')[0];
                    const endStr = end.toISOString().split('T')[0];

                    // 날짜 입력 필드 설정
                    const competitorStartInput = document.getElementById('competitorStartDate');
                    const competitorEndInput = document.getElementById('competitorEndDate');
                    if (competitorStartInput && competitorEndInput) {
                        competitorStartInput.value = startStr;
                        competitorEndInput.value = endStr;
                    }

                    // 경쟁사 테이블 7일 데이터로 업데이트
                    await updateCompetitorTableWithRange(startStr, endStr);
                }, 200);
            }
            // Product View 진입 시 최근 7일로 설정 후 차트 데이터 로드
            if (pageId === 'product') {
                setTimeout(() => {
                    // 최근 7일 기간 설정
                    const end = new Date();
                    const start = new Date();
                    start.setDate(start.getDate() - 6);  // 7일간 (오늘 포함)
                    const startStr = start.toISOString().split('T')[0];
                    const endStr = end.toISOString().split('T')[0];

                    // Product View의 모든 날짜 선택기를 최근 7일로 설정
                    const dateInputPairs = [
                        ['productStartDate', 'productEndDate'],
                        ['rankTrendStartDate', 'rankTrendEndDate'],
                        ['matrixStartDate', 'matrixEndDate'],
                        ['discountStartDate', 'discountEndDate'],
                        ['growthTypeStartDate', 'growthTypeEndDate'],
                        ['competitorPromoStartDate', 'competitorPromoEndDate']
                    ];

                    dateInputPairs.forEach(([startId, endId]) => {
                        const startInput = document.getElementById(startId);
                        const endInput = document.getElementById(endId);
                        if (startInput && endInput) {
                            startInput.value = startStr;
                            endInput.value = endStr;
                        }
                    });

                    loadInitialProductChartData();
                }, 200);
            }
        }

        // === Category Date Range Functions ===
        let categoryDateRange = {
            start: null,
            end: null
        };

        // === CPI 점수 변환 함수 (100점 만점 스케일링) ===
        // 원본 CPI(비율): 100 = 경쟁사 동일, >100 = 고가, <100 = 저가
        // 변환 점수: 100 = 최고(저가), 50 = 동일, 0 = 최저(2배 고가)
        function convertCpiToScore(rawCpi) {
            return Math.max(0, Math.min(100, Math.round((200 - rawCpi) / 2)));
        }

        function initCategoryDateRange() {
            // 카테고리 KPI는 최근 7일 고정 (날짜 선택 UI 제거됨)
            // 특정 기간 데이터가 필요하면 챗봇에게 질문

            // 글로벌 날짜 범위 사용
            const { startDate, endDate } = globalDateRange.get();

            // CPI 차트 날짜 범위 초기화
            const cpiStartInput = document.getElementById('cpiStartDate');
            const cpiEndInput = document.getElementById('cpiEndDate');
            if (cpiStartInput && cpiEndInput) {
                cpiStartInput.value = startDate;
                cpiEndInput.value = endDate;
            }

            // CPI 드롭다운 변경 이벤트 리스너 추가
            const cpiLaneigeSelect = document.getElementById('cpiLaneigeProductSelect');
            const cpiCompetitorSelect = document.getElementById('cpiCompetitorProductSelect');
            if (cpiLaneigeSelect) {
                cpiLaneigeSelect.addEventListener('change', () => applyCpiDateRange());
            }
            if (cpiCompetitorSelect) {
                cpiCompetitorSelect.addEventListener('change', () => applyCpiDateRange());
            }
        }

        async function applyCpiDateRange() {
            const startDate = document.getElementById('cpiStartDate')?.value;
            const endDate = document.getElementById('cpiEndDate')?.value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 글로벌 날짜 범위 업데이트 (모든 차트 자동 업데이트)
            globalDateRange.set(startDate, endDate);
        }

        // CPI 차트: LANEIGE 브랜드 평균가 vs 경쟁사 Top 100 평균가 (기간 조정 가능)
        // 현재 선택된 CPI 기간 (일 수)
        let currentCpiPeriodDays = 7;

        async function updateCpiChartWithBrandAverage(customStartDate = null, customEndDate = null) {
            try {
                // 커스텀 날짜가 있으면 사용, 아니면 기본 기간 사용
                let startStr, endStr;
                if (customStartDate && customEndDate) {
                    startStr = customStartDate;
                    endStr = customEndDate;
                } else {
                    const endDate = new Date();
                    const startDate = new Date();
                    startDate.setDate(startDate.getDate() - (currentCpiPeriodDays - 1));  // 선택된 기간
                    startStr = startDate.toISOString().split('T')[0];
                    endStr = endDate.toISOString().split('T')[0];
                }

                console.log('[CPI Brand Avg] Loading data for:', startStr, '~', endStr);

                const historicalData = await fetchHistoricalData(startStr, endStr);
                if (!historicalData) {
                    console.log('[CPI Brand Avg] No historical data');
                    return;
                }

                const rankHistory = historicalData.rank_history || {};
                const allDates = Object.keys(rankHistory).sort();
                const dates = allDates.filter(d => d >= startStr && d <= endStr);

                // 누락 날짜 계산 및 UI 업데이트
                const missingDatesList = calculateMissingDates(startStr, endStr, dates);
                updateMissingDatesUI('cpi', missingDatesList);

                console.log('[CPI Brand Avg] Available dates:', dates.length);

                // 일별 브랜드 평균 가격 계산
                const dailyCpi = [];
                const labels = [];

                dates.forEach(date => {
                    const dayData = rankHistory[date];
                    if (!dayData || !dayData.products) {
                        labels.push(date.slice(5));
                        dailyCpi.push(null);
                        return;
                    }

                    // LANEIGE 제품들의 평균 가격
                    const laneigePrices = dayData.products
                        .filter(p => p.brand && p.brand.toLowerCase() === 'laneige' && p.price && p.price > 0)
                        .map(p => p.price);

                    // 경쟁사 (LANEIGE 제외) Top 100 제품들의 평균 가격
                    const competitorPrices = dayData.products
                        .filter(p => p.brand && p.brand.toLowerCase() !== 'laneige' && p.price && p.price > 0)
                        .map(p => p.price);

                    const dateLabel = date.slice(5); // MM-DD
                    labels.push(dateLabel);

                    if (laneigePrices.length > 0 && competitorPrices.length > 0) {
                        const laneigeAvg = laneigePrices.reduce((a, b) => a + b, 0) / laneigePrices.length;
                        const competitorAvg = competitorPrices.reduce((a, b) => a + b, 0) / competitorPrices.length;
                        const cpi = (laneigeAvg / competitorAvg) * 100;
                        dailyCpi.push(parseFloat(cpi.toFixed(1)));
                        console.log(`[CPI] ${dateLabel}: LANEIGE avg $${laneigeAvg.toFixed(2)} (${laneigePrices.length}개) vs Competitors avg $${competitorAvg.toFixed(2)} (${competitorPrices.length}개) = CPI ${cpi.toFixed(1)}`);
                    } else {
                        dailyCpi.push(null);
                    }
                });

                const validCount = dailyCpi.filter(v => v !== null).length;
                console.log('[CPI Brand Avg] Valid data points:', validCount, '/', dates.length);

                if (validCount > 0) {
                    updateCpiChartSimple(labels, dailyCpi);
                }

            } catch (error) {
                console.error('[CPI Brand Avg] Error:', error);
            }
        }

        // 간소화된 CPI 차트 업데이트 (100점 만점 점수 기반)
        function updateCpiChartSimple(labels, cpiData) {
            const ctx = document.getElementById('cpiChart');
            if (!ctx) return;

            // 기존 차트 제거
            if (charts.cpi) {
                charts.cpi.destroy();
            }

            // 원본 CPI를 100점 만점 점수로 변환
            const scoreData = cpiData.map(v => v === null ? null : convertCpiToScore(v));

            // Y축 스케일: 데이터 기반 동적 조정 (기준선 50 포함 보장)
            const validScores = scoreData.filter(v => v !== null);
            const dataMax = validScores.length > 0 ? Math.max(...validScores) : 50;
            const dataMin = validScores.length > 0 ? Math.min(...validScores) : 0;

            // Y축 범위: 최소 0, 최대는 데이터+여유 or 기준선(50)+여유 중 큰 값
            const yMin = 0;
            const yMax = Math.max(Math.ceil((dataMax + 10) / 25) * 25, 75); // 최소 75, 25단위로 올림

            charts.cpi = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'LANEIGE 가격경쟁력 점수',
                            data: scoreData,
                            borderColor: '#1F5795',
                            backgroundColor: 'rgba(31, 87, 149, 0.15)',
                            borderWidth: 2.5,
                            fill: false,
                            tension: 0.3,
                            spanGaps: false,
                            pointRadius: function(context) {
                                return context.raw === null ? 0 : 5;
                            },
                            pointBackgroundColor: '#1F5795',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            segment: {
                                borderDash: ctx => {
                                    if (ctx.p0.skip || ctx.p1.skip) return [5, 5];
                                    return undefined;
                                }
                            }
                        },
                        {
                            label: '기준선 (50점 = 동일가격)',
                            data: Array(labels.length).fill(50),
                            borderColor: '#E74C3C',
                            borderWidth: 2,
                            borderDash: [5, 5],
                            fill: false,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { font: { size: 11 } }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                return tooltipItem.raw !== null;
                            },
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        const score = context.parsed.y;
                                        if (score === null) return null;
                                        let status;
                                        if (score >= 90) status = '가격 경쟁력 우위';
                                        else if (score >= 50) status = '적정 가격';
                                        else status = '가격 경쟁력 하락';
                                        return `${score}점 (${status})`;
                                    }
                                    return context.dataset.label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            min: yMin,
                            max: yMax,
                            ticks: {
                                font: { size: 11 },
                                stepSize: 25,
                                callback: function(value) {
                                    if (value === 50) return '★ 50 (기준)';
                                    if (value === 0) return '0 (최저)';
                                    return value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    // 50 기준선은 데이터셋의 점선으로 표시하므로 그리드는 투명
                                    if (context.tick.value === 50) {
                                        return 'transparent';
                                    }
                                    return 'rgba(0, 0, 0, 0.08)';
                                }
                            }
                        },
                        x: {
                            ticks: {
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 10
                            }
                        }
                    }
                }
            });

            // 정보 업데이트 (100점 만점 점수 기반)
            const infoEl = document.getElementById('cpi-comparison-info');
            if (infoEl) {
                const validScores = scoreData.filter(v => v !== null);
                const avgScore = validScores.length > 0
                    ? Math.round(validScores.reduce((a, b) => a + b, 0) / validScores.length)
                    : 50;
                let status;
                if (avgScore >= 90) status = '가격 경쟁력 우위';
                else if (avgScore >= 50) status = '적정 가격';
                else status = '가격 경쟁력 하락';
                infoEl.innerHTML = `📊 <strong>비교:</strong> LANEIGE 브랜드 평균 vs 경쟁사 Top 100 평균 | <strong>평균 점수:</strong> ${avgScore}점 (${status})`;
            }
        }

        // 기존 함수 호환성 유지 (무시하고 브랜드 평균 사용)
        async function updateCpiChartWithProducts(startDate, endDate) {
            // 최근 7일 고정으로 변경됨 - 브랜드 평균 비교 방식 사용
            await updateCpiChartWithBrandAverage();
        }

        function updateCpiChart(labels, data, laneigeName, competitorName, competitorBrand, actualRange = '', missingDates = 0, totalDates = 0, validDates = 0) {
            const ctx = document.getElementById('cpiChart');
            if (!ctx) return;

            // 기존 차트 제거
            if (charts.cpi) {
                charts.cpi.destroy();
            }

            const shortLaneige = laneigeName.length > 25 ? laneigeName.substring(0, 25) + '...' : laneigeName;
            const shortCompetitor = competitorName.length > 25 ? competitorName.substring(0, 25) + '...' : competitorName;

            // Y축 스케일: 100을 정확히 가운데로 배치 (null 값 제외)
            const numericData = data.filter(v => v !== null).map(Number);
            const dataMax = numericData.length > 0 ? Math.max(...numericData) : 130;
            const dataMin = numericData.length > 0 ? Math.min(...numericData) : 70;

            // 100에서 가장 멀리 떨어진 값 기준으로 대칭 범위 설정
            const maxDeviation = Math.max(
                Math.abs(dataMax - 100),
                Math.abs(dataMin - 100)
            );
            // 여유 20% 추가, 최소 30pt
            const range = Math.max(30, Math.ceil(maxDeviation * 1.2));
            const yMin = 100 - range;
            const yMax = 100 + range;

            charts.cpi = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'LANEIGE CPI',
                            data: data,
                            borderColor: '#1F5795',
                            backgroundColor: 'rgba(31, 87, 149, 0.15)',
                            borderWidth: 2.5,
                            fill: false, // null 값이 있을 때 fill 비활성화
                            tension: 0.3,
                            spanGaps: false, // null 값에서 선 끊기
                            pointRadius: function(context) {
                                // null 값은 포인트 숨김
                                return context.raw === null ? 0 : 5;
                            },
                            pointBackgroundColor: '#1F5795',
                            pointBorderColor: '#fff',
                            pointBorderWidth: 2,
                            segment: {
                                // 데이터가 끊어진 구간 전후는 점선으로 표시
                                borderDash: ctx => {
                                    if (ctx.p0.skip || ctx.p1.skip) return [5, 5];
                                    return undefined;
                                }
                            }
                        },
                        {
                            label: '기준선 (100)',
                            data: Array(labels.length).fill(100),
                            borderColor: '#E74C3C',
                            borderWidth: 2,
                            fill: false,
                            pointRadius: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            labels: { font: { size: 11 } }
                        },
                        tooltip: {
                            filter: function(tooltipItem) {
                                // null 값은 툴팁에서 제외
                                return tooltipItem.raw !== null;
                            },
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        const cpi = context.parsed.y;
                                        if (cpi === null) return null;
                                        const diff = (cpi - 100).toFixed(1);
                                        const status = cpi >= 100 ? `+${diff} 프리미엄` : `${diff} 저가`;
                                        return `CPI: ${cpi} (${status})`;
                                    }
                                    return context.dataset.label;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            min: yMin,
                            max: yMax,
                            ticks: {
                                font: { size: 11 },
                                stepSize: range > 100 ? 50 : 25,
                                callback: function(value) {
                                    if (value === 100) return '★ 100 (기준)';
                                    return value;
                                }
                            },
                            grid: {
                                color: function(context) {
                                    // 100 기준선은 데이터셋의 점선으로 표시하므로 그리드는 투명
                                    if (context.tick.value === 100) {
                                        return 'transparent';
                                    }
                                    return 'rgba(0, 0, 0, 0.08)';
                                }
                            }
                        },
                        x: {
                            ticks: {
                                font: { size: 11 },
                                maxRotation: 45,
                                minRotation: 0,
                                autoSkip: true,
                                maxTicksLimit: 15 // 너무 많은 날짜는 자동 생략
                            }
                        }
                    }
                }
            });

            // 정보 업데이트 (개선된 표시)
            const infoEl = document.getElementById('cpi-comparison-info');
            if (infoEl) {
                // null 값 제외하고 평균 계산
                const validData = data.filter(v => v !== null);
                const avgCpi = validData.length > 0
                    ? (validData.reduce((a, b) => a + parseFloat(b), 0) / validData.length).toFixed(1)
                    : 100;
                const diff = (avgCpi - 100).toFixed(1);
                const status = avgCpi >= 100 ? `프리미엄 (+${diff}%)` : `저가 (${diff}%)`;
                let info = `📊 <strong>비교:</strong> ${shortLaneige} vs ${competitorBrand} (${shortCompetitor}) | <strong>평균 CPI:</strong> ${avgCpi} (${status})`;
                if (actualRange) {
                    info += ` | <strong>데이터 기간:</strong> ${actualRange}`;
                }
                // 개선된 누락 정보 표시
                if (totalDates > 0 && validDates > 0 && validDates < totalDates) {
                    const coverage = ((validDates / totalDates) * 100).toFixed(0);
                    info += ` <span style="color: #C4A962;">(${validDates}일/${totalDates}일 데이터, ${coverage}% 커버리지)</span>`;
                }
                infoEl.innerHTML = info;
            }
        }

        async function applyCategoryDateRange() {
            const startDate = document.getElementById('categoryStartDate').value;
            const endDate = document.getElementById('categoryEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            categoryDateRange.start = startDate;
            categoryDateRange.end = endDate;

            // CPI 차트 기간도 동기화
            const cpiStartInput = document.getElementById('cpiStartDate');
            const cpiEndInput = document.getElementById('cpiEndDate');
            if (cpiStartInput && cpiEndInput) {
                cpiStartInput.value = startDate;
                cpiEndInput.value = endDate;
            }

            // 현재 선택된 카테고리 찾기
            const activeTab = document.querySelector('.category-tab.active');
            if (activeTab) {
                const catKey = activeTab.getAttribute('onclick').match(/selectCategory\('(\w+)'/)?.[1];
                if (catKey) {
                    await loadCategoryKPIWithDateRange(catKey, startDate, endDate);
                }
            }

            // CPI 차트도 업데이트
            await updateCpiChartWithProducts(startDate, endDate);

            showToast(`기간이 ${startDate} ~ ${endDate}로 적용되었습니다.`, 'success');
        }

        async function loadCategoryKPIWithDateRange(categoryKey, startDate, endDate) {
            // category_id 매핑: SQLite에 저장된 실제 category_id와 일치해야 함
            const catMap = {
                'beauty': 'beauty',  // SQLite: 'beauty' (not 'beauty_personal_care')
                'skin': 'skin_care',
                'lip': 'lip_care',
                'lip_makeup': 'lip_makeup',
                'face_powder': 'face_powder'
            };
            const categoryId = catMap[categoryKey] || categoryKey;

            try {
                // API 호출하여 기간별 데이터 로드
                const response = await fetch(`/api/category/kpi?category_id=${categoryId}&start_date=${startDate}&end_date=${endDate}`);

                if (response.ok) {
                    const result = await response.json();
                    if (result.success && result.data) {
                        updateCategoryKPIDisplay(result.data);
                        return;
                    }
                }

                // API 실패 시 기존 데이터 사용
                console.warn('API 호출 실패, 기존 데이터 사용');

            } catch (error) {
                console.error('Category KPI 로드 오류:', error);
            }
        }

        function updateCategoryKPIDisplay(data) {
            if (data.sos !== undefined) {
                document.getElementById('cat-sos').innerHTML = data.sos.toFixed(1) + '<span class="unit">%</span>';
            }
            if (data.best_rank !== undefined) {
                document.getElementById('cat-rank').textContent = '#' + data.best_rank;
            }
            if (data.cpi !== undefined) {
                const cpiScore = convertCpiToScore(data.cpi);
                document.getElementById('cat-cpi').innerHTML = cpiScore + '<span class="unit">점</span>';
            }
            if (data.new_competitors !== undefined) {
                document.getElementById('cat-new').innerHTML = data.new_competitors + '<span class="unit">개</span>';
            }

            // 배지 업데이트 (CPI는 점수로 변환하여 전달)
            updateCategoryBadges({
                sos: data.sos || 0,
                rank: '#' + (data.best_rank || 0),
                cpiScore: convertCpiToScore(data.cpi || 100),
                new: data.new_competitors || 0
            });
        }

        async function selectCategory(cat, el) {
            document.querySelectorAll('.category-tab').forEach(t => t.classList.remove('active'));
            el.classList.add('active');

            // 카테고리 ID 매핑 (프론트엔드 탭 ID → 백엔드 category_id)
            const catMap = {
                'beauty': 'beauty',          // Beauty & Personal Care
                'skin': 'skin_care',         // Skin Care
                'lip': 'lip_care',           // Lip Care
                'lip_makeup': 'lip_makeup',  // Lip Makeup
                'face_powder': 'face_powder' // Face Powder
            };
            const catId = catMap[cat] || cat;

            // 최근 7일 고정 (기간 선택 UI 제거됨)
            // 특정 기간 데이터가 필요하면 챗봇에게 질문

            // 캐시된 dashboardData 사용 (최근 7일 데이터)
            let data;
            const catKpi = dashboardData?.charts?.category_kpis?.[catId];
            if (catKpi) {
                // Top 100 진입 여부에 따라 순위 표시 방식 변경
                const hasRank = catKpi.best_rank && catKpi.best_rank < 999;
                const rawCpi = catKpi.cpi ?? 100;
                data = {
                    sos: catKpi.sos ?? 0,
                    rank: hasRank ? '#' + catKpi.best_rank : 'Top 100 외',
                    rankValue: hasRank ? catKpi.best_rank : null,  // 배지 계산용
                    cpiScore: convertCpiToScore(rawCpi),  // 100점 만점 점수
                    new: catKpi.new_competitors ?? 0
                };
                console.log(`[Category KPI] ${catId} (캐시 사용):`, data);
            } else {
                // 데이터 없음 - 기본값
                console.warn(`[Category KPI] No data for ${catId}`);
                data = { sos: 0, rank: 'Top 100 외', rankValue: null, cpiScore: 50, new: 0 };  // 50점 = 동일 가격 기준
            }

            document.getElementById('cat-sos').innerHTML = data.sos + '<span class="unit">%</span>';
            document.getElementById('cat-rank').textContent = data.rank;
            document.getElementById('cat-cpi').innerHTML = data.cpiScore + '<span class="unit">점</span>';
            document.getElementById('cat-new').innerHTML = data.new + '<span class="unit">개</span>';

            // KPI 배지 업데이트
            updateCategoryBadges(data);

            // CPI 차트 드롭다운 데이터 로드
            const cpiStartDate = document.getElementById('cpiStartDate')?.value;
            const cpiEndDate = document.getElementById('cpiEndDate')?.value;
            if (cpiStartDate && cpiEndDate) {
                updateCpiChartWithProducts(cpiStartDate, cpiEndDate);
            }
        }

        // 카테고리 KPI 배지 동적 업데이트
        function updateCategoryBadges(data) {
            const sos = parseFloat(data.sos);
            const rank = data.rankValue;  // null이면 Top 100 외
            const cpiScore = parseFloat(data.cpiScore);  // 100점 만점 점수
            const newComp = parseInt(data.new);

            // SoS 배지
            const sosBadge = document.getElementById('cat-sos-badge');
            if (sos >= 15) {
                sosBadge.textContent = 'Category Leader';
                sosBadge.className = 'kpi-delta up';
            } else if (sos >= 8) {
                sosBadge.textContent = 'Strong Presence';
                sosBadge.className = 'kpi-delta up';
            } else {
                sosBadge.textContent = '점유율 확대 필요';
                sosBadge.className = 'kpi-delta down';
            }

            // Rank 배지
            const rankBadge = document.getElementById('cat-rank-badge');
            if (rank === null) {
                // Top 100에 진입하지 못함
                rankBadge.textContent = '진입 필요';
                rankBadge.className = 'kpi-delta down';
            } else if (rank <= 3) {
                rankBadge.textContent = '1위 근접';
                rankBadge.className = 'kpi-delta up';
            } else if (rank <= 10) {
                rankBadge.textContent = 'Top 10';
                rankBadge.className = 'kpi-delta up';
            } else {
                rankBadge.textContent = '순위 개선 필요';
                rankBadge.className = 'kpi-delta down';
            }

            // CPI 배지 (100점 만점 기준: 높을수록 가격 경쟁력 좋음)
            const cpiBadge = document.getElementById('cat-cpi-badge');
            if (cpiScore >= 90) {
                cpiBadge.textContent = '가격 경쟁력 우위';
                cpiBadge.className = 'kpi-delta up';
            } else if (cpiScore >= 50) {
                cpiBadge.textContent = '적정 가격';
                cpiBadge.className = 'kpi-delta up';
            } else {
                cpiBadge.textContent = '가격 경쟁력 하락';
                cpiBadge.className = 'kpi-delta down';
            }

            // 신규 경쟁자 배지
            const newBadge = document.getElementById('cat-new-badge');
            if (newComp >= 15) {
                newBadge.textContent = '경쟁 심화';
                newBadge.className = 'kpi-delta down';
            } else if (newComp >= 5) {
                newBadge.textContent = '보통';
                newBadge.className = 'kpi-delta';
            } else {
                newBadge.textContent = '안정적';
                newBadge.className = 'kpi-delta up';
            }
        }

        function updateProductList() {
            const cat = document.getElementById('productCategory').value;
            const select = document.getElementById('productSelect');
            select.innerHTML = '';
            categoryProducts[cat].forEach(p => { const opt = document.createElement('option'); opt.value = p[0]; opt.textContent = p[1]; select.appendChild(opt); });
            updateProductView();
        }

        function updateProductView() {
            const prod = document.getElementById('productSelect').value;
            // API 데이터 없으면 N/A 표시 (하드코딩 fallback 제거)
            const d = productData[prod] || { rank: '#N/A', rankDelta: '-', vol: '-', volDelta: '-', rating: '-', ratingDelta: '-', stick: '-', stickDelta: '-' };
            document.getElementById('prod-rank').textContent = d.rank;
            document.getElementById('prod-rank-delta').textContent = d.rankDelta;
            document.getElementById('prod-vol').innerHTML = d.vol + '<span class="unit">pt</span>';
            document.getElementById('prod-vol-delta').textContent = d.volDelta;
            document.getElementById('prod-rating').innerHTML = d.rating + '<span class="unit">★</span>';
            document.getElementById('prod-rating-delta').textContent = d.ratingDelta;
            document.getElementById('prod-stick').innerHTML = d.stick + '<span class="unit">pt</span>';
            document.getElementById('prod-stick-delta').textContent = d.stickDelta;

            // 프로모션 관련 데이터 업데이트
            updatePromoViews();
        }

        // Product View 날짜 범위 적용
        function applyProductDateRange() {
            const startDate = document.getElementById('productStartDate').value;
            const endDate = document.getElementById('productEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 기간 배지 업데이트
            const periodText = `${startDate.slice(5)} ~ ${endDate.slice(5)}`;
            const periodBadges = ['rankTrendPeriod', 'matrixPeriod', 'discountPeriod'];
            periodBadges.forEach(id => {
                const badge = document.getElementById(id);
                if (badge) badge.textContent = periodText;
            });

            // 차트 데이터 필터링 및 업데이트 (실제 데이터가 있을 경우)
            console.log(`Product View 기간 설정: ${startDate} ~ ${endDate}`);
            showToast(`기간이 적용되었습니다: ${periodText}`, 'success');

            // TODO: 실제 데이터 필터링 로직
            // filterProductDataByDateRange(startDate, endDate);
        }

        // === 날짜 유효성 검사 및 누락 날짜 표시 헬퍼 함수 ===

        // 시작 날짜 ~ 종료 날짜 사이의 모든 날짜 생성
        // UTC 변환 방지: 로컬 시간대 기준으로 날짜 생성
        function getDatesBetween(startDate, endDate) {
            const dates = [];
            // YYYY-MM-DD 문자열 파싱 (UTC 변환 방지)
            const [startY, startM, startD] = startDate.split('-').map(Number);
            const [endY, endM, endD] = endDate.split('-').map(Number);
            const current = new Date(startY, startM - 1, startD);
            const end = new Date(endY, endM - 1, endD);

            while (current <= end) {
                // 로컬 시간대 기준 날짜 문자열 생성
                const y = current.getFullYear();
                const m = String(current.getMonth() + 1).padStart(2, '0');
                const d = String(current.getDate()).padStart(2, '0');
                dates.push(`${y}-${m}-${d}`);
                current.setDate(current.getDate() + 1);
            }

            return dates;
        }

        // 누락된 날짜 찾기
        function findMissingDates(requestedStart, requestedEnd, availableDates) {
            const allRequestedDates = getDatesBetween(requestedStart, requestedEnd);
            const availableSet = new Set(availableDates);

            return allRequestedDates.filter(date => !availableSet.has(date));
        }

        // 누락된 날짜 알림 표시
        function showMissingDatesAlert(elementId, missingDates, totalDays) {
            const alertDiv = document.getElementById(elementId);
            const textSpan = document.getElementById(elementId + '-text');

            if (!alertDiv || !textSpan) return;

            if (missingDates.length === 0) {
                alertDiv.style.display = 'none';
                return;
            }

            // 날짜 포맷팅 (MM-DD)
            const formatDate = (d) => {
                const date = new Date(d);
                return `${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
            };

            let message = '';
            if (missingDates.length === totalDays) {
                message = `선택한 기간(${totalDays}일)에 데이터가 없습니다. 다른 기간을 선택해 주세요.`;
            } else if (missingDates.length <= 5) {
                const formattedDates = missingDates.map(formatDate).join(', ');
                message = `다음 날짜의 데이터가 없습니다: ${formattedDates}`;
            } else {
                const firstThree = missingDates.slice(0, 3).map(formatDate).join(', ');
                message = `${missingDates.length}개 날짜의 데이터가 없습니다: ${firstThree} 외 ${missingDates.length - 3}개`;
            }

            textSpan.textContent = message;
            alertDiv.style.display = 'block';

            // Lucide 아이콘 재렌더링
            if (window.lucide) {
                lucide.createIcons({ nodes: [alertDiv] });
            }
        }

        // 날짜 입력 유효성 검사 (시작일 > 종료일 방지)
        function validateDateInputs(startInputId, endInputId) {
            const startInput = document.getElementById(startInputId);
            const endInput = document.getElementById(endInputId);

            if (!startInput || !endInput) return;

            // 시작일 변경 시 종료일의 min 설정
            startInput.addEventListener('change', function() {
                if (this.value) {
                    endInput.min = this.value;
                    // 종료일이 시작일보다 이전이면 종료일을 시작일로 설정
                    if (endInput.value && endInput.value < this.value) {
                        endInput.value = this.value;
                        showToast('종료일이 시작일로 자동 조정되었습니다.', 'info');
                    }
                }
            });

            // 종료일 변경 시 시작일의 max 설정
            endInput.addEventListener('change', function() {
                if (this.value) {
                    startInput.max = this.value;
                    // 시작일이 종료일보다 이후면 시작일을 종료일로 설정
                    if (startInput.value && startInput.value > this.value) {
                        startInput.value = this.value;
                        showToast('시작일이 종료일로 자동 조정되었습니다.', 'info');
                    }
                }
            });
        }

        // === 경쟁사 비교 분석 테이블 날짜 범위 함수 ===

        // 경쟁사 테이블 날짜 범위 적용
        async function applyCompetitorDateRange() {
            const startDate = document.getElementById('competitorStartDate').value;
            const endDate = document.getElementById('competitorEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            await updateCompetitorTableWithRange(startDate, endDate);
        }

        // 경쟁사 테이블 기간별 데이터 업데이트
        async function updateCompetitorTableWithRange(startDate, endDate) {
            try {
                console.log('[CompetitorTable] Fetching data for:', startDate, '~', endDate);

                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('competitor-table-missing-dates', missingDates, totalRequestedDays);

                // brand_metrics에서 경쟁사 데이터 추출
                const competitors = historicalData?.brand_metrics || [];

                if (competitors.length === 0) {
                    showToast('해당 기간의 경쟁사 데이터가 없습니다.', 'info');
                    return;
                }

                // 기간 배지 업데이트
                updateCompetitorPeriodBadge(startDate, endDate);

                // 테이블 렌더링
                updateCompetitorTable(competitors);

                console.log('[CompetitorTable] Updated with', competitors.length, 'brands');

            } catch (error) {
                console.error('[CompetitorTable] Error:', error);
                showToast('경쟁사 데이터 업데이트 중 오류가 발생했습니다.', 'error');
            }
        }

        // 경쟁사 테이블 기간 배지 업데이트
        function updateCompetitorPeriodBadge(startDate, endDate) {
            const badge = document.getElementById('competitor-period-badge');
            if (!badge) return;

            const start = new Date(startDate);
            const end = new Date(endDate);
            const daysDiff = Math.ceil((end - start) / (1000 * 60 * 60 * 24)) + 1;

            const formatDate = (d) => `${(d.getMonth() + 1).toString().padStart(2, '0')}.${d.getDate().toString().padStart(2, '0')}`;

            if (daysDiff === 7) {
                badge.textContent = `최근 7일 (${formatDate(start)}~${formatDate(end)})`;
            } else if (daysDiff === 14) {
                badge.textContent = `최근 14일 (${formatDate(start)}~${formatDate(end)})`;
            } else if (daysDiff === 30 || daysDiff === 31) {
                badge.textContent = `최근 30일 (${formatDate(start)}~${formatDate(end)})`;
            } else {
                badge.textContent = `${daysDiff}일 (${formatDate(start)}~${formatDate(end)})`;
            }
        }

        // Individual chart date range functions (글로벌 상태 업데이트 포함)
        async function applyRankTrendDateRange() {
            const startDate = document.getElementById('rankTrendStartDate').value;
            const endDate = document.getElementById('rankTrendEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 순위 차트만 독립적으로 업데이트
            await updateRankTrendChart(startDate, endDate);
        }

        async function applyMatrixDateRange() {
            const startDate = document.getElementById('matrixStartDate').value;
            const endDate = document.getElementById('matrixEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 매트릭스 차트만 독립적으로 업데이트
            await updateProductMatrixChart(startDate, endDate);
        }

        async function applyDiscountDateRange() {
            const startDate = document.getElementById('discountStartDate').value;
            const endDate = document.getElementById('discountEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 가격/할인율 차트만 독립적으로 업데이트
            await updateDiscountTrendChartWithRange(startDate, endDate);
        }

        async function applyGrowthTypeDateRange() {
            const startDate = document.getElementById('growthTypeStartDate').value;
            const endDate = document.getElementById('growthTypeEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 성장 유형 차트만 독립적으로 업데이트
            const daysDiff = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24));
            await updateGrowthTypeDataWithRange(startDate, endDate, daysDiff);
        }

        async function applyCompetitorPromoDateRange() {
            const startDate = document.getElementById('competitorPromoStartDate').value;
            const endDate = document.getElementById('competitorPromoEndDate').value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 스켈레톤 로딩 표시
            showCompetitorPromoSkeleton();

            try {
                // 경쟁사 프로모션 차트만 독립적으로 업데이트
                const daysDiff = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24));
                await updateCompetitorPromoDataWithRange(startDate, endDate, daysDiff);
            } finally {
                // 스켈레톤 로딩 숨김
                hideCompetitorPromoSkeleton();
            }
        }

        // Product View 초기화 시 날짜 범위 기본값 설정 (글로벌 날짜 범위 사용)
        function initProductDateRange() {
            const { startDate, endDate } = globalDateRange.get();

            const startInput = document.getElementById('productStartDate');
            const endInput = document.getElementById('productEndDate');

            if (startInput && endInput) {
                startInput.value = startDate;
                endInput.value = endDate;
            }
        }

        // Initialize all chart date ranges (글로벌 날짜 범위 사용)
        function initAllChartDateRanges() {
            const { startDate, endDate } = globalDateRange.get();

            // Rank Trend chart
            const rankStartInput = document.getElementById('rankTrendStartDate');
            const rankEndInput = document.getElementById('rankTrendEndDate');
            if (rankStartInput && rankEndInput) {
                rankStartInput.value = startDate;
                rankEndInput.value = endDate;
            }

            // Matrix chart
            const matrixStartInput = document.getElementById('matrixStartDate');
            const matrixEndInput = document.getElementById('matrixEndDate');
            if (matrixStartInput && matrixEndInput) {
                matrixStartInput.value = startDate;
                matrixEndInput.value = endDate;
            }

            // Discount chart
            const discountStartInput = document.getElementById('discountStartDate');
            const discountEndInput = document.getElementById('discountEndDate');
            if (discountStartInput && discountEndInput) {
                discountStartInput.value = startDate;
                discountEndInput.value = endDate;
            }

            // 제품 선택 드롭다운 변경 시 차트 업데이트
            const discountProductSelect = document.getElementById('discountProductSelect');
            if (discountProductSelect) {
                discountProductSelect.addEventListener('change', () => {
                    applyDiscountDateRange();
                });
            }

            // Growth Type
            const growthStartInput = document.getElementById('growthTypeStartDate');
            const growthEndInput = document.getElementById('growthTypeEndDate');
            if (growthStartInput && growthEndInput) {
                growthStartInput.value = startDate;
                growthEndInput.value = endDate;
            }

            // 성장 유형 제품 선택 드롭다운 변경 시 업데이트
            const growthTypeProductSelect = document.getElementById('growthTypeProductSelect');
            if (growthTypeProductSelect) {
                growthTypeProductSelect.addEventListener('change', () => {
                    applyGrowthTypeDateRange();
                });
            }

            // Competitor Promo
            const compStartInput = document.getElementById('competitorPromoStartDate');
            const compEndInput = document.getElementById('competitorPromoEndDate');
            if (compStartInput && compEndInput) {
                compStartInput.value = startDate;
                compEndInput.value = endDate;
            }

            // 경쟁사 프로모션 제품 선택 드롭다운 변경 시 테이블 업데이트
            const competitorProductSelect = document.getElementById('competitorProductSelect');
            if (competitorProductSelect) {
                competitorProductSelect.addEventListener('change', () => {
                    applyCompetitorPromoDateRange();
                });
            }

            // 경쟁사 비교 분석 테이블 (Brand View)
            const competitorStartInput = document.getElementById('competitorStartDate');
            const competitorEndInput = document.getElementById('competitorEndDate');
            if (competitorStartInput && competitorEndInput) {
                competitorStartInput.value = startDate;
                competitorEndInput.value = endDate;
                // 기간 배지 초기화
                updateCompetitorPeriodBadge(startDate, endDate);
            }

            // 날짜 입력 유효성 검사 초기화 (시작일 > 종료일 방지)
            validateDateInputs('rankTrendStartDate', 'rankTrendEndDate');
            validateDateInputs('matrixStartDate', 'matrixEndDate');
            validateDateInputs('discountStartDate', 'discountEndDate');
            validateDateInputs('growthTypeStartDate', 'growthTypeEndDate');
            validateDateInputs('competitorPromoStartDate', 'competitorPromoEndDate');
            validateDateInputs('competitorStartDate', 'competitorEndDate');
        }

        // 프로모션 데이터 뷰 업데이트
        function updatePromoViews() {
            if (!dashboardData || !dashboardData.charts) return;

            const charts = dashboardData.charts;

            // 성장 유형 분류 업데이트
            if (charts.growth_type_summary) {
                const organic = charts.growth_type_summary.organic || 0;
                const discountBased = charts.growth_type_summary.discount_based || 0;
                document.getElementById('organic-count').textContent = organic + '개';
                document.getElementById('discount-count').textContent = discountBased + '개';
            }

            // 경쟁사 프로모션 비교 테이블 업데이트
            if (charts.competitor_promo && charts.competitor_promo.length > 0) {
                const tbody = document.getElementById('competitor-promo-tbody');
                tbody.innerHTML = '';

                charts.competitor_promo.forEach(comp => {
                    const row = document.createElement('tr');
                    if (comp.is_laneige) row.classList.add('is-laneige');

                    const brandClass = comp.is_laneige ? 'brand-name laneige' : 'brand-name';
                    const discountDisplay = comp.avg_discount > 0 ? comp.avg_discount + '%' : '-';

                    // Add discount badge if significant discount
                    const discountBadge = comp.avg_discount > 15 ?
                        `<span class="discount-badge" style="font-size: 9px; padding: 2px 6px; margin-left: 4px;">🔥</span>` : '';

                    row.innerHTML = `
                        <td class="${brandClass}" title="${comp.brand}">${comp.brand.substring(0, 12)}</td>
                        <td class="num-cell">${comp.product_count}</td>
                        <td class="num-cell discount-cell">${discountDisplay}${discountBadge}</td>
                        <td class="num-cell">${comp.coupon_count}${comp.coupon_count > 0 ? ' 🎟️' : ''}</td>
                        <td class="num-cell">${comp.deal_count}${comp.deal_count > 0 ? ' ⚡' : ''}</td>
                        <td class="num-cell">${comp.sns_count}</td>
                    `;
                    tbody.appendChild(row);
                });
            }

            // 할인율 추이 차트 업데이트
            if (charts.discount_trend && charts.discount_trend.labels) {
                updateDiscountTrendChart(charts.discount_trend);
            }
        }

        // 할인율 추이 차트 업데이트
        function updateDiscountTrendChart(discountData) {
            const ctx = document.getElementById('discountTrendChart');
            if (!ctx) return;

            // 기존 차트 제거
            if (window.discountChart) {
                window.discountChart.destroy();
            }

            // 현재 할인율 배지 업데이트
            const latestDiscount = discountData.data[discountData.data.length - 1] || 0;
            document.getElementById('discount-badge').textContent = `현재 할인율: ${latestDiscount}%`;

            window.discountChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: discountData.labels,
                    datasets: [{
                        label: '평균 할인율',
                        data: discountData.data,
                        borderColor: '#ef4444',
                        backgroundColor: 'rgba(239, 68, 68, 0.1)',
                        fill: true,
                        tension: 0.4,
                        pointBackgroundColor: '#ef4444',
                        pointRadius: 4,
                        pointHoverRadius: 6
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 50,
                            title: {
                                display: true,
                                text: '할인율 (%)'
                            }
                        }
                    }
                }
            });

            // 인사이트 업데이트
            const trend = latestDiscount > discountData.data[0] ? '상승' : latestDiscount < discountData.data[0] ? '하락' : '유지';
            document.getElementById('discount-insight').textContent = `추세: ${trend}`;
        }

        // API 서버 주소 (배포 환경에서는 현재 호스트 사용, 로컬에서는 localhost:8001)
        const API_BASE = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1'
            ? 'http://localhost:8001'
            : window.location.origin;

        // API 인증 키 (환경에 따라 설정)
        const API_KEY = window.DASHBOARD_API_KEY || '';

        // API 요청용 공통 헤더
        function getApiHeaders(contentType = 'application/json') {
            const headers = { 'Content-Type': contentType };
            if (API_KEY) {
                headers['X-API-Key'] = API_KEY;
            }
            return headers;
        }

        // XSS 방지를 위한 HTML 이스케이프 함수
        function escapeHtml(text) {
            if (typeof text !== 'string') return text;
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ============================================
        // 통화 설정 및 환율 관리
        // ============================================
        const CURRENCY_CONFIG = {
            USD: { symbol: '$', name: 'US Dollar', rate: 1.0 },
            KRW: { symbol: '₩', name: 'Korean Won', rate: 1350 },  // Fallback 기본 환율 (참고용)
            JPY: { symbol: '¥', name: 'Japanese Yen', rate: 150 }   // Fallback 기본 환율 (참고용)
        };

        let currentCurrency = 'USD';  // 기본 통화
        let exchangeRates = { USD: 1.0, KRW: 1350, JPY: 150 };  // 캐시된 환율
        let exchangeRatesLastUpdated = null;
        let isUsingFallbackRate = true;  // Fallback 환율 사용 여부

        // 환율 가져오기 (API 호출)
        async function fetchExchangeRates() {
            try {
                // frankfurter.app API 사용 (무료, ECB 기준)
                const response = await fetch('https://api.frankfurter.app/latest?from=USD&to=KRW,JPY');
                if (response.ok) {
                    const data = await response.json();
                    exchangeRates = {
                        USD: 1.0,
                        KRW: data.rates.KRW || 1350,
                        JPY: data.rates.JPY || 150
                    };
                    exchangeRatesLastUpdated = new Date();
                    isUsingFallbackRate = false;
                    console.log('💱 환율 업데이트 (실시간):', exchangeRates);
                    updateExchangeRateDisplay();
                    return true;
                }
            } catch (e) {
                console.warn('환율 API 호출 실패, Fallback 환율 사용:', e);
                isUsingFallbackRate = true;
                updateExchangeRateDisplay();
            }
            return false;
        }

        // 가격 변환 함수 (USD → 선택 통화)
        function convertPrice(usdPrice, targetCurrency = currentCurrency) {
            if (!usdPrice || isNaN(usdPrice)) return null;
            const rate = exchangeRates[targetCurrency] || 1;
            return usdPrice * rate;
        }

        // 가격 포맷팅 함수
        function formatPrice(usdPrice, currency = currentCurrency, options = {}) {
            if (usdPrice === null || usdPrice === undefined || isNaN(usdPrice)) {
                return options.fallback || '-';
            }

            const config = CURRENCY_CONFIG[currency] || CURRENCY_CONFIG.USD;
            const convertedPrice = convertPrice(usdPrice, currency);

            if (currency === 'KRW') {
                // 원화는 소수점 없이 표시
                return `${config.symbol}${Math.round(convertedPrice).toLocaleString()}`;
            } else if (currency === 'JPY') {
                // 엔화도 소수점 없이 표시
                return `${config.symbol}${Math.round(convertedPrice).toLocaleString()}`;
            } else {
                // USD는 소수점 2자리
                return `${config.symbol}${convertedPrice.toFixed(2)}`;
            }
        }

        // 환율 표시 업데이트
        function updateExchangeRateDisplay() {
            const rateEl = document.getElementById('exchangeRateInfo');
            if (rateEl) {
                if (isUsingFallbackRate) {
                    // Fallback 환율 사용 시 - 참고용임을 명시
                    rateEl.innerHTML = `
                        <span class="rate-badge rate-fallback" title="실시간 환율을 가져오지 못해 참고용 기본값을 사용 중입니다. 실제 환율과 다를 수 있습니다.">
                            1 USD ≈ ₩${exchangeRates.KRW.toLocaleString()}
                        </span>
                        <span class="rate-time rate-warning">(참고용 기본값)</span>
                    `;
                } else {
                    // 실시간 환율 - ECB 기준
                    const lastUpdate = exchangeRatesLastUpdated
                        ? exchangeRatesLastUpdated.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' })
                        : '';
                    rateEl.innerHTML = `
                        <span class="rate-badge" title="ECB(유럽중앙은행) 기준 환율">
                            1 USD = ₩${exchangeRates.KRW.toLocaleString()}
                        </span>
                        <span class="rate-time">(ECB ${lastUpdate})</span>
                    `;
                }
            }
        }

        // 통화 변경 시 대시보드 전체 새로고침
        function changeCurrency(newCurrency) {
            if (CURRENCY_CONFIG[newCurrency] && currentCurrency !== newCurrency) {
                currentCurrency = newCurrency;
                localStorage.setItem('dashboardCurrency', newCurrency);
                console.log(`💱 통화 변경: ${newCurrency}`);

                // 모든 가격 표시 업데이트
                refreshAllPriceDisplays();

                // 선택 UI 업데이트
                document.querySelectorAll('.currency-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.currency === newCurrency);
                });
            }
        }

        // 모든 가격 표시 새로고침
        function refreshAllPriceDisplays() {
            // 차트 및 테이블 업데이트가 필요한 경우
            // 현재 활성화된 탭에 따라 다시 렌더링
            const activeTab = document.querySelector('.tab-btn.active');
            if (activeTab) {
                const event = new Event('click');
                activeTab.dispatchEvent(event);
            }
        }

        // 초기화 시 저장된 통화 설정 불러오기
        function initCurrencySettings() {
            const savedCurrency = localStorage.getItem('dashboardCurrency');
            if (savedCurrency && CURRENCY_CONFIG[savedCurrency]) {
                currentCurrency = savedCurrency;
            }
            // 환율 가져오기 (비동기)
            fetchExchangeRates();
        }

        // 서버 연결 상태 관리
        let serverConnected = false;
        let reconnectAttempts = 0;
        const MAX_RECONNECT_ATTEMPTS = 30;

        // 서버 상태 체크 및 자동 재연결
        async function checkServerStatus() {
            try {
                const response = await fetch(`${API_BASE}/`, {
                    method: 'GET',
                    signal: AbortSignal.timeout(2000)
                });
                if (response.ok) {
                    if (!serverConnected) {
                        serverConnected = true;
                        reconnectAttempts = 0;
                        showServerStatus('connected');
                        console.log('✅ 서버 연결됨');
                    }
                    return true;
                }
            } catch (e) {
                if (serverConnected) {
                    serverConnected = false;
                    showServerStatus('disconnected');
                }
            }
            return false;
        }

        // 서버 연결 상태 UI 표시
        function showServerStatus(status) {
            let statusEl = document.getElementById('serverStatus');
            if (!statusEl) {
                statusEl = document.createElement('div');
                statusEl.id = 'serverStatus';
                statusEl.style.cssText = 'position:fixed;top:10px;left:50%;transform:translateX(-50%);padding:8px 16px;border-radius:20px;font-size:12px;font-weight:500;z-index:9999;transition:all 0.3s;display:flex;align-items:center;gap:8px;';
                document.body.appendChild(statusEl);
            }

            // file:// 프로토콜로 열린 경우 서버 URL로 이동 안내
            if (window.location.protocol === 'file:') {
                statusEl.style.background = 'linear-gradient(135deg, #3b82f6, #1d4ed8)';
                statusEl.style.color = 'white';
                statusEl.style.opacity = '1';
                statusEl.style.cursor = 'pointer';
                statusEl.innerHTML = '🔗 서버 대시보드로 이동하기 (클릭)';
                statusEl.onclick = () => { window.location.href = 'http://localhost:8001/dashboard'; };
                return;
            }

            if (status === 'connected') {
                statusEl.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                statusEl.style.color = 'white';
                statusEl.innerHTML = '<span style="width:8px;height:8px;background:#fff;border-radius:50%;animation:pulse 1s infinite;"></span> API 서버 연결됨';
                setTimeout(() => { statusEl.style.opacity = '0'; }, 3000);
            } else if (status === 'disconnected') {
                statusEl.style.background = 'linear-gradient(135deg, #f59e0b, #d97706)';
                statusEl.style.color = 'white';
                statusEl.style.opacity = '1';
                statusEl.innerHTML = '<span style="width:8px;height:8px;background:#fff;border-radius:50%;"></span> 서버 연결 중... (자동 재연결)';
            } else if (status === 'failed') {
                statusEl.style.background = 'linear-gradient(135deg, #ef4444, #dc2626)';
                statusEl.style.color = 'white';
                statusEl.style.opacity = '1';
                statusEl.style.cursor = 'pointer';
                statusEl.innerHTML = '❌ 서버 연결 실패 - 클릭하여 서버 대시보드로 이동';
                statusEl.onclick = () => { window.location.href = 'http://localhost:8001/dashboard'; };
            }
        }

        // 자동 재연결 루프
        async function autoReconnect() {
            if (serverConnected) return;

            reconnectAttempts++;
            const connected = await checkServerStatus();

            if (!connected && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                // 2초마다 재시도
                setTimeout(autoReconnect, 2000);
            } else if (!connected) {
                showServerStatus('failed');
            }
        }

        // 페이지 로드 시 서버 연결 확인 및 초기화
        document.addEventListener('DOMContentLoaded', async () => {
            // 통화 설정 초기화 (가장 먼저)
            initCurrencySettings();

            const connected = await checkServerStatus();
            if (!connected) {
                showServerStatus('disconnected');
                autoReconnect();
            }

            // Product View 날짜 범위 초기화
            initProductDateRange();
            initAllChartDateRanges();
            // Category View 날짜 범위 초기화
            initCategoryDateRange();
            // SoS 추이 차트 날짜 범위 초기화
            initSosTrendDateRange();

            // 글로벌 날짜 범위 변경 이벤트 리스너 등록
            registerGlobalDateRangeListeners();

            // 툴팁 동적 위치 조정 초기화
            initTooltipPositioning();
            initSelectorTooltipPositioning();
        });

        // ===== 툴팁 동적 위치 조정 =====
        function initTooltipPositioning() {
            const statusCards = document.querySelectorAll('.status-card');

            statusCards.forEach(card => {
                const tooltip = card.querySelector('.status-card-tooltip');
                if (!tooltip) return;

                card.addEventListener('mouseenter', () => {
                    adjustTooltipPosition(card, tooltip);
                });
            });

            // 윈도우 리사이즈 시 재계산
            window.addEventListener('resize', () => {
                const visibleTooltips = document.querySelectorAll('.status-card:hover .status-card-tooltip');
                visibleTooltips.forEach(tooltip => {
                    const card = tooltip.closest('.status-card');
                    if (card) adjustTooltipPosition(card, tooltip);
                });
            });
        }

        function adjustTooltipPosition(card, tooltip) {
            const cardRect = card.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            const padding = 16;

            // 인라인 스타일 초기화 (CSS 기본값 사용)
            tooltip.style.left = '';
            tooltip.style.right = '';
            tooltip.style.transform = '';
            tooltip.style.top = '';
            tooltip.style.bottom = '';
            tooltip.style.marginTop = '';
            tooltip.style.marginBottom = '';

            // 기존 정렬 클래스 제거
            tooltip.classList.remove('align-left', 'align-right', 'align-center', 'position-below');

            // 잠시 표시해서 크기 측정
            const originalDisplay = tooltip.style.display;
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '0';
            tooltip.style.display = 'block';
            const tooltipRect = tooltip.getBoundingClientRect();

            // 측정 후 인라인 스타일 제거 (CSS가 hover 상태 제어)
            tooltip.style.display = originalDisplay || '';
            tooltip.style.visibility = '';
            tooltip.style.opacity = '';

            // === 수직 위치 결정 (기본: 아래쪽, 공간 부족 시 위쪽) ===
            const spaceAbove = cardRect.top;
            const spaceBelow = viewportHeight - cardRect.bottom;

            // 아래쪽 공간이 충분하면 아래에 표시 (기본)
            if (spaceBelow >= tooltipRect.height + padding) {
                tooltip.classList.add('position-below');
            } else if (spaceAbove >= tooltipRect.height + padding) {
                // 아래쪽 공간 부족, 위쪽은 충분 → 위쪽에 표시 (기본 CSS)
                // position-below 클래스 없음 = 위쪽 표시
            } else {
                // 양쪽 다 공간 부족 → 더 넓은 쪽 선택
                if (spaceBelow >= spaceAbove) {
                    tooltip.classList.add('position-below');
                }
                // else: 위쪽 (기본 CSS)
            }

            // === 수평 정렬 결정 ===
            const cardCenter = cardRect.left + cardRect.width / 2;
            const tooltipHalfWidth = tooltipRect.width / 2;
            const leftEdge = cardCenter - tooltipHalfWidth;
            const rightEdge = cardCenter + tooltipHalfWidth;

            if (leftEdge < padding) {
                // 왼쪽 넘침 → 왼쪽 정렬
                tooltip.classList.add('align-left');
            } else if (rightEdge > viewportWidth - padding) {
                // 오른쪽 넘침 → 오른쪽 정렬
                tooltip.classList.add('align-right');
            } else {
                // 중앙 정렬 유지
                tooltip.classList.add('align-center');
            }
        }

        // ===== Selector 툴팁 동적 위치 조정 (카테고리/제품 선택) =====
        function initSelectorTooltipPositioning() {
            const selectorWrappers = document.querySelectorAll('.selector-wrapper');

            selectorWrappers.forEach(wrapper => {
                const tooltip = wrapper.querySelector('.selector-tooltip');
                if (!tooltip) return;

                wrapper.addEventListener('mouseenter', () => {
                    adjustSelectorTooltipPosition(wrapper, tooltip);
                });
            });
        }

        function adjustSelectorTooltipPosition(wrapper, tooltip) {
            const wrapperRect = wrapper.getBoundingClientRect();
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const padding = 16;

            // 인라인 스타일 초기화
            tooltip.style.left = '';
            tooltip.style.right = '';
            tooltip.style.top = '';
            tooltip.style.bottom = '';
            tooltip.style.transform = '';

            // 잠시 표시해서 크기 측정
            tooltip.style.visibility = 'hidden';
            tooltip.style.opacity = '0';
            tooltip.style.display = 'block';
            const tooltipRect = tooltip.getBoundingClientRect();
            tooltip.style.display = '';
            tooltip.style.visibility = '';
            tooltip.style.opacity = '';

            // 상단 공간 vs 하단 공간 비교
            const spaceAbove = wrapperRect.top;
            const spaceBelow = viewportHeight - wrapperRect.bottom;

            // 위쪽 공간이 부족하면 아래로 표시
            if (spaceAbove < tooltipRect.height + padding && spaceBelow > spaceAbove) {
                tooltip.style.bottom = 'auto';
                tooltip.style.top = 'calc(100% + 10px)';
                // 화살표 방향 변경
                tooltip.classList.add('position-below');
            } else {
                tooltip.style.top = 'auto';
                tooltip.style.bottom = 'calc(100% + 10px)';
                tooltip.classList.remove('position-below');
            }

            // 좌우 위치 조정 (화면 밖으로 나가면)
            const tooltipLeft = wrapperRect.left + wrapperRect.width / 2 - tooltipRect.width / 2;
            const tooltipRight = tooltipLeft + tooltipRect.width;

            if (tooltipLeft < padding) {
                // 왼쪽으로 넘침 → 왼쪽 정렬
                tooltip.style.left = '0';
                tooltip.style.transform = 'translateX(0)';
            } else if (tooltipRight > viewportWidth - padding) {
                // 오른쪽으로 넘침 → 오른쪽 정렬
                tooltip.style.left = 'auto';
                tooltip.style.right = '0';
                tooltip.style.transform = 'translateX(0)';
            }
        }

        // ===== 글로벌 날짜 범위 변경 이벤트 리스너 등록 =====
        function registerGlobalDateRangeListeners() {
            console.log('[GlobalDateRange] Registering event listeners');

            // dateRangeChanged 이벤트 리스너 - 모든 차트 업데이트
            document.addEventListener('dateRangeChanged', async (e) => {
                const { startDate, endDate } = e.detail;
                console.log('[GlobalDateRange] dateRangeChanged received:', startDate, '~', endDate);

                // 모든 날짜 입력창 동기화
                syncAllDateInputsToGlobal();

                // 현재 페이지에 따라 관련 차트 업데이트
                showToast('날짜 범위가 변경되었습니다. 차트 업데이트 중...', 'info');

                // 차트 로딩 오버레이 표시
                showBrandMatrixLoading();

                try {
                    // 병렬로 모든 차트 업데이트
                    await Promise.allSettled([
                        updateSosTrendWithGlobalRange(startDate, endDate),
                        updateCpiChartWithGlobalRange(startDate, endDate),
                        updateRankTrendWithGlobalRange(startDate, endDate),
                        updateBrandMatrixWithGlobalRange(startDate, endDate),
                        updateDiscountTrendWithGlobalRange(startDate, endDate)
                    ]);

                    showToast(`${startDate} ~ ${endDate} 기간 데이터가 적용되었습니다.`, 'success');
                } catch (error) {
                    console.error('[GlobalDateRange] Error updating charts:', error);
                    showToast('일부 차트 업데이트에 실패했습니다.', 'error');
                } finally {
                    // 차트 로딩 오버레이 숨김
                    hideBrandMatrixLoading();
                }
            });
        }

        // ===== 글로벌 날짜 범위로 각 차트 업데이트 함수들 =====

        // 누락 날짜 계산 유틸리티
        // 타임존 문제를 피하기 위해 로컬 날짜 문자열을 직접 파싱
        function calculateMissingDates(startDate, endDate, existingDates) {
            const missing = [];
            // 날짜 문자열을 YYYY-MM-DD 형식으로 정규화
            const existing = new Set(existingDates.map(d => {
                if (d.includes('T')) {
                    return d.split('T')[0];
                }
                return d;
            }));

            // 타임존 문제를 피하기 위해 날짜 문자열을 직접 조작
            const [startY, startM, startD] = startDate.split('-').map(Number);
            const [endY, endM, endD] = endDate.split('-').map(Number);

            // 로컬 날짜로 생성 (UTC 변환 없이)
            const current = new Date(startY, startM - 1, startD);
            const end = new Date(endY, endM - 1, endD);

            while (current <= end) {
                const y = current.getFullYear();
                const m = String(current.getMonth() + 1).padStart(2, '0');
                const d = String(current.getDate()).padStart(2, '0');
                const dateStr = `${y}-${m}-${d}`;

                if (!existing.has(dateStr)) {
                    missing.push(dateStr);
                }
                current.setDate(current.getDate() + 1);
            }

            console.log('[calculateMissingDates] Start:', startDate, ', End:', endDate);
            console.log('[calculateMissingDates] Existing dates:', [...existing]);
            console.log('[calculateMissingDates] Missing dates:', missing);

            return missing;
        }

        // 누락 날짜 UI 업데이트 유틸리티
        function updateMissingDatesUI(chartId, missingDates) {
            const container = document.getElementById(`${chartId}MissingDates`);
            const textEl = document.getElementById(`${chartId}MissingDatesText`);

            if (!container || !textEl) return;

            if (missingDates.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';

            // 날짜 포맷팅 (MM월 DD일)
            const formatDate = (dateStr) => {
                const d = new Date(dateStr);
                return `${d.getMonth() + 1}월 ${d.getDate()}일`;
            };

            if (missingDates.length <= 5) {
                // 5일 이하: 모든 날짜 나열
                textEl.textContent = `${missingDates.map(formatDate).join(', ')}은(는) 데이터가 없습니다.`;
            } else {
                // 6일 이상: 처음 3개 + 나머지 개수 표시
                const firstThree = missingDates.slice(0, 3).map(formatDate).join(', ');
                const remaining = missingDates.length - 3;
                textEl.textContent = `${firstThree} 외 ${remaining}일은 데이터가 없습니다.`;
            }

            // Lucide 아이콘 다시 렌더링
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // SoS 추이 차트 업데이트 (LANEIGE + 경쟁사 평균)
        async function updateSosTrendWithGlobalRange(startDate, endDate) {
            try {
                // LANEIGE와 경쟁사 평균 데이터 병렬 로드
                const [laneigRes, competitorRes] = await Promise.all([
                    fetch(`/api/sos/trend?start_date=${startDate}&end_date=${endDate}&brand=LANEIGE`),
                    fetch(`/api/sos/trend/competitors-avg?start_date=${startDate}&end_date=${endDate}&top_n=10`)
                ]);

                const laneigResult = await laneigRes.json();
                const competitorResult = await competitorRes.json();

                console.log('[SoS Trend] LANEIGE API response:', laneigResult);
                console.log('[SoS Trend] Competitor Avg API response:', competitorResult);

                if (laneigResult.success && charts.trend) {
                    const trendData = laneigResult.trend || [];
                    const competitorTrendData = competitorResult.success ? (competitorResult.trend || []) : [];

                    // 날짜 범위 전체 생성 (요청된 시작~종료)
                    const allDates = [];
                    const [startY, startM, startD] = startDate.split('-').map(Number);
                    const [endY, endM, endD] = endDate.split('-').map(Number);
                    const current = new Date(startY, startM - 1, startD);
                    const endDateObj = new Date(endY, endM - 1, endD);

                    while (current <= endDateObj) {
                        const y = current.getFullYear();
                        const m = String(current.getMonth() + 1).padStart(2, '0');
                        const d = String(current.getDate()).padStart(2, '0');
                        allDates.push(`${y}-${m}-${d}`);
                        current.setDate(current.getDate() + 1);
                    }

                    // LANEIGE 데이터를 날짜 맵으로 변환
                    const laneigByDate = {};
                    trendData.forEach(d => {
                        laneigByDate[d.date] = d.sos;
                    });

                    // 경쟁사 평균 데이터를 날짜 맵으로 변환
                    const competitorByDate = {};
                    competitorTrendData.forEach(d => {
                        competitorByDate[d.date] = d.avg_sos;
                    });

                    // 누락 날짜 계산 및 UI 업데이트
                    const existingDates = trendData.map(d => d.date);
                    const missingDates = calculateMissingDates(startDate, endDate, existingDates);

                    console.log('[SoS Trend] Date range:', startDate, '~', endDate);
                    console.log('[SoS Trend] All dates in range:', allDates.length);
                    console.log('[SoS Trend] Missing dates:', missingDates);

                    updateMissingDatesUI('sosTrend', missingDates);

                    // 전체 날짜 범위로 X축 라벨 생성 (MM-DD 형식)
                    charts.trend.data.labels = allDates.map(d => {
                        const parts = d.split('-');
                        return `${parts[1]}-${parts[2]}`;
                    });

                    // LANEIGE 데이터 (dataset[0])
                    charts.trend.data.datasets[0].data = allDates.map(d => {
                        return laneigByDate[d] !== undefined ? laneigByDate[d] : null;
                    });
                    charts.trend.data.datasets[0].spanGaps = false;

                    // 경쟁사 평균 데이터 (dataset[1])
                    if (charts.trend.data.datasets[1]) {
                        charts.trend.data.datasets[1].data = allDates.map(d => {
                            return competitorByDate[d] !== undefined ? competitorByDate[d] : null;
                        });
                        charts.trend.data.datasets[1].spanGaps = false;
                    }

                    charts.trend.update('none');
                    console.log('[SoS Trend] Chart updated with LANEIGE and competitor avg data');
                }
            } catch (error) {
                console.error('[GlobalDateRange] Failed to update SoS trend:', error);
            }
        }

        // CPI 차트 업데이트
        async function updateCpiChartWithGlobalRange(startDate, endDate) {
            try {
                // 기존 함수 호출
                if (typeof updateCpiChartWithProducts === 'function') {
                    await updateCpiChartWithProducts(startDate, endDate);
                    console.log('[GlobalDateRange] CPI chart updated');
                }
            } catch (error) {
                console.error('[GlobalDateRange] Failed to update CPI chart:', error);
            }
        }

        // 제품 순위 추이 차트 업데이트
        async function updateRankTrendWithGlobalRange(startDate, endDate) {
            try {
                const days = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)) + 1;
                if (typeof updateProductRankTrendChart === 'function') {
                    await updateProductRankTrendChart(startDate, endDate, days);
                    console.log('[GlobalDateRange] Rank trend chart updated');
                }
            } catch (error) {
                console.error('[GlobalDateRange] Failed to update rank trend:', error);
            }
        }

        // 브랜드 매트릭스 차트 업데이트
        async function updateBrandMatrixWithGlobalRange(startDate, endDate) {
            try {
                const days = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)) + 1;
                let brandCount = 0;
                let dataPoints = 0;

                if (typeof updateProductMatrixChart === 'function') {
                    const result = await updateProductMatrixChart(startDate, endDate, days);
                    // result가 반환되면 브랜드 수와 데이터 포인트 추출
                    if (result) {
                        brandCount = result.brandCount || 0;
                        dataPoints = result.dataPoints || 0;
                    }
                    console.log('[GlobalDateRange] Brand matrix chart updated');
                }

                // 데이터 요약 카드 업데이트
                updateBrandMatrixSummary({
                    startDate,
                    endDate,
                    brandCount,
                    dataPoints
                });
            } catch (error) {
                console.error('[GlobalDateRange] Failed to update brand matrix:', error);
            }
        }

        // 할인율 추이 차트 업데이트
        async function updateDiscountTrendWithGlobalRange(startDate, endDate) {
            try {
                const days = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)) + 1;
                if (typeof updateDiscountTrendChartWithRange === 'function') {
                    await updateDiscountTrendChartWithRange(startDate, endDate, days);
                    console.log('[GlobalDateRange] Discount trend chart updated');
                }
            } catch (error) {
                console.error('[GlobalDateRange] Failed to update discount trend:', error);
            }
        }

        // ===== 글로벌 날짜 범위 적용 버튼 핸들러 =====
        // 이 함수를 개별 차트의 "적용" 버튼에서 호출하면 글로벌 범위도 함께 업데이트됨
        function applyGlobalDateRange(startInputId, endInputId) {
            const startInput = document.getElementById(startInputId);
            const endInput = document.getElementById(endInputId);

            if (!startInput || !endInput) return false;

            const startDate = startInput.value;
            const endDate = endInput.value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return false;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return false;
            }

            // 글로벌 날짜 범위 업데이트 (이벤트 자동 발송됨)
            return globalDateRange.set(startDate, endDate);
        }

        // CSS 애니메이션 추가
        const pulseStyle = document.createElement('style');
        pulseStyle.textContent = '@keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }';
        document.head.appendChild(pulseStyle);

        function toggleChatbot() {
            chatbotOpen = !chatbotOpen;
            document.getElementById('chatbotPanel').classList.toggle('open', chatbotOpen);
            document.getElementById('chatFab').classList.toggle('hidden', chatbotOpen);
            // 태블릿/모바일에서 오버레이 토글
            const overlay = document.querySelector('.chatbot-overlay');
            if (overlay) {
                overlay.classList.toggle('active', chatbotOpen);
            }
            if (chatbotOpen) {
                lucide.createIcons();
            }
        }

        // ===== 모바일 사이드바 토글 =====
        function toggleMobileSidebar() {
            const sidebar = document.getElementById('sidebar');
            const overlay = document.querySelector('.sidebar-overlay');
            sidebar.classList.toggle('open');
            if (overlay) {
                overlay.classList.toggle('active');
            }
        }

        // ===== 추천 질문 접기/펼치기 =====
        function toggleSuggestions() {
            const container = document.getElementById('chatSuggestions');
            container.classList.toggle('collapsed');
        }

        // ===== 챗봇 패널 크기 조절 (드래그) =====
        (function initChatResize() {
            const panel = document.getElementById('chatbotPanel');
            const handle = document.getElementById('chatResizeHandle');
            let isResizing = false;
            let startX, startWidth;

            handle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                panel.classList.add('resizing');
                handle.classList.add('active');
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                // 왼쪽으로 드래그 = 너비 증가
                const diff = startX - e.clientX;
                const newWidth = Math.min(600, Math.max(320, startWidth + diff));
                panel.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    panel.classList.remove('resizing');
                    handle.classList.remove('active');
                    document.body.style.cursor = '';
                }
            });
        })();

        // 챗봇 메시지 전송 - SSE 스트리밍 v3 API 연동
        async function sendChatMessage(msg) {
            const chatBody = document.getElementById('chatBody');

            // 사용자 메시지 표시 (XSS 방지)
            chatBody.innerHTML += `<div class="chat-message user"><div class="bubble">${escapeHtml(msg)}</div></div>`;

            // 응답 버블 생성 (스트리밍용)
            const responseId = 'response-' + Date.now();
            chatBody.innerHTML += `<div class="chat-message bot" id="${responseId}"><div class="bubble"><span class="streaming-text"></span><span class="streaming-cursor">▌</span></div></div>`;
            chatBody.scrollTop = chatBody.scrollHeight;

            const responseEl = document.getElementById(responseId);
            const textEl = responseEl.querySelector('.streaming-text');
            const cursorEl = responseEl.querySelector('.streaming-cursor');

            let fullText = '';
            let toolsUsed = [];
            let suggestions = [];

            try {
                // SSE 스트리밍 API 호출
                const response = await fetch(`${API_BASE}/api/v3/chat/stream`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({ message: msg })
                });

                if (!response.ok) {
                    throw new Error('API 응답 오류');
                }

                const reader = response.body.getReader();
                const decoder = new TextDecoder();

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const chunk = decoder.decode(value, { stream: true });
                    const lines = chunk.split('\n');

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            try {
                                const data = JSON.parse(line.slice(6));

                                if (data.type === 'text') {
                                    // 텍스트 청크 추가
                                    fullText += data.content;
                                    // 마크다운 변환하여 표시
                                    textEl.innerHTML = formatMarkdown(fullText);
                                    chatBody.scrollTop = chatBody.scrollHeight;

                                } else if (data.type === 'tool_call') {
                                    // 도구 호출 표시
                                    toolsUsed.push(data.content.name);
                                    const toolBadge = document.createElement('span');
                                    toolBadge.className = 'tool-badge-streaming';
                                    toolBadge.innerHTML = `🔧 ${data.content.name} 호출 중...`;
                                    toolBadge.style.cssText = 'display:inline-block;background:#fef3c7;color:#92400e;padding:2px 6px;border-radius:4px;font-size:9px;margin-bottom:6px;';
                                    textEl.parentElement.insertBefore(toolBadge, textEl);

                                } else if (data.type === 'done') {
                                    // 완료 - 커서 제거 및 마무리
                                    cursorEl.remove();
                                    suggestions = data.content.suggestions || [];

                                    // 도구 배지 업데이트 (완료 상태로)
                                    const toolBadges = responseEl.querySelectorAll('.tool-badge-streaming');
                                    toolBadges.forEach(badge => {
                                        badge.style.background = '#e0f2fe';
                                        badge.style.color = '#0369a1';
                                        badge.innerHTML = badge.innerHTML.replace('호출 중...', '');
                                    });

                                    // AI 출처 표기 추가
                                    const sourceCitation = renderSourceCitation([]);
                                    textEl.innerHTML += sourceCitation;

                                    // 후속 질문 제안 업데이트
                                    updateSuggestions(suggestions);

                                } else if (data.type === 'error') {
                                    // 오류
                                    cursorEl.remove();
                                    textEl.innerHTML = `<span style="color:#dc2626;">⚠️ ${escapeHtml(data.content)}</span>`;
                                }

                            } catch (parseError) {
                                // JSON 파싱 실패 무시
                            }
                        }
                    }
                }

            } catch (error) {
                console.error('Chat SSE error:', error);

                // 커서 제거
                if (cursorEl) cursorEl.remove();

                // 폴백 응답 (API 연결 실패 시)
                let res = `<strong>💡 안내:</strong><br><br>현재 API 서버에 연결할 수 없습니다.<br><br>`;

                if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                    res += `<span style="color:#f59e0b;">🔄 자동 재연결 시도 중... (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})</span><br><br>`;
                    res += `<button onclick="retryLastMessage('${msg.replace(/'/g, "\\'")}')" style="background:#3b82f6;color:white;border:none;padding:8px 16px;border-radius:8px;cursor:pointer;margin-right:8px;">🔁 재시도</button>`;
                    if (!serverConnected) autoReconnect();
                } else {
                    res += `서버 실행 명령:<br><code>python dashboard_api.py</code><br><br>`;
                    res += `<button onclick="location.reload()" style="background:#10b981;color:white;border:none;padding:8px 16px;border-radius:8px;cursor:pointer;">🔄 페이지 새로고침</button>`;
                }

                textEl.innerHTML = res;
            }

            chatBody.scrollTop = chatBody.scrollHeight;
        }

        // 마크다운 포매팅 헬퍼 (AMOREPACIFIC 인사이트 스타일 지원)
        function formatMarkdown(text) {
            let result = text
                // 섹션 헤더: ▎**제목** → <div class="insight-section-header">제목</div>
                .replace(/▎\*\*(.+?)\*\*/g, '<div class="insight-section-header">$1</div>')
                // Layer 헤더: **Layer N: 제목** → <div class="insight-layer-header">Layer N: 제목</div>
                .replace(/\*\*(Layer\s*\d+:\s*[^*]+)\*\*/g, '<div class="insight-layer-header">$1</div>')
                // 긍정 수치: **+숫자** → <span class="insight-metric-positive">+숫자</span>
                .replace(/\*\*(\+\d+\.?\d*%?p?)\*\*/g, '<span class="insight-metric-positive">$1</span>')
                // 부정 수치: **-숫자** → <span class="insight-metric-negative">-숫자</span>
                .replace(/\*\*(-\d+\.?\d*%?p?)\*\*/g, '<span class="insight-metric-negative">$1</span>')
                // 순위: **#숫자** → <span class="insight-rank">#숫자</span>
                .replace(/\*\*(#\d+)\*\*/g, '<span class="insight-rank">$1</span>')
                // 브랜드명 (한글)
                .replace(/\*\*(라네즈|설화수|이니스프리|에뛰드|코스알엑스|에스트라|헤라|프리메라|아이오페|마몽드|에스쁘아|아모레퍼시픽|티르티르|아누아|조선미녀|스킨1004|미샤|썸바이미|토리든|넘버즈인|메디큐브)\*\*/g,
                    '<span class="insight-brand-name">$1</span>')
                // 일반 볼드
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                // 이탤릭
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                // 코드
                .replace(/`([^`]+)`/g, '<code style="background:#f3f4f6;padding:1px 4px;border-radius:3px;">$1</code>')
                // 최상위 불릿: • → <span class="insight-bullet">•</span>
                .replace(/^• /gm, '<span class="insight-bullet">• </span>')
                // 서브 불릿: - (들여쓰기)
                .replace(/^  - /gm, '<span class="insight-sub-bullet">  - </span>')
                // 줄바꿈
                .replace(/\n/g, '<br>');
            return result;
        }

        // AI 경고 문구 렌더링
        function renderSourceCitation(sources) {
            return `<div class="ai-disclaimer">※ AI가 생성한 분석 결과입니다. 중요한 의사결정 시 추가 검증을 권장합니다.</div>`;
        }

        // 후속 질문 제안 업데이트 (XSS 방지)
        function updateSuggestions(suggestions) {
            const chipsContainer = document.querySelector('.suggestion-chips');
            if (!chipsContainer || !suggestions) return;

            // 기존 칩 제거
            chipsContainer.innerHTML = '';

            // 안전하게 이벤트 리스너 방식으로 추가
            suggestions.forEach(s => {
                const chip = document.createElement('div');
                chip.className = 'suggestion-chip';
                chip.textContent = s;  // textContent 사용으로 XSS 방지
                chip.addEventListener('click', () => sendChatMessage(s));
                chipsContainer.appendChild(chip);
            });
        }

        // 마지막 메시지 재시도
        function retryLastMessage(msg) {
            // 마지막 에러 메시지 제거
            const chatBody = document.getElementById('chatBody');
            const lastBotMsg = chatBody.querySelector('.chat-message.bot:last-child');
            if (lastBotMsg) lastBotMsg.remove();
            // 재전송
            sendChatMessage(msg);
        }

        function sendChatFromInput() { const input = document.getElementById('chatInput'); if (input.value.trim()) { sendChatMessage(input.value); input.value = ''; } }
        function handleChatKeypress(e) { if (e.key === 'Enter') sendChatFromInput(); }
        // AI Strategy Report 데이터 로드 및 렌더링
        async function openAIDrawer() {
            const drawer = document.getElementById('aiDrawer');
            drawer.classList.add('open');

            // 현재 대시보드 데이터로 리포트 업데이트
            updateStrategyReport();
        }

        function closeAIDrawer() {
            document.getElementById('aiDrawer').classList.remove('open');
        }

        // 전략 리포트 업데이트 (대시보드 데이터 기반)
        function updateStrategyReport() {
            if (!dashboardData) return;

            const home = dashboardData.home || {};
            const kpis = home.kpis || {};
            const brand = home.brand || {};
            const trends = home.trends || {};

            // KPI 업데이트
            const sosEl = document.getElementById('kpi-sos');
            const rankEl = document.getElementById('kpi-rank');
            const ratingEl = document.getElementById('kpi-rating');

            const sosValue = parseFloat(kpis.sos) || 0;
            const avgRank = parseInt(kpis.avg_rank) || 50;
            const top10Count = parseInt(kpis.top10_count) || 0;
            const brandRating = parseFloat(brand.rating) || 4.5;

            if (sosEl) {
                sosEl.textContent = sosValue.toFixed(1) + '%';
                sosEl.className = 'insight-kpi-value ' + (sosValue >= 5 ? 'positive' : '');
            }

            if (rankEl) {
                rankEl.textContent = '#' + avgRank;
            }

            if (ratingEl) {
                ratingEl.textContent = brandRating.toFixed(1);
            }

            // Strategy Summary 동적 업데이트 - 근거 기반
            const summaryEl = document.getElementById('strategy-summary-content');
            if (summaryEl) {
                // 경쟁 상황 분석
                const competitorContext = sosValue >= 8 ?
                    '코스알엑스(COSRX) 대비 점유율 우위를 확보' :
                    sosValue >= 5 ?
                    '주요 경쟁사와 점유율 경쟁 중' :
                    '코스알엑스, 티르티르(TIRTIR) 등 경쟁사 대비 점유율 열위';

                // 핵심 지표 기반 상황 설명
                const situation = `
                    <strong>현재 상황:</strong> 라네즈는 Amazon US Lip Care 카테고리에서
                    SoS <strong>${sosValue.toFixed(1)}%</strong> (Top 100 중 ${Math.round(sosValue)}개 제품)를 점유하고 있습니다.
                    ${competitorContext}한 상태입니다.
                    <br><br>
                    <strong>근거:</strong> Best Rank <strong>#${avgRank}</strong>,
                    평균 평점 <strong>${brandRating.toFixed(1)}</strong>점으로
                    ${brandRating >= 4.5 ? '품질 경쟁력은 확보' : '리뷰 관리가 필요'}되어 있으나,
                    ${top10Count >= 3 ? 'Top 10 내 ' + top10Count + '개 제품으로 SKU 다각화 성공' :
                      'Top 10 진입 제품이 ' + top10Count + '개로 SKU 확장이 필요'}합니다.
                `;

                summaryEl.innerHTML = situation;
            }

            // Inference Path 동적 업데이트
            updateInferencePath(kpis, brand);

            // Recommended Actions 동적 업데이트
            updateRecommendedActions(kpis, brand);

            lucide.createIcons();
        }

        // Inference Path 업데이트 - 논리적 인과관계 표시
        function updateInferencePath(kpis, brand) {
            const container = document.getElementById('inference-path-container');
            if (!container) return;

            const sosValue = parseFloat(kpis.sos) || 0;
            const avgRank = parseInt(kpis.avg_rank) || 50;
            const top10Count = parseInt(kpis.top10_count) || 0;

            // 데이터 기반 논리적 분석
            let dataPoint, analysis, conclusion;

            if (sosValue >= 8 && avgRank <= 10) {
                dataPoint = `SoS ${sosValue.toFixed(1)}% (상위)`;
                analysis = `Top 10 제품 ${top10Count}개`;
                conclusion = '점유율 방어 전략';
            } else if (sosValue >= 5) {
                dataPoint = `SoS ${sosValue.toFixed(1)}% (중위)`;
                analysis = `Best Rank #${avgRank}`;
                conclusion = 'SKU 확장 전략';
            } else if (avgRank <= 20) {
                dataPoint = `Best Rank #${avgRank}`;
                analysis = `SoS ${sosValue.toFixed(1)}% (개선 필요)`;
                conclusion = '인지도 강화 전략';
            } else {
                dataPoint = `SoS ${sosValue.toFixed(1)}%`;
                analysis = `평균 순위 #${avgRank}`;
                conclusion = '브랜드 인지도 구축';
            }

            container.innerHTML = `
                <div class="path-node" style="font-size: 11px; padding: 6px 10px;">
                    <strong>데이터</strong><br>${dataPoint}
                </div>
                <span class="path-arrow">→</span>
                <div class="path-node" style="font-size: 11px; padding: 6px 10px;">
                    <strong>분석</strong><br>${analysis}
                </div>
                <span class="path-arrow">→</span>
                <div class="path-node highlight" style="font-size: 11px; padding: 6px 10px;">
                    <strong>전략</strong><br>${conclusion}
                </div>
            `;
        }

        // Recommended Actions 업데이트 - 근거와 기대효과 포함
        function updateRecommendedActions(kpis, brand) {
            const container = document.getElementById('action-list');
            if (!container) return;

            const sosValue = parseFloat(kpis.sos) || 0;
            const avgRank = parseInt(kpis.avg_rank) || 50;
            const top10Count = parseInt(kpis.top10_count) || 0;
            const brandRating = parseFloat(brand.rating) || 4.5;

            const actions = [];

            // SoS 기반 액션 - 근거 포함
            if (sosValue >= 8) {
                actions.push({
                    priority: 'urgent',
                    title: 'Top 3 포지션 방어',
                    reason: `현재 SoS ${sosValue.toFixed(1)}%로 카테고리 상위권`,
                    action: '경쟁사 신제품 출시 및 프로모션 실시간 모니터링',
                    expected: '점유율 하락 리스크 사전 대응'
                });
            } else if (sosValue >= 5) {
                actions.push({
                    priority: 'urgent',
                    title: 'SKU 확장으로 점유율 확대',
                    reason: `SoS ${sosValue.toFixed(1)}%로 성장 여력 존재`,
                    action: 'Lip Sleeping Mask 신규 플레이버(Mango, Vanilla) 출시 검토',
                    expected: 'SKU당 1-2%p 추가 점유율 확보 가능'
                });
            } else {
                actions.push({
                    priority: 'urgent',
                    title: '브랜드 인지도 강화',
                    reason: `SoS ${sosValue.toFixed(1)}%로 경쟁사 대비 열위`,
                    action: 'TikTok/Instagram 인플루언서 협업 확대',
                    expected: '6개월 내 SoS 3%p 이상 개선 목표'
                });
            }

            // Top 10/순위 기반 액션
            if (top10Count < 3) {
                actions.push({
                    priority: 'monitoring',
                    title: 'Water Bank 라인업 순위 개선',
                    reason: `Top 10 제품 ${top10Count}개로 SKU 다각화 부족`,
                    action: '부정 리뷰 키워드 분석 및 제품 개선점 도출',
                    expected: 'Top 10 진입 제품 1개 추가 시 SoS +1%p'
                });
            } else {
                actions.push({
                    priority: 'monitoring',
                    title: '경쟁사 동향 모니터링',
                    reason: `Top 10 내 ${top10Count}개 제품으로 안정적 포지션`,
                    action: 'COSRX, TIRTIR 가격/프로모션 변동 추적',
                    expected: '시장 변화 선제 대응으로 점유율 유지'
                });
            }

            // 평점 기반 액션
            if (brandRating < 4.5) {
                actions.push({
                    priority: 'review',
                    title: '리뷰 품질 관리',
                    reason: `평균 평점 ${brandRating.toFixed(1)}점으로 개선 필요`,
                    action: '부정 리뷰 대응 및 만족 고객 리뷰 유도',
                    expected: '평점 0.2점 상승 시 전환율 5-10% 개선'
                });
            } else {
                actions.push({
                    priority: 'review',
                    title: '번들 프로모션 기획',
                    reason: `평점 ${brandRating.toFixed(1)}점으로 품질 신뢰 확보`,
                    action: 'Lip Mask + Cream Skin 세트 구성',
                    expected: '객단가 15-20% 상승 및 교차 판매 유도'
                });
            }

            // 렌더링 - 근거와 기대효과 포함
            container.innerHTML = actions.map((action, idx) => `
                <div class="action-item" style="padding: 16px;">
                    <div class="action-number">${idx + 1}</div>
                    <div class="action-content">
                        <div class="action-title">
                            <span class="action-tag ${action.priority === 'urgent' ? 'urgent' : ''}">${
                                action.priority === 'urgent' ? '즉시' :
                                action.priority === 'monitoring' ? '모니터링' : '검토'
                            }</span>${action.title}
                        </div>
                        <div class="action-description" style="margin-top: 8px;">
                            <div style="color: var(--text-secondary); font-size: 12px; margin-bottom: 4px;">
                                <strong>근거:</strong> ${action.reason}
                            </div>
                            <div style="color: var(--pacific-blue); font-size: 13px; margin-bottom: 4px;">
                                <strong>액션:</strong> ${action.action}
                            </div>
                            <div style="color: var(--amore-blue); font-size: 12px;">
                                <strong>기대효과:</strong> ${action.expected}
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');
        }

        // AI Strategy Report 복사 기능
        async function copyStrategyReport() {
            const drawerContent = document.querySelector('.drawer-content');
            if (!drawerContent) {
                alert('❌ 복사할 내용이 없습니다.');
                return;
            }

            // 리포트 텍스트 추출
            const sections = drawerContent.querySelectorAll('.insight-section');
            let reportText = '📊 AI Strategy Report - Laneige Amazon US Analysis\n';
            reportText += '=' .repeat(50) + '\n\n';

            sections.forEach(section => {
                const header = section.querySelector('.insight-section-header h4');
                const content = section.querySelector('.insight-box, .inference-path');

                if (header) {
                    reportText += `▶ ${header.textContent}\n`;
                }

                if (content) {
                    // HTML을 텍스트로 변환 (br -> 줄바꿈, 태그 제거)
                    let text = content.innerHTML
                        .replace(/<br\s*\/?>/gi, '\n')
                        .replace(/<strong>(.*?)<\/strong>/gi, '**$1**')
                        .replace(/<em>(.*?)<\/em>/gi, '"$1"')
                        .replace(/<[^>]+>/g, '')
                        .replace(/&nbsp;/g, ' ')
                        .trim();
                    reportText += text + '\n\n';
                }
            });

            reportText += '-'.repeat(50) + '\n';
            reportText += `📅 Generated: ${new Date().toLocaleString('ko-KR')}\n`;
            reportText += '🤖 AMORE INSIGHT AI Intelligence v2.0';

            try {
                await navigator.clipboard.writeText(reportText);

                // 버튼 피드백
                const btn = document.querySelector('.drawer-btn.secondary');
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i data-lucide="check" style="width: 16px; height: 16px;"></i>복사됨!';
                btn.style.background = '#10b981';
                btn.style.color = 'white';

                setTimeout(() => {
                    btn.innerHTML = originalHTML;
                    btn.style.background = '';
                    btn.style.color = '';
                    lucide.createIcons();
                }, 2000);

            } catch (err) {
                // Fallback: 구형 브라우저 지원
                const textArea = document.createElement('textarea');
                textArea.value = reportText;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                alert('✅ 리포트가 클립보드에 복사되었습니다!');
            }
        }

        // AI Strategy Report 공유 기능
        async function shareStrategyReport() {
            const drawerContent = document.querySelector('.drawer-content');
            if (!drawerContent) {
                alert('❌ 공유할 내용이 없습니다.');
                return;
            }

            // 리포트 요약 텍스트 생성
            const summaryBox = drawerContent.querySelector('.insight-box');
            const summary = summaryBox ? summaryBox.textContent.trim() : 'Laneige Amazon US 전략 분석 리포트';

            const reportTitle = 'AMORE INSIGHT - AI Strategy Report';
            const reportDate = new Date().toLocaleDateString('ko-KR');

            // Web Share API 지원 확인
            if (navigator.share) {
                try {
                    await navigator.share({
                        title: reportTitle,
                        text: `📊 ${reportTitle}\n\n${summary}\n\n📅 ${reportDate}`,
                        url: window.location.href
                    });
                } catch (err) {
                    if (err.name !== 'AbortError') {
                        // 사용자가 취소한 게 아니면 이메일 폴백
                        openEmailShare(reportTitle, summary);
                    }
                }
            } else {
                // Web Share API 미지원 시 이메일로 공유
                openEmailShare(reportTitle, summary);
            }
        }

        // 이메일 공유 (폴백)
        function openEmailShare(title, content) {
            const subject = encodeURIComponent(title);
            const body = encodeURIComponent(
                `📊 AI Strategy Report - Laneige Amazon US Analysis\n\n` +
                `${content}\n\n` +
                `-`.repeat(40) + `\n` +
                `📅 생성일: ${new Date().toLocaleString('ko-KR')}\n` +
                `🔗 대시보드: ${window.location.href}\n\n` +
                `🤖 AMORE INSIGHT AI Intelligence v2.0`
            );

            window.open(`mailto:?subject=${subject}&body=${body}`, '_blank');

            // 버튼 피드백
            const btn = document.querySelector('.drawer-btn.primary');
            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<i data-lucide="check" style="width: 16px; height: 16px;"></i>메일 열림!';

            setTimeout(() => {
                btn.innerHTML = originalHTML;
                lucide.createIcons();
            }, 2000);
        }
        function openExportModal() {
            document.getElementById('exportModal').classList.add('open');
            // 글로벌 날짜 범위 사용
            const { startDate, endDate } = globalDateRange.get();
            document.getElementById('exportEndDate').value = endDate;
            document.getElementById('exportStartDate').value = startDate;
        }
        function closeExportModal() { document.getElementById('exportModal').classList.remove('open'); }

        // ============================================================
        // 비동기 내보내기 시스템 (페이지 새로고침에도 다운로드 지속)
        // ============================================================

        // 현재 진행 중인 작업 ID 저장 (localStorage로 페이지 새로고침에도 유지)
        const EXPORT_JOBS_KEY = 'amore_export_jobs';

        function getStoredExportJobs() {
            try {
                return JSON.parse(localStorage.getItem(EXPORT_JOBS_KEY) || '[]');
            } catch { return []; }
        }

        function addStoredExportJob(jobId, format) {
            const jobs = getStoredExportJobs();
            jobs.push({ jobId, format, startedAt: new Date().toISOString() });
            localStorage.setItem(EXPORT_JOBS_KEY, JSON.stringify(jobs));
        }

        function removeStoredExportJob(jobId) {
            const jobs = getStoredExportJobs().filter(j => j.jobId !== jobId);
            localStorage.setItem(EXPORT_JOBS_KEY, JSON.stringify(jobs));
        }

        // 페이지 로드 시 미완료 작업 복구
        async function resumeExportJobs() {
            const jobs = getStoredExportJobs();
            for (const job of jobs) {
                console.log(`Resuming export job: ${job.jobId}`);
                pollExportStatus(job.jobId, job.format === 'excel' ? 'Excel' : 'DOCX 리포트');
            }
        }

        // DOCX/Excel 내보내기 - 비동기 API 연동 (페이지 새로고침에도 지속)
        async function executeExport() {
            // 선택된 형식 확인
            const formatRadio = document.querySelector('input[name="exportFormat"]:checked');
            const format = formatRadio ? formatRadio.value : 'docx';
            const formatLabel = format === 'excel' ? 'Excel' : 'DOCX 리포트';

            // 날짜 값 가져오기
            const startDate = document.getElementById('exportStartDate').value;
            const endDate = document.getElementById('exportEndDate').value;

            // 모달 즉시 닫기
            closeExportModal();

            // 진행 중 토스트 표시
            showExportToast(`📄 ${formatLabel} 작업 시작 중...`, 'progress');

            try {
                // 비동기 작업 시작 요청
                const jobType = format === 'excel' ? 'export_excel' : 'export_analyst_report';

                const response = await fetch(`${API_BASE}/api/export/async/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        job_type: jobType,
                        start_date: startDate || null,
                        end_date: endDate || null,
                        include_charts: true,
                        include_external_signals: true,
                        include_metrics: true
                    })
                });

                if (!response.ok) {
                    const error = await response.text();
                    throw new Error(error || 'Failed to start export job');
                }

                const result = await response.json();
                const jobId = result.job_id;

                // localStorage에 저장 (페이지 새로고침 대비)
                addStoredExportJob(jobId, format);

                // 진행 상태 폴링 시작
                showExportToast(`📄 ${formatLabel} 생성 중... (0%)`, 'progress', jobId);
                pollExportStatus(jobId, formatLabel);

            } catch (error) {
                console.error('Export error:', error);
                showExportToast(`❌ 내보내기 실패: ${error.message}`, 'error');
            }
        }

        // 작업 시작 시간 및 예상 시간 추적
        const exportJobTimings = {};
        const ESTIMATED_TOTAL_SECONDS = 60; // 예상 총 소요 시간 (초)

        // 예상 남은 시간 계산
        function calculateRemainingTime(jobId, progress) {
            if (!exportJobTimings[jobId]) {
                exportJobTimings[jobId] = { startTime: Date.now(), lastProgress: 0 };
            }

            const timing = exportJobTimings[jobId];
            const elapsedSeconds = (Date.now() - timing.startTime) / 1000;

            if (progress <= 0) return ESTIMATED_TOTAL_SECONDS;
            if (progress >= 100) return 0;

            // 진행률 기반 예상 남은 시간 계산
            const estimatedTotal = (elapsedSeconds / progress) * 100;
            const remaining = Math.max(0, estimatedTotal - elapsedSeconds);

            // 최소값과 경험적 보정 적용
            return Math.ceil(Math.min(remaining, ESTIMATED_TOTAL_SECONDS * 2));
        }

        // 시간 포맷팅 (초 → "약 X초" 또는 "약 X분")
        function formatRemainingTime(seconds) {
            if (seconds <= 0) return '거의 완료';
            if (seconds < 60) return `약 ${seconds}초`;
            const minutes = Math.ceil(seconds / 60);
            return `약 ${minutes}분`;
        }

        // 작업 상태 폴링
        async function pollExportStatus(jobId, formatLabel, retryCount = 0) {
            const MAX_RETRIES = 300; // 최대 10분 (2초 × 300)
            const POLL_INTERVAL = 2000; // 2초

            try {
                const response = await fetch(`${API_BASE}/api/export/async/status/${jobId}`);

                if (!response.ok) {
                    throw new Error('Failed to get job status');
                }

                const status = await response.json();

                if (status.status === 'completed') {
                    // 완료! 파일 다운로드
                    delete exportJobTimings[jobId];
                    removeStoredExportJob(jobId);
                    showExportToast(`✅ ${formatLabel} 준비 완료! 다운로드 중...`, 'success');

                    // 자동 다운로드
                    const downloadUrl = `${API_BASE}/api/export/download/${jobId}`;
                    const a = document.createElement('a');
                    a.href = downloadUrl;
                    a.download = '';  // 서버에서 Content-Disposition 헤더로 파일명 지정
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    setTimeout(() => {
                        showExportToast(`✅ ${formatLabel} 다운로드 완료!`, 'success');
                    }, 1000);

                } else if (status.status === 'failed') {
                    // 실패
                    delete exportJobTimings[jobId];
                    removeStoredExportJob(jobId);
                    const errorMsg = status.error_message || 'Unknown error';
                    showExportToast(`❌ ${formatLabel} 생성 실패: ${errorMsg.substring(0, 100)}`, 'error');

                } else if (status.status === 'running' || status.status === 'pending') {
                    // 진행 중 - 진행률 및 예상 시간 업데이트
                    const progress = status.progress || 0;
                    const progressMsg = status.progress_message || '처리 중...';
                    const remainingSeconds = calculateRemainingTime(jobId, progress);
                    const remainingText = formatRemainingTime(remainingSeconds);

                    showExportToast(
                        `📄 ${formatLabel} 생성 중... (${progress}%) - ${progressMsg}`,
                        'progress',
                        jobId,
                        remainingText
                    );

                    // 계속 폴링
                    if (retryCount < MAX_RETRIES) {
                        setTimeout(() => pollExportStatus(jobId, formatLabel, retryCount + 1), POLL_INTERVAL);
                    } else {
                        delete exportJobTimings[jobId];
                        removeStoredExportJob(jobId);
                        showExportToast(`⚠️ ${formatLabel} 생성 시간 초과. 나중에 다시 시도해 주세요.`, 'error');
                    }
                }

            } catch (error) {
                console.error('Poll error:', error);

                // 네트워크 오류 시 재시도
                if (retryCount < 5) {
                    setTimeout(() => pollExportStatus(jobId, formatLabel, retryCount + 1), POLL_INTERVAL * 2);
                } else {
                    delete exportJobTimings[jobId];
                    removeStoredExportJob(jobId);
                    showExportToast(`❌ 상태 확인 실패: ${error.message}`, 'error');
                }
            }
        }

        // 페이지 로드 시 미완료 작업 복구
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(resumeExportJobs, 1000);
        });

        // Export 전용 토스트 (진행 중 상태 지원, jobId로 취소 가능)
        // ARITA 디자인 토스트 - "단아하고 지적이며, 건강한 아름다움"
        function showExportToast(message, type = 'info', jobId = null, remainingTime = null) {
            const existing = document.getElementById('export-toast');

            // 진행률 추출 (메시지에서 "XX%" 패턴 찾기)
            let progressPercent = 0;
            const progressMatch = message.match(/\((\d+)%\)/);
            if (progressMatch) {
                progressPercent = parseInt(progressMatch[1], 10);
            }

            // 기존 progress 토스트가 있고 type도 progress면 내용만 업데이트 (깜빡임 방지)
            if (existing && type === 'progress' && existing.dataset.type === 'progress') {
                const messageSpan = existing.querySelector('div[style*="flex: 1"] > span');
                const progressBar = existing.querySelector('#export-progress-bar');
                const timeSpan = existing.querySelector('#export-remaining-time');
                if (messageSpan) messageSpan.textContent = message;
                if (progressBar) progressBar.style.width = `${progressPercent}%`;
                if (timeSpan && remainingTime) timeSpan.textContent = remainingTime;
                return;
            }

            // 기존 토스트 제거 (type이 다른 경우)
            if (existing) existing.remove();

            const toast = document.createElement('div');
            toast.id = 'export-toast';
            toast.dataset.type = type;

            // ARITA 디자인 시스템: Pacific Blue + Amore Blue 조합
            let bgStyle, iconHtml, borderStyle;
            if (type === 'progress') {
                // 진행 중: Pacific Blue → Amore Blue 그라데이션
                bgStyle = 'background: linear-gradient(135deg, #001C58 0%, #1F5795 100%);';
                borderStyle = 'border-left: 3px solid rgba(255,255,255,0.4);';
                iconHtml = '<div class="export-spinner"></div>';
            } else if (type === 'success') {
                // 성공: Amore Blue 베이스 (부드러운 성공 표현)
                bgStyle = 'background: linear-gradient(135deg, #1F5795 0%, #2d6cb3 100%);';
                borderStyle = 'border-left: 3px solid #7db8f7;';
                iconHtml = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"></polyline></svg>';
            } else if (type === 'error') {
                // 에러: 깊은 레드 (세련된 경고, ARITA 컬러)
                bgStyle = 'background: linear-gradient(135deg, #8B2635 0%, #a33344 100%);';
                borderStyle = 'border-left: 3px solid #f5a5a5;';
                iconHtml = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>';
            } else {
                // 정보: Pacific Blue
                bgStyle = 'background: linear-gradient(135deg, #001C58 0%, #1F5795 100%);';
                borderStyle = 'border-left: 3px solid rgba(255,255,255,0.3);';
                iconHtml = '<svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>';
            }

            toast.style.cssText = `
                position: fixed;
                bottom: 24px;
                right: 24px;
                z-index: 10001;
                padding: 14px 20px;
                padding-bottom: ${type === 'progress' ? '18px' : '14px'};
                border-radius: 8px;
                font-size: 13px;
                font-weight: 500;
                letter-spacing: -0.02em;
                color: white;
                box-shadow: 0 8px 32px rgba(0, 28, 88, 0.3);
                animation: slideInUp 0.35s cubic-bezier(0.16, 1, 0.3, 1);
                display: flex;
                align-items: center;
                gap: 12px;
                font-family: 'Arita Dotum', 'Noto Sans KR', sans-serif;
                min-width: 320px;
                ${bgStyle}
                ${borderStyle}
            `;

            // 진행 중일 때 프로그레스 바 추가
            const progressBarHtml = type === 'progress' ? `
                <div style="
                    position: absolute;
                    bottom: 0;
                    left: 0;
                    width: 100%;
                    height: 4px;
                    background: rgba(255,255,255,0.2);
                    border-radius: 0 0 8px 8px;
                    overflow: hidden;
                ">
                    <div id="export-progress-bar" style="
                        width: ${progressPercent}%;
                        height: 100%;
                        background: linear-gradient(90deg, rgba(255,255,255,0.6), rgba(255,255,255,0.9));
                        transition: width 0.3s ease;
                    "></div>
                </div>
            ` : '';

            // 예상 남은 시간 표시 텍스트
            const remainingTimeHtml = (type === 'progress' && remainingTime)
                ? `<span id="export-remaining-time" style="font-size: 11px; opacity: 0.7; margin-left: 8px;">${remainingTime}</span>`
                : '';

            toast.innerHTML = `
                <span style="display: flex; align-items: center; justify-content: center; opacity: 0.95;">${iconHtml}</span>
                <div style="flex: 1;">
                    <span>${message}</span>${remainingTimeHtml}
                    ${type === 'progress' ? `<div style="font-size: 11px; opacity: 0.8; margin-top: 2px;">잠시만 기다려 주세요...</div>` : ''}
                </div>
                ${progressBarHtml}
            `;

            // 스피너 스타일 추가 (없으면)
            if (!document.getElementById('export-toast-styles')) {
                const style = document.createElement('style');
                style.id = 'export-toast-styles';
                style.textContent = `
                    @keyframes slideInUp {
                        from {
                            opacity: 0;
                            transform: translateY(20px);
                        }
                        to {
                            opacity: 1;
                            transform: translateY(0);
                        }
                    }
                    @keyframes slideOutDown {
                        from {
                            opacity: 1;
                            transform: translateY(0);
                        }
                        to {
                            opacity: 0;
                            transform: translateY(20px);
                        }
                    }
                    @keyframes spin {
                        to { transform: rotate(360deg); }
                    }
                    .export-spinner {
                        width: 18px;
                        height: 18px;
                        border: 2px solid rgba(255,255,255,0.3);
                        border-top-color: white;
                        border-radius: 50%;
                        animation: spin 0.8s linear infinite;
                    }
                `;
                document.head.appendChild(style);
            }

            document.body.appendChild(toast);

            // progress가 아닌 경우 5초 후 자동 제거
            if (type !== 'progress') {
                setTimeout(() => {
                    toast.style.animation = 'slideOutDown 0.3s cubic-bezier(0.16, 1, 0.3, 1) forwards';
                    setTimeout(() => toast.remove(), 300);
                }, 5000);
            }
        }

        // ============== SoS 차트 관련 함수들 ==============

        // SoS 차트 전역 변수
        let sosChartInstance = null;
        let sosBrandsData = [];

        // 날짜 필터 초기화 (글로벌 날짜 범위 사용)
        function initSosDateFilters() {
            let { startDate, endDate } = globalDateRange.get();

            // globalDateRange가 아직 초기화되지 않은 경우 fallback
            if (!startDate || !endDate) {
                console.warn('[initSosDateFilters] globalDateRange not initialized, using fallback');
                // dashboardData에서 가져오기 시도
                if (dashboardData?.charts?.sos_trend?.['30d']?.labels) {
                    const labels = dashboardData.charts.sos_trend['30d'].labels;
                    if (labels.length > 0) {
                        // globalDateRange의 변환 함수 사용
                        startDate = globalDateRange.convertLabelToDate(labels[0]);
                        endDate = globalDateRange.convertLabelToDate(labels[labels.length - 1]);
                    }
                }
                // 그래도 없으면 최근 14일
                if (!startDate || !endDate) {
                    const today = new Date();
                    endDate = today.toISOString().split('T')[0];
                    const start = new Date(today);
                    start.setDate(start.getDate() - 13);
                    startDate = start.toISOString().split('T')[0];
                }
                console.log('[initSosDateFilters] Fallback dates:', startDate, '~', endDate);
            }

            const sosEndInput = document.getElementById('sosEndDate');
            const sosStartInput = document.getElementById('sosStartDate');
            if (sosEndInput && sosStartInput) {
                sosEndInput.value = endDate;
                sosStartInput.value = startDate;
                console.log('[initSosDateFilters] Set dates:', startDate, '~', endDate);
            }
        }

        // 선택된 브랜드 저장
        let selectedCompareBrands = [];

        // 비교 브랜드 드롭다운 로드
        async function loadSosBrands() {
            try {
                const response = await fetch('/api/sos/brands?min_count=2');
                const data = await response.json();

                if (data.success && data.brands) {
                    // LANEIGE 제외 + Unknown 브랜드 제외
                    sosBrandsData = data.brands.filter(b =>
                        !b.is_laneige &&
                        b.name.toLowerCase() !== 'unknown'
                    );
                    renderBrandCheckboxList();
                }
            } catch (error) {
                console.error('Failed to load brands:', error);
            }
        }

        // 브랜드 체크박스 목록 렌더링
        function renderBrandCheckboxList(filter = '') {
            const container = document.getElementById('brandCheckboxList');
            if (!container) return;

            const filtered = sosBrandsData
                .filter(b => !filter || b.name.toLowerCase().includes(filter.toLowerCase()))
                .slice(0, 30);

            container.innerHTML = filtered.map(b => `
                <label style="display: flex; align-items: center; gap: 8px; padding: 6px 4px; cursor: pointer; font-size: 12px; border-radius: 4px; transition: background 0.15s;"
                       onmouseover="this.style.background='var(--bg-subtle)'" onmouseout="this.style.background='transparent'">
                    <input type="checkbox" value="${b.name}" onchange="toggleBrandSelection('${b.name}')"
                           ${selectedCompareBrands.includes(b.name) ? 'checked' : ''}
                           style="margin: 0;">
                    <span>${b.name}</span>
                    <span style="color: var(--text-secondary); margin-left: auto;">${b.product_count}개</span>
                </label>
            `).join('');
        }

        // 브랜드 선택 토글
        function toggleBrandSelection(brandName) {
            const idx = selectedCompareBrands.indexOf(brandName);
            if (idx > -1) {
                selectedCompareBrands.splice(idx, 1);
            } else {
                if (selectedCompareBrands.length < 5) {  // 최대 5개
                    selectedCompareBrands.push(brandName);
                } else {
                    alert('최대 5개까지 선택 가능합니다.');
                    renderBrandCheckboxList(document.getElementById('brandSearchInput')?.value || '');
                    return;
                }
            }
            updateSelectedBrandTags();
            updateBrandDropdownLabel();
        }

        // 선택된 브랜드 태그 업데이트
        function updateSelectedBrandTags() {
            const container = document.getElementById('selectedBrandTags');
            if (!container) return;

            container.innerHTML = selectedCompareBrands.map(brand => `
                <span style="display: inline-flex; align-items: center; gap: 4px; padding: 2px 8px; background: var(--amore-blue); color: white; border-radius: 12px; font-size: 10px;">
                    ${brand.length > 10 ? brand.substring(0, 10) + '...' : brand}
                    <span onclick="removeBrandSelection('${brand}')" style="cursor: pointer; font-weight: bold;">×</span>
                </span>
            `).join('');
        }

        // 브랜드 선택 제거
        function removeBrandSelection(brandName) {
            const idx = selectedCompareBrands.indexOf(brandName);
            if (idx > -1) {
                selectedCompareBrands.splice(idx, 1);
                updateSelectedBrandTags();
                updateBrandDropdownLabel();
                renderBrandCheckboxList(document.getElementById('brandSearchInput')?.value || '');
            }
        }

        // 드롭다운 라벨 업데이트
        function updateBrandDropdownLabel() {
            const label = document.getElementById('brandDropdownLabel');
            if (label) {
                label.textContent = selectedCompareBrands.length > 0
                    ? `${selectedCompareBrands.length}개 선택됨`
                    : '브랜드 선택';
            }
        }

        // 드롭다운 토글
        function toggleBrandDropdown() {
            const menu = document.getElementById('brandDropdownMenu');
            if (menu) {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        // 카테고리 트리 토글 함수
        function toggleCategoryTree(nodeElement) {
            const toggleIcon = nodeElement.querySelector('.category-tree-toggle');
            const parentItem = nodeElement.closest('.category-tree-item');
            const childrenContainer = parentItem.querySelector('.category-tree-children');

            if (childrenContainer) {
                const isExpanded = childrenContainer.classList.contains('expanded');
                childrenContainer.classList.toggle('expanded');
                toggleIcon.classList.toggle('expanded');
            }
        }

        // 브랜드 목록 필터링
        function filterBrandList() {
            const input = document.getElementById('brandSearchInput');
            renderBrandCheckboxList(input?.value || '');
        }

        // 드롭다운 외부 클릭 시 닫기
        document.addEventListener('click', function(e) {
            const container = document.querySelector('.brand-dropdown-container');
            const menu = document.getElementById('brandDropdownMenu');
            if (container && menu && !container.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // SoS 차트 툴팁은 인라인 이벤트 핸들러로 처리 (sosChartHelpIcon span의 onmouseenter/onmouseleave)

        // SoS 막대그래프 초기화
        function initSosBarChart(colors, chartColors, brandColors) {
            // 초기 차트 생성 (빈 데이터)
            const ctx = document.getElementById('sosChart').getContext('2d');

            sosChartInstance = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [],
                    datasets: []
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    indexAxis: 'y',  // 수평 막대그래프
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: { font: { size: 11 }, padding: 10, usePointStyle: true }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(1)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            beginAtZero: true,
                            min: 0,
                            max: 15,  // 동적으로 업데이트됨
                            ticks: {
                                stepSize: 2.5,
                                callback: function(value) { return value + '%'; }
                            },
                            title: { display: true, text: '시장점유율 (%)', font: { size: 11 } },
                            grid: { color: 'rgba(0, 28, 88, 0.06)' }
                        },
                        y: {
                            grid: { display: false }
                        }
                    }
                },
                plugins: [{
                    // 막대 끝에 값 표시
                    afterDatasetsDraw: function(chart) {
                        const ctx = chart.ctx;
                        chart.data.datasets.forEach((dataset, i) => {
                            if (dataset.type === 'line') return;  // 라인 차트는 제외
                            const meta = chart.getDatasetMeta(i);
                            meta.data.forEach((bar, index) => {
                                const value = dataset.data[index];
                                if (value > 0) {
                                    ctx.fillStyle = '#333';
                                    ctx.font = '10px Arial';
                                    ctx.textAlign = 'left';
                                    ctx.textBaseline = 'middle';
                                    ctx.fillText(value.toFixed(1) + '%', bar.x + 4, bar.y);
                                }
                            });
                        });
                    }
                }]
            });

            // 초기 데이터 로드
            updateSosChart();
        }

        // SoS 차트 업데이트 (API 호출)
        async function updateSosChart() {
            const startDate = document.getElementById('sosStartDate').value;
            const endDate = document.getElementById('sosEndDate').value;
            const selectedBrands = selectedCompareBrands.join(',');

            const noDataMsg = document.getElementById('sosNoDataMessage');
            const chartCanvas = document.getElementById('sosChart');

            try {
                let url = `/api/sos/category?start_date=${startDate}&end_date=${endDate}`;
                if (selectedBrands) {
                    url += `&compare_brands=${encodeURIComponent(selectedBrands)}`;
                }

                const response = await fetch(url);
                const result = await response.json();

                if (!result.success || !result.data || result.data.length === 0) {
                    // 데이터 없음 표시
                    chartCanvas.style.display = 'none';
                    noDataMsg.style.display = 'block';
                    return;
                }

                chartCanvas.style.display = 'block';
                noDataMsg.style.display = 'none';

                // 카테고리 라벨 (꺽쇠 없이 깔끔하게)
                const labels = result.data.map(d => d.category_name);

                // LANEIGE 데이터
                const laneigeSos = result.data.map(d => d.laneige_sos);

                // 평균 SoS 데이터
                const avgSos = result.data.map(d => d.avg_sos);

                // 데이터셋 구성
                const datasets = [
                    {
                        label: 'LANEIGE',
                        data: laneigeSos,
                        backgroundColor: '#1F5795',
                        borderColor: '#1F5795',
                        borderWidth: 1,
                        barPercentage: 0.6
                    },
                    {
                        label: '평균 (Top 100)',
                        data: avgSos,
                        backgroundColor: 'rgba(125, 125, 125, 0.3)',
                        borderColor: '#7D7D7D',
                        borderWidth: 1,
                        borderDash: [5, 5],
                        type: 'line',
                        fill: false,
                        pointRadius: 0
                    }
                ];

                // 비교 브랜드 추가
                const compareBrandColors = ['#C4A962', '#4A7DB8', '#FF6B6B', '#4ECDC4', '#45B7D1'];
                if (result.compare_brands && result.compare_brands.length > 0) {
                    result.compare_brands.forEach((brand, idx) => {
                        const brandSos = result.data.map(d => d.compare_brands[brand] || 0);
                        datasets.push({
                            label: brand,
                            data: brandSos,
                            backgroundColor: compareBrandColors[idx % compareBrandColors.length],
                            borderColor: compareBrandColors[idx % compareBrandColors.length],
                            borderWidth: 1,
                            barPercentage: 0.6
                        });
                    });
                }

                // X축 최대값 동적 계산 (데이터 기반)
                const allValues = [...laneigeSos, ...avgSos];
                if (result.compare_brands && result.compare_brands.length > 0) {
                    result.compare_brands.forEach(brand => {
                        const brandSos = result.data.map(d => d.compare_brands[brand] || 0);
                        allValues.push(...brandSos);
                    });
                }
                const maxValue = Math.max(...allValues, 1);  // 최소 1%
                // 최대값을 5% 단위로 올림 (여유 공간 포함)
                const xMax = Math.ceil((maxValue * 1.3) / 5) * 5;  // 30% 여유 + 5% 단위 올림
                const adjustedMax = Math.max(xMax, 10);  // 최소 10%

                // 차트 업데이트
                sosChartInstance.data.labels = labels;
                sosChartInstance.data.datasets = datasets;
                sosChartInstance.options.scales.x.max = adjustedMax;
                sosChartInstance.options.scales.x.ticks.stepSize = adjustedMax / 5;  // 5등분

                sosChartInstance.update();

                // 카테고리별 상세 정보 표시 (계층적 트리 구조)
                const detailContent = document.getElementById('sosCategoryDetailContent');
                if (detailContent) {
                    // API 데이터를 카테고리별로 매핑
                    const categoryDataMap = {};
                    result.data.forEach(d => {
                        categoryDataMap[d.category_id] = d;
                    });

                    // 카테고리 계층 구조 정의 (category_hierarchy.json 기반)
                    const categoryHierarchy = {
                        beauty: {
                            name: 'Beauty & Personal Care',
                            level: 0,
                            children: ['skin_care', 'makeup']
                        },
                        skin_care: {
                            name: 'Skin Care',
                            level: 1,
                            parent: 'beauty',
                            children: ['lip_care']
                        },
                        lip_care: {
                            name: 'Lip Care',
                            level: 2,
                            parent: 'skin_care',
                            children: []
                        },
                        makeup: {
                            name: 'Makeup',
                            level: 1,
                            parent: 'beauty',
                            children: ['lip_makeup', 'face_makeup'],
                            isIntermediate: true  // 모니터링 안 함
                        },
                        lip_makeup: {
                            name: 'Lip Makeup',
                            level: 2,
                            parent: 'makeup',
                            children: []
                        },
                        face_makeup: {
                            name: 'Face Makeup',
                            level: 2,
                            parent: 'makeup',
                            children: ['face_powder'],
                            isIntermediate: true  // 모니터링 안 함
                        },
                        face_powder: {
                            name: 'Face Powder',
                            level: 3,
                            parent: 'face_makeup',
                            children: []
                        }
                    };

                    // 계층적 트리 렌더링 함수
                    function renderCategoryTree(categoryId, expanded = true) {
                        const cat = categoryHierarchy[categoryId];
                        if (!cat) return '';

                        const data = categoryDataMap[categoryId];
                        const hasLaneige = data && (data.laneige_count > 0 || data.laneige_sos > 0);
                        const hasChildren = cat.children && cat.children.length > 0;
                        const isIntermediate = cat.isIntermediate;

                        // 노드 클래스 결정
                        let nodeClass = 'category-tree-node';
                        if (isIntermediate) {
                            nodeClass += ' intermediate';
                        } else if (hasLaneige) {
                            nodeClass += ' has-laneige';
                        } else {
                            nodeClass += ' no-laneige';
                        }

                        // 통계 정보
                        let statsHtml = '';
                        if (data && !isIntermediate) {
                            // 제품 수 표시 (소수점, 일 평균)
                            const countText = data.laneige_count > 0
                                ? `평균 ${data.laneige_count}개`
                                : '미출현';
                            // 출현율 표시
                            const appearanceText = data.laneige_appearance_rate !== undefined && data.laneige_appearance_rate > 0
                                ? `${data.laneige_appearance_rate}% 출현`
                                : '';
                            // 출현 일수 텍스트 (툴팁용)
                            const appearanceDaysText = data.laneige_appearance_days !== undefined && data.num_dates
                                ? `${data.laneige_appearance_days}/${data.num_dates}일`
                                : '';

                            statsHtml = `
                                <div class="category-tree-stats">
                                    <div class="category-tree-sos">${data.laneige_sos.toFixed(1)}%</div>
                                    <div class="category-tree-count" title="${appearanceDaysText ? appearanceDaysText + ' Top 100 진입' : ''}">${countText}${appearanceText ? ' | ' + appearanceText : ''}</div>
                                </div>
                            `;
                        } else if (isIntermediate) {
                            statsHtml = '<div class="category-tree-stats" style="font-size: 10px; color: #999;">모니터링 안 함</div>';
                        }

                        // 자식 노드 렌더링
                        let childrenHtml = '';
                        if (hasChildren) {
                            const childNodes = cat.children.map(childId => renderCategoryTree(childId, false)).join('');
                            childrenHtml = `<div class="category-tree-children ${expanded ? 'expanded' : ''}">${childNodes}</div>`;
                        }

                        // 토글 아이콘
                        const toggleClass = hasChildren ? (expanded ? 'expanded' : '') : 'empty';
                        const toggleIcon = hasChildren ? '▶' : '';

                        return `
                            <div class="category-tree-item">
                                <div class="${nodeClass}" onclick="toggleCategoryTree(this)" data-category="${categoryId}">
                                    <div class="category-tree-toggle ${toggleClass}">${toggleIcon}</div>
                                    <div class="category-tree-content">
                                        <div>
                                            <span class="category-tree-name">${cat.name}</span>
                                            <span class="category-tree-level">L${cat.level}</span>
                                        </div>
                                        ${statsHtml}
                                    </div>
                                </div>
                                ${childrenHtml}
                            </div>
                        `;
                    }

                    // 루트(Beauty & Personal Care)부터 시작하여 트리 렌더링
                    detailContent.innerHTML = renderCategoryTree('beauty', true);

                    // Lucide 아이콘 새로고침
                    if (typeof lucide !== 'undefined') {
                        lucide.createIcons();
                    }
                }

            } catch (error) {
                console.error('SoS chart update error:', error);
                chartCanvas.style.display = 'none';
                noDataMsg.style.display = 'block';
            }
        }

        // ============== END SoS 차트 관련 함수들 ==============

        function initChartsForPage(pageId) {
            Object.values(charts).forEach(c => c.destroy()); charts = {};
            // SoS Bar Chart는 별도 인스턴스로 관리됨
            if (sosChartInstance) {
                sosChartInstance.destroy();
                sosChartInstance = null;
            }
            // AMOREPACIFIC CI Colors - Harmony of Contrast
            const colors = {
                laneige: '#1F5795',      // Amore Blue - 부드러움
                pacific: '#001C58',       // Pacific Blue - 강함
                competitor: '#7D7D7D',    // AP Gray
                others: '#D0D0D0',
                grid: 'rgba(0, 28, 88, 0.06)',
                warning: '#C4A962'        // Gold accent
            };
            // 차트 색상 - Amore Blue 기반 그라데이션
            const chartColors = ['#001C58', '#1F5795', '#4A7DB8', '#7DA3CC', '#B0C9E0'];
            // 브랜드 비교 색상 - Pacific Blue, Gray 톤
            const brandColors = ['#1F5795', '#001C58', '#7D7D7D', '#4A7DB8', '#A0A0A0', '#2E4A6E', '#5C5C5C', '#3D6B99', '#8B8B8B', '#1A3D66'];

            if (pageId === 'home') {
                // SoS 날짜 필터 먼저 초기화 (updateSosChart가 날짜 값을 필요로 함)
                initSosDateFilters();
                // SoS 막대그래프 초기화 - API 연동 (내부에서 updateSosChart 호출)
                initSosBarChart(colors, chartColors, brandColors);
                loadSosBrands();  // 비교 브랜드 드롭다운 로드

                // SoS 트렌드 차트 - JSON 데이터 사용
                // 동적 fallback 날짜 생성
                window.generateRecentDates = (days = 7) => {
                    const dates = [];
                    for (let i = days - 1; i >= 0; i--) {
                        const d = new Date();
                        d.setDate(d.getDate() - i);
                        dates.push((d.getMonth() + 1).toString().padStart(2, '0') + '/' + d.getDate().toString().padStart(2, '0'));
                    }
                    return dates;
                };

                // SoS 트렌드 데이터 가져오기 (기간별)
                window.getSosTrendData = (days) => {
                    const fallbackLabels = generateRecentDates(days);
                    const fallbackData = new Array(days).fill(0);

                    // 기간별 데이터 키 확인 (7d, 14d, 30d)
                    const periodKey = days + 'd';
                    if (dashboardData?.charts?.sos_trend?.[periodKey]) {
                        return {
                            labels: dashboardData.charts.sos_trend[periodKey].labels || fallbackLabels,
                            data: dashboardData.charts.sos_trend[periodKey].data || fallbackData
                        };
                    }

                    // 레거시 형식 지원 (단일 데이터)
                    if (dashboardData?.charts?.sos_trend?.labels) {
                        const rawLabels = dashboardData.charts.sos_trend.labels;
                        const rawData = dashboardData.charts.sos_trend.data;

                        // 데이터가 요청 기간보다 적으면 fallback 날짜로 채움
                        if (rawLabels.length < days) {
                            // 기존 데이터를 날짜 맵으로 변환
                            const dataMap = {};
                            rawLabels.forEach((label, idx) => {
                                dataMap[label] = rawData[idx];
                            });

                            // fallback 날짜에 매칭
                            const mergedData = fallbackLabels.map(label => {
                                // MM/DD 형식으로 변환하여 매칭
                                const mmdd = label.replace('/', '-');
                                return dataMap[mmdd] || dataMap[label] || 0;
                            });

                            return { labels: fallbackLabels, data: mergedData };
                        }

                        // 최근 N일만 추출
                        return {
                            labels: rawLabels.slice(-days),
                            data: rawData.slice(-days)
                        };
                    }

                    return { labels: fallbackLabels, data: fallbackData };
                };

                // 초기 7일 데이터로 차트 생성
                const initialData = getSosTrendData(7);

                charts.trend = new Chart(document.getElementById('trendChart').getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: initialData.labels,
                        datasets: [
                            {
                                label: 'LANEIGE',
                                data: initialData.data,
                                borderColor: colors.laneige,
                                backgroundColor: 'rgba(31, 87, 149, 0.1)',
                                tension: 0.4,
                                fill: true,
                                borderWidth: 3,
                                pointRadius: 4,
                                pointBackgroundColor: colors.laneige,
                                pointBorderColor: '#fff',
                                pointBorderWidth: 2,
                                pointHoverRadius: 6,
                                spanGaps: false,
                                order: 1  // LANEIGE가 위에 표시
                            },
                            {
                                label: '경쟁사 평균 (Top 10)',
                                data: [],  // API에서 로드
                                borderColor: '#7D7D7D',
                                backgroundColor: 'rgba(125, 125, 125, 0.05)',
                                tension: 0.4,
                                fill: true,
                                borderWidth: 2,
                                borderDash: [5, 5],  // 점선
                                pointRadius: 3,
                                pointBackgroundColor: '#7D7D7D',
                                pointBorderColor: '#fff',
                                pointBorderWidth: 1,
                                pointHoverRadius: 5,
                                spanGaps: false,
                                order: 2  // 경쟁사가 아래에 표시
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                align: 'end',
                                labels: {
                                    boxWidth: 12,
                                    boxHeight: 12,
                                    padding: 16,
                                    font: {
                                        family: "'Arita Dotum', 'Noto Sans KR', sans-serif",
                                        size: 11
                                    },
                                    usePointStyle: true,
                                    pointStyle: 'circle'
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: (ctx) => `${ctx.dataset.label}: ${ctx.parsed.y?.toFixed(2) ?? '-'}%`
                                }
                            }
                        },
                        scales: {
                            y: {
                                grid: { color: colors.grid },
                                ticks: {
                                    callback: (value) => value + '%'
                                },
                                beginAtZero: true
                            },
                            x: {
                                grid: { display: false },
                                ticks: {
                                    maxRotation: 45,
                                    minRotation: 0,
                                    autoSkip: false,
                                    callback: function(value, tickIndex, ticks) {
                                        const labels = this.chart.data.labels;
                                        const total = labels.length;

                                        // value는 labels 배열의 인덱스
                                        const labelIndex = value;
                                        const label = labels[labelIndex];

                                        if (!label) return null;

                                        // 7일 이하: 모든 날짜 표시
                                        if (total <= 7) {
                                            return label;
                                        }

                                        // 8~14일: 2일 간격으로 표시 (첫날, 마지막날은 항상)
                                        if (total <= 14) {
                                            if (labelIndex === 0 || labelIndex === total - 1) {
                                                return label;
                                            }
                                            return labelIndex % 2 === 0 ? label : null;
                                        }

                                        // 15~21일: 3일 간격
                                        if (total <= 21) {
                                            if (labelIndex === 0 || labelIndex === total - 1) {
                                                return label;
                                            }
                                            return labelIndex % 3 === 0 ? label : null;
                                        }

                                        // 22일 이상: 균등 간격으로 최대 10개 표시
                                        const maxLabels = 10;
                                        if (labelIndex === 0 || labelIndex === total - 1) {
                                            return label;
                                        }
                                        const step = Math.ceil(total / (maxLabels - 1));
                                        if (labelIndex % step === 0) {
                                            return label;
                                        }

                                        return null;
                                    }
                                }
                            }
                        }
                    }
                });

                // [FIX] Home 복귀 시 API에서 최신 SoS Trend 데이터 로드
                // 다른 차트들(SoS 막대그래프, Product 차트)과 동일한 패턴 적용
                const { startDate, endDate } = globalDateRange.get();
                if (startDate && endDate) {
                    updateSosTrendWithGlobalRange(startDate, endDate).catch(err => {
                        console.error('[initChartsForPage] Failed to load SoS trend data:', err);
                    });
                }
            }

            if (pageId === 'brand') {
                // 브랜드 매트릭스 버블 차트 - API 데이터만 사용 (하드코딩 fallback 제거)
                let brandDatasets = [];

                if (dashboardData?.charts?.brand_matrix && dashboardData.charts.brand_matrix.length > 0) {
                    brandDatasets = dashboardData.charts.brand_matrix.map((brand, idx) => ({
                        label: brand.brand,
                        data: [{ x: brand.sos, y: brand.avg_rank, r: Math.min(Math.max(brand.bubble_size, 6), 12) }],
                        backgroundColor: brand.is_laneige
                            ? 'rgba(0, 28, 88, 0.75)'  // Pacific Blue 75% 투명도
                            : brandColors[idx % brandColors.length].replace(')', ', 0.65)').replace('rgb', 'rgba'),
                        borderColor: brand.is_laneige ? '#001C58' : 'rgba(255,255,255,0.9)',
                        borderWidth: brand.is_laneige ? 3 : 2
                    }));
                }

                // 동적 축 범위 계산 (데이터 분포에 맞게 + 10% 여유)
                const allSoS = brandDatasets.flatMap(d => d.data.map(p => p.x));
                const allRanks = brandDatasets.flatMap(d => d.data.map(p => p.y));

                // 데이터가 없을 때 기본값 사용
                const sosMin = allSoS.length > 0 ? Math.max(0, Math.min(...allSoS) - 2) : 0;
                const sosMax = allSoS.length > 0 ? Math.min(100, Math.max(...allSoS) * 1.3) : 50;
                const rankMin = allRanks.length > 0 ? Math.max(1, Math.min(...allRanks) - 5) : 1;
                const rankMax = allRanks.length > 0 ? Math.min(100, Math.max(...allRanks) + 10) : 100;

                // stepSize 계산 (범위에 맞게)
                const sosRange = sosMax - sosMin;
                const sosStep = sosRange <= 20 ? 2 : sosRange <= 50 ? 5 : 10;
                const rankRange = rankMax - rankMin;
                const rankStep = rankRange <= 30 ? 5 : 10;

                charts.brandMatrix = new Chart(document.getElementById('brandMatrixChart').getContext('2d'), {
                    type: 'bubble',
                    data: { datasets: brandDatasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        layout: {
                            padding: { top: 20, right: 30, bottom: 20, left: 20 }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    font: { size: 11 },
                                    usePointStyle: true,
                                    pointStyle: 'circle',
                                    padding: 12
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const data = context.raw;
                                        return `${context.dataset.label}: 점유율 ${data.x.toFixed(1)}%, 순위 ${data.y.toFixed(1)}위`;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                reverse: true,
                                title: { display: true, text: '평균순위', font: { weight: 'bold' } },
                                grid: { color: colors.grid },
                                min: Math.floor(rankMin),
                                max: Math.ceil(rankMax),
                                ticks: {
                                    stepSize: rankStep,
                                    callback: function(value) {
                                        return Number.isInteger(value) ? value + '위' : '';
                                    }
                                }
                            },
                            x: {
                                title: { display: true, text: '시장점유율 (%)', font: { weight: 'bold' } },
                                grid: { color: colors.grid },
                                min: Math.floor(sosMin),
                                max: Math.ceil(sosMax),
                                ticks: {
                                    stepSize: sosStep,
                                    callback: function(value) {
                                        return Number.isInteger(value) ? value + '%' : '';
                                    }
                                }
                            }
                        },
                        elements: {
                            point: {
                                hoverRadius: 10
                            }
                        }
                    }
                });
            }

            if (pageId === 'category') {
                // CPI 추이 차트 - JSON 데이터 사용
                // 동적 fallback 날짜 생성 (최근 7일)
                const generateRecentDatesForCPI = (days = 7) => {
                    const dates = [];
                    for (let i = days - 1; i >= 0; i--) {
                        const d = new Date();
                        d.setDate(d.getDate() - i);
                        dates.push((d.getMonth() + 1).toString().padStart(2, '0') + '/' + d.getDate().toString().padStart(2, '0'));
                    }
                    return dates;
                };
                let cpiLabels = generateRecentDatesForCPI(7);
                let cpiData = [100, 100, 100, 100, 100, 100, 100]; // 기준선 100으로 초기화

                if (dashboardData?.charts?.cpi_trend) {
                    cpiLabels = dashboardData.charts.cpi_trend.labels || cpiLabels;
                    cpiData = dashboardData.charts.cpi_trend.data || cpiData;
                }

                // 기준선 데이터 생성
                const baselineData = cpiLabels.map(() => 100);

                charts.cpi = new Chart(document.getElementById('cpiChart').getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: cpiLabels,
                        datasets: [
                            {
                                label: 'Laneige 가격경쟁지수',
                                data: cpiData,
                                borderColor: colors.laneige,
                                backgroundColor: 'rgba(32,128,128,0.1)',
                                tension: 0.4,
                                fill: true,
                                borderWidth: 3
                            },
                            {
                                label: '기준선 (100)',
                                data: baselineData,
                                borderColor: '#94a3b8',
                                borderDash: [5, 5],
                                borderWidth: 2,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { position: 'top', labels: { font: { size: 11 } } } },
                        scales: { y: { min: 90, max: 250, grid: { color: colors.grid } }, x: { grid: { display: false } } }
                    }
                });

                // [FIX] Category 페이지 진입/복귀 시 API에서 최신 CPI 데이터 로드
                // 최근 7일 고정, LANEIGE 브랜드 평균 vs 경쟁사 Top 100 평균 비교
                updateCpiChartWithBrandAverage().catch(err => {
                    console.error('[initChartsForPage] Failed to load CPI data:', err);
                });
            }

            if (pageId === 'product') {
                // 제품 순위 추이 차트 - JSON 데이터 사용
                // 동적 fallback 날짜 생성 (최근 7일)
                const generateRecentDatesForRank = (days = 7) => {
                    const dates = [];
                    for (let i = days - 1; i >= 0; i--) {
                        const d = new Date();
                        d.setDate(d.getDate() - i);
                        dates.push((d.getMonth() + 1).toString().padStart(2, '0') + '/' + d.getDate().toString().padStart(2, '0'));
                    }
                    return dates;
                };
                let rankLabels = generateRecentDatesForRank(7);
                let rankDatasets = [
                    { label: '데이터 로딩 중...', data: rankLabels.map(() => null), borderColor: colors.laneige, backgroundColor: 'rgba(32,128,128,0.1)', tension: 0.4, fill: true, borderWidth: 3 }
                ];

                let rankYMax = 20; // 기본값
                if (dashboardData?.charts?.product_rank_trend) {
                    const prt = dashboardData.charts.product_rank_trend;
                    rankLabels = prt.labels || rankLabels;

                    if (prt.products && Object.keys(prt.products).length > 0) {
                        // 모든 순위 데이터에서 최대값 계산
                        const allRanks = Object.values(prt.products)
                            .flatMap(p => p.ranks)
                            .filter(r => r !== null && r !== undefined);
                        if (allRanks.length > 0) {
                            rankYMax = Math.max(...allRanks, 20) + 10; // 여유 공간 추가
                        }

                        rankDatasets = Object.entries(prt.products).map(([asin, product], idx) => ({
                            label: product.name,
                            data: product.ranks.map(r => r || null),
                            borderColor: chartColors[idx % chartColors.length],
                            backgroundColor: idx === 0 ? 'rgba(32,128,128,0.1)' : 'transparent',
                            tension: 0.4,
                            fill: idx === 0,
                            borderWidth: 3
                        }));
                    }
                }

                charts.rankTrend = new Chart(document.getElementById('rankTrendChart').getContext('2d'), {
                    type: 'line',
                    data: { labels: rankLabels, datasets: rankDatasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'top',
                                labels: {
                                    font: { size: 10 },
                                    boxWidth: 12,
                                    padding: 8,
                                    generateLabels: function(chart) {
                                        const datasets = chart.data.datasets;
                                        return datasets.map((ds, i) => {
                                            const fullLabel = ds.label || '';
                                            const shortLabel = fullLabel.length > 30 ? fullLabel.substring(0, 30) + '...' : fullLabel;
                                            return {
                                                text: shortLabel,
                                                fullText: fullLabel,
                                                fillStyle: ds.borderColor || ds.backgroundColor,
                                                strokeStyle: ds.borderColor,
                                                lineWidth: ds.borderWidth || 2,
                                                hidden: !chart.isDatasetVisible(i),
                                                datasetIndex: i
                                            };
                                        });
                                    }
                                },
                                onHover: function(event, legendItem) {
                                    if (legendItem && legendItem.fullText) {
                                        event.native.target.title = legendItem.fullText;
                                        event.native.target.style.cursor = 'pointer';
                                    }
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        return context[0].dataset.label;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: { reverse: true, title: { display: true, text: 'Rank' }, min: 1, max: rankYMax, grid: { color: colors.grid } },
                            x: { grid: { display: false } }
                        }
                    }
                });

                // 제품 매트릭스 버블 차트 - API 데이터만 사용 (하드코딩 fallback 제거)
                let matrixDatasets = [];

                if (dashboardData?.charts?.product_matrix && dashboardData.charts.product_matrix.length > 0) {
                    matrixDatasets = dashboardData.charts.product_matrix.map(product => ({
                        label: product.name,
                        data: [{ x: product.rank, y: product.volatility, r: product.bubble_size }],
                        backgroundColor: product.color
                    }));
                }

                charts.productMatrix = new Chart(document.getElementById('productMatrixChart').getContext('2d'), {
                    type: 'bubble',
                    data: { datasets: matrixDatasets },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        clip: false, // 버블 클리핑 방지
                        layout: {
                            padding: { top: 35, right: 35, bottom: 20, left: 25 }
                        },
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    font: { size: 10 },
                                    boxWidth: 10,
                                    padding: 6,
                                    generateLabels: function(chart) {
                                        const datasets = chart.data.datasets;
                                        return datasets.map((ds, i) => {
                                            // 데이터에서 fullName 가져오기
                                            const fullName = ds.data?.[0]?.fullName || ds.label || '';
                                            const shortLabel = fullName.length > 25 ? fullName.substring(0, 25) + '...' : fullName;
                                            return {
                                                text: shortLabel,
                                                fullText: fullName,
                                                fillStyle: ds.backgroundColor,
                                                strokeStyle: ds.borderColor || ds.backgroundColor,
                                                lineWidth: 1,
                                                hidden: !chart.isDatasetVisible(i),
                                                datasetIndex: i
                                            };
                                        });
                                    }
                                },
                                onHover: function(event, legendItem, legend) {
                                    event.native.target.style.cursor = 'pointer';
                                    if (legendItem && typeof legendItem.datasetIndex === 'number') {
                                        const dataset = legend.chart.data.datasets[legendItem.datasetIndex];
                                        const fullName = dataset?.data?.[0]?.fullName || legendItem.fullText || '';
                                        event.native.target.title = fullName;
                                    }
                                },
                                onLeave: function(event) {
                                    event.native.target.style.cursor = 'default';
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    title: function(context) {
                                        const raw = context[0].raw;
                                        return raw.fullName || context[0].dataset.label;
                                    },
                                    label: function(context) {
                                        const raw = context.raw;
                                        const lines = [
                                            `평균 순위: ${context.parsed.x}위`,
                                            `변동성: ${context.parsed.y.toFixed(1)}`
                                        ];
                                        if (raw.reviewsCount) {
                                            lines.push(`리뷰 수: ${raw.reviewsCount.toLocaleString()}개`);
                                        }
                                        if (raw.avgPrice) {
                                            lines.push(`평균 가격: ${formatPrice(raw.avgPrice)}`);
                                        }
                                        return lines;
                                    },
                                    afterLabel: function(context) {
                                        // 4분면 해석 추가
                                        const x = context.parsed.x;
                                        const y = context.parsed.y;
                                        let quadrant = '';
                                        if (x <= 25 && y <= 15) quadrant = '📍 King: 안정적 상위권';
                                        else if (x <= 25 && y > 15) quadrant = '🚀 Rising: 급부상 중';
                                        else if (x > 25 && y <= 15) quadrant = '⚠️ Lagging: 정체';
                                        else quadrant = '🔴 Risk: 위험';
                                        return quadrant;
                                    }
                                }
                            }
                        },
                        scales: {
                            y: {
                                title: { display: true, text: '순위변동성 ↑' },
                                min: 0,
                                // 데이터 기반 동적 최대값 (데이터 없으면 기본 45)
                                max: matrixDatasets.length > 0 ?
                                    Math.ceil(Math.max(...matrixDatasets.flatMap(d => d.data.map(p => p.y))) * 1.2) : 45,
                                ticks: { stepSize: 5 },
                                grid: { color: colors.grid }
                            },
                            x: {
                                title: { display: true, text: '순위 (← 우수)' },
                                min: 0,
                                // 데이터 기반 동적 최대값 (데이터 없으면 기본 50)
                                max: matrixDatasets.length > 0 ?
                                    Math.ceil(Math.max(...matrixDatasets.flatMap(d => d.data.map(p => p.x))) * 1.2) : 50,
                                ticks: { stepSize: 5 },
                                grid: { color: colors.grid }
                            }
                        }
                    }
                });

                // 할인율 추이 차트 초기화
                initDiscountTrendChart();
            }
        }

        // Product View 초기 데이터 로드
        async function loadInitialProductChartData() {
            const rankStartInput = document.getElementById('rankTrendStartDate');
            const rankEndInput = document.getElementById('rankTrendEndDate');

            if (rankStartInput && rankEndInput && rankStartInput.value && rankEndInput.value) {
                const startDate = rankStartInput.value;
                const endDate = rankEndInput.value;
                console.log('[Init] Loading initial product chart data:', startDate, '~', endDate);

                try {
                    // 순위 추이 차트 업데이트
                    await updateRankTrendChart(startDate, endDate);

                    // 제품 매트릭스 차트 업데이트
                    await updateProductMatrixChart(startDate, endDate);

                    // 할인율 추이 차트 업데이트
                    await updateDiscountTrendChartWithRange(startDate, endDate);

                    const daysDiff = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24));

                    // 성장 유형 분류 데이터 로드
                    await updateGrowthTypeDataWithRange(startDate, endDate, daysDiff);

                    // 경쟁사 프로모션 비교 데이터 로드
                    await updateCompetitorPromoDataWithRange(startDate, endDate, daysDiff);
                } catch (error) {
                    console.error('[Init] Error loading initial chart data:', error);
                }
            }
        }

        // 할인율 추이 차트 초기화
        function initDiscountTrendChart() {
            const ctx = document.getElementById('discountTrendChart');
            if (!ctx) return;

            // 기존 차트가 있으면 제거
            if (charts.discountTrend) {
                charts.discountTrend.destroy();
            }

            // 기본 데이터 (JSON에서 로드하거나 fallback)
            let discountLabels = ['D-6', 'D-5', 'D-4', 'D-3', 'D-2', 'D-1', '오늘'];
            let priceData = [24.00, 24.00, 22.00, 22.00, 22.00, 22.00, 22.00];
            let discountData = [0, 0, 8.3, 8.3, 8.3, 8.3, 8.3];
            let currentDiscount = 8.3;

            // JSON 데이터에서 로드
            if (dashboardData?.charts?.discount_trend) {
                const trend = dashboardData.charts.discount_trend;
                if (trend.labels && trend.labels.length > 0) {
                    discountLabels = trend.labels;
                    priceData = trend.prices || priceData;
                    discountData = trend.discounts || trend.data || discountData;
                    currentDiscount = discountData[discountData.length - 1] || 0;
                }
            }

            // 할인율 배지 업데이트
            const discountBadge = document.getElementById('discount-badge');
            if (discountBadge) {
                discountBadge.textContent = `현재 할인율: ${currentDiscount}%`;
                if (currentDiscount > 10) {
                    discountBadge.style.background = 'rgba(139, 38, 53, 0.1)';
                    discountBadge.style.color = '#8B2635';
                } else if (currentDiscount > 0) {
                    discountBadge.style.background = 'rgba(196, 169, 98, 0.1)';
                    discountBadge.style.color = '#C4A962';
                }
            }

            // 인사이트 메시지
            const insightEl = document.getElementById('discount-insight');
            if (insightEl) {
                if (currentDiscount > 10) {
                    insightEl.textContent = '⚠️ 높은 할인율 - 마진 압박 주의';
                } else if (currentDiscount > 0) {
                    insightEl.textContent = '✓ 적정 할인율 유지 중';
                } else {
                    insightEl.textContent = '📍 정가 판매 중';
                }
            }

            charts.discountTrend = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: discountLabels,
                    datasets: [
                        {
                            label: '판매가 ($)',
                            data: priceData,
                            borderColor: '#1F5795',
                            backgroundColor: 'rgba(31, 87, 149, 0.1)',
                            fill: true,
                            tension: 0.3,
                            yAxisID: 'y',
                            spanGaps: false,  // null 값에서 선 끊기
                            pointRadius: function(context) {
                                return context.raw === null ? 0 : 4;
                            }
                        },
                        {
                            label: '할인율 (%)',
                            data: discountData,
                            borderColor: '#C4A962',
                            backgroundColor: 'rgba(196, 169, 98, 0.1)',
                            borderDash: [5, 5],
                            fill: false,
                            tension: 0.3,
                            yAxisID: 'y1',
                            spanGaps: false,  // null 값에서 선 끊기
                            pointRadius: function(context) {
                                return context.raw === null ? 0 : 4;
                            }
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: { mode: 'index', intersect: false },
                    plugins: {
                        legend: { position: 'top', labels: { font: { size: 11 } } },
                        tooltip: {
                            filter: function(tooltipItem) {
                                return tooltipItem.raw !== null;
                            },
                            callbacks: {
                                label: function(context) {
                                    if (context.raw === null) return null;
                                    if (context.dataset.label.includes('가격') || context.dataset.label.includes('판매가')) {
                                        return `${context.dataset.label}: ${formatPrice(context.parsed.y)}`;
                                    }
                                    return `${context.dataset.label}: ${context.parsed.y}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: { display: true, text: '판매가 ($)' },
                            grid: { color: 'rgba(0,0,0,0.05)' }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: { display: true, text: '할인율 (%)' },
                            min: 0,
                            max: 50,
                            grid: { drawOnChartArea: false }
                        },
                        x: { grid: { display: false } }
                    }
                }
            });
        }

        // ============================================
        // 날짜 범위 선택 기능
        // ============================================

        // 날짜 범위 선택 버튼 이벤트 리스너 초기화
        function initDateRangeSelectors() {
            document.querySelectorAll('.date-range-selector').forEach(selector => {
                const chartType = selector.dataset.chart;
                selector.querySelectorAll('.date-btn').forEach(btn => {
                    btn.addEventListener('click', async function(e) {
                        e.preventDefault();
                        const days = parseInt(this.dataset.days);

                        // 로딩 상태 표시
                        selector.querySelectorAll('.date-btn').forEach(b => b.classList.remove('active'));
                        this.classList.add('active', 'loading');

                        try {
                            await updateChartWithDateRange(chartType, days);
                        } catch (error) {
                            console.error(`Failed to update ${chartType} chart:`, error);
                            showToast(`차트 업데이트 실패: ${error.message}`, 'error');
                        } finally {
                            this.classList.remove('loading');
                        }
                    });
                });
            });

            // CPI 기간 선택 초기화
            initCpiPeriodSelector();
        }

        // CPI 기간 선택 버튼 이벤트 리스너 초기화
        function initCpiPeriodSelector() {
            const selector = document.getElementById('cpiPeriodSelector');
            if (!selector) return;

            const customDateRange = document.getElementById('cpiCustomDateRange');
            const buttons = selector.querySelectorAll('.period-btn');

            buttons.forEach(btn => {
                btn.addEventListener('click', async function(e) {
                    e.preventDefault();
                    const days = this.dataset.days;

                    // 활성화 상태 변경
                    buttons.forEach(b => b.classList.remove('active'));
                    this.classList.add('active');

                    if (days === 'custom') {
                        // 직접설정 선택 시 날짜 입력 필드 표시
                        customDateRange.style.display = 'flex';
                        // 기본값 설정 (현재 선택된 기간)
                        const endDate = new Date();
                        const startDate = new Date();
                        startDate.setDate(startDate.getDate() - 6);
                        document.getElementById('cpiCustomStartDate').value = startDate.toISOString().split('T')[0];
                        document.getElementById('cpiCustomEndDate').value = endDate.toISOString().split('T')[0];
                    } else {
                        // 날짜 입력 필드 숨기기
                        customDateRange.style.display = 'none';

                        // 로딩 상태 표시
                        this.classList.add('loading');

                        try {
                            currentCpiPeriodDays = parseInt(days);
                            await updateCpiChartWithBrandAverage();
                            showToast(`CPI 차트가 ${days}일 기간으로 업데이트되었습니다.`, 'success');
                        } catch (error) {
                            console.error('Failed to update CPI chart:', error);
                            showToast(`CPI 차트 업데이트 실패: ${error.message}`, 'error');
                        } finally {
                            this.classList.remove('loading');
                        }
                    }
                });
            });
        }

        // CPI 직접설정 날짜 적용
        async function applyCpiCustomDateRange() {
            const startDate = document.getElementById('cpiCustomStartDate')?.value;
            const endDate = document.getElementById('cpiCustomEndDate')?.value;

            if (!startDate || !endDate) {
                showToast('시작일과 종료일을 모두 선택해주세요.', 'error');
                return;
            }

            if (new Date(startDate) > new Date(endDate)) {
                showToast('시작일이 종료일보다 늦을 수 없습니다.', 'error');
                return;
            }

            // 기간 계산 (일 수)
            const daysDiff = Math.ceil((new Date(endDate) - new Date(startDate)) / (1000 * 60 * 60 * 24)) + 1;
            if (daysDiff > 90) {
                showToast('최대 90일까지 조회 가능합니다.', 'error');
                return;
            }

            try {
                await updateCpiChartWithBrandAverage(startDate, endDate);
                showToast(`CPI 차트가 ${startDate} ~ ${endDate} 기간으로 업데이트되었습니다.`, 'success');
            } catch (error) {
                console.error('Failed to update CPI chart:', error);
                showToast(`CPI 차트 업데이트 실패: ${error.message}`, 'error');
            }
        }

        // 날짜 범위 계산 (YYYY-MM-DD 형식)
        function getDateRange(days) {
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days + 1);

            const formatDate = (d) => {
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            };

            return {
                start_date: formatDate(start),
                end_date: formatDate(end)
            };
        }

        // Historical API 호출
        async function fetchHistoricalData(startDate, endDate, brand = 'LANEIGE') {
            const url = `${API_BASE}/api/historical?start_date=${startDate}&end_date=${endDate}&brand=${brand}`;
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }

            const data = await response.json();
            if (!data.success) {
                throw new Error(data.error || 'Unknown error');
            }

            // rank_history와 data를 병합하여 반환
            return {
                ...data.data,
                rank_history: data.rank_history,
                available_dates: data.available_dates,
                available_date_range: data.available_date_range,
                data_source: data.data_source,
                brand_metrics: data.brand_metrics
            };
        }

        // 차트별 업데이트 함수
        async function updateChartWithDateRange(chartType, days) {
            const { start_date, end_date } = getDateRange(days);

            switch (chartType) {
                case 'rankTrend':
                    await updateRankTrendChart(start_date, end_date, days);
                    break;
                case 'productMatrix':
                    await updateProductMatrixChart(start_date, end_date, days);
                    break;
                case 'discountTrend':
                    await updateDiscountTrendChartWithRange(start_date, end_date, days);
                    break;
                default:
                    console.warn(`Unknown chart type: ${chartType}`);
            }
        }

        // 전역 변수: 현재 LANEIGE 제품 목록과 선택된 제품
        let currentLaneigeProducts = {};
        let selectedProductNames = [];
        let currentRankHistoryData = null;
        let currentRankLabels = [];

        // 순위 추이 차트 업데이트
        async function updateRankTrendChart(startDate, endDate, days) {
            try {
                console.log('[RankTrend] Fetching data for:', startDate, '~', endDate);
                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('rank-missing-dates', missingDates, totalRequestedDays);

                if (!historicalData || !historicalData.rank_history) {
                    showToast('해당 기간의 순위 데이터가 없습니다.', 'info');
                    return;
                }

                const rankHistory = historicalData.rank_history;
                const labels = Object.keys(rankHistory).sort();
                console.log('[RankTrend] Labels from API:', labels);

                // 데이터 저장 (필터링에서 재사용)
                currentRankHistoryData = rankHistory;
                currentRankLabels = labels;

                // LANEIGE 제품만 필터링하여 제품별 데이터 구성
                const productRanks = {};
                labels.forEach(date => {
                    const dayData = rankHistory[date];
                    if (dayData && dayData.products) {
                        dayData.products
                            .filter(p => p.brand && p.brand.toLowerCase() === 'laneige')
                            .forEach(product => {
                                const name = product.name || product.product_name;
                                if (!name) return;
                                if (!productRanks[name]) {
                                    productRanks[name] = [];
                                }
                                productRanks[name].push({ date, rank: product.rank, price: product.price });
                            });
                    }
                });

                // 전역에 저장
                currentLaneigeProducts = productRanks;

                // LANEIGE 제품이 없으면 경고
                if (Object.keys(productRanks).length === 0) {
                    showToast('해당 기간에 LANEIGE 제품 데이터가 없습니다.', 'warning');
                    return;
                }

                // 제품 선택기 업데이트
                updateProductSelector(productRanks);

                // 선택된 제품이 없으면 전체 표시
                const productsToShow = selectedProductNames.length > 0
                    ? Object.fromEntries(Object.entries(productRanks).filter(([name]) => selectedProductNames.includes(name)))
                    : productRanks;

                // 차트 렌더링
                renderRankTrendChart(labels, productsToShow);

            } catch (error) {
                console.error('Error updating rank trend chart:', error);
                throw error;
            }
        }

        // 제품 선택기 업데이트 (체크박스 드롭다운)
        function updateProductSelector(productRanks) {
            const checkboxList = document.getElementById('productCheckboxList');
            if (!checkboxList) return;

            checkboxList.innerHTML = '';

            // 제품명을 평균 순위로 정렬
            const sortedProducts = Object.entries(productRanks)
                .map(([name, data]) => {
                    const avgRank = data.reduce((sum, d) => sum + d.rank, 0) / data.length;
                    return { name, avgRank };
                })
                .sort((a, b) => a.avgRank - b.avgRank);

            // 체크박스 항목 추가
            sortedProducts.forEach(({ name, avgRank }, idx) => {
                const shortName = name.length > 40 ? name.substring(0, 40) + '...' : name;
                const itemDiv = document.createElement('div');
                itemDiv.className = 'dropdown-item';
                itemDiv.style.cssText = 'padding: 6px 12px; border-bottom: 1px solid #f0f0f0;';
                itemDiv.innerHTML = `
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 12px;">
                        <input type="checkbox" class="product-checkbox" value="${name}" checked onchange="onProductCheckboxChange()" style="width: 14px; height: 14px;">
                        <span style="color: ${chartColors[idx % chartColors.length]}; font-weight: 500;">●</span>
                        <span title="${name}">${shortName}</span>
                        <span style="color: #888; margin-left: auto; font-size: 11px;">${Math.round(avgRank)}위</span>
                    </label>
                `;
                checkboxList.appendChild(itemDiv);
            });

            // 드롭다운 라벨 업데이트
            updateDropdownLabel();
        }

        // 드롭다운 토글
        function toggleProductDropdown() {
            const menu = document.getElementById('productDropdownMenu');
            if (menu) {
                menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
            }
        }

        // 드롭다운 외부 클릭 시 닫기
        document.addEventListener('click', function(e) {
            const dropdown = document.getElementById('productDropdown');
            if (dropdown && !dropdown.contains(e.target)) {
                const menu = document.getElementById('productDropdownMenu');
                if (menu) menu.style.display = 'none';
            }
        });

        // 전체 선택/해제
        function toggleAllProducts(checked) {
            const checkboxes = document.querySelectorAll('.product-checkbox');
            checkboxes.forEach(cb => cb.checked = checked);
            onProductCheckboxChange();
        }

        // 체크박스 변경 시
        function onProductCheckboxChange() {
            updateDropdownLabel();
            applyProductFilter();
        }

        // 드롭다운 라벨 업데이트
        function updateDropdownLabel() {
            const label = document.getElementById('productDropdownLabel');
            const checkboxes = document.querySelectorAll('.product-checkbox');
            const checkedCount = document.querySelectorAll('.product-checkbox:checked').length;
            const totalCount = checkboxes.length;

            if (checkedCount === 0) {
                label.textContent = '선택 없음';
            } else if (checkedCount === totalCount) {
                label.textContent = `전체 제품 (${totalCount}개)`;
                document.getElementById('productSelectAll').checked = true;
            } else {
                label.textContent = `${checkedCount}개 선택됨`;
                document.getElementById('productSelectAll').checked = false;
            }
        }

        // ========== 분리 Y축 (Break Axis) 설정 ==========
        // 하위권 임계값: 이 순위를 초과하면 하위권으로 분류
        const LOWER_RANK_THRESHOLD = 30;
        // 주요 구간 하단 마진 (break 구간 위)
        const MAIN_ZONE_BOTTOM_MARGIN = 5;
        // 하위권 구간 높이 비율 (전체 차트 높이 대비)
        const LOWER_ZONE_RATIO = 0.15;

        // 분리 Y축 상태 저장
        let breakAxisState = {
            enabled: false,
            mainZoneMax: 30,      // 상위권 구간 최대값
            lowerZoneMin: 50,     // 하위권 구간 시작값
            lowerZoneMax: 100,    // 하위권 구간 최대값
            breakPosition: 0.85,  // break 위치 (0~1, 차트 높이 비율)
            lowerRanks: [],       // 하위권 데이터 포인트
            originalData: {}      // 원본 데이터 (툴팁용)
        };

        // IQR 기반 하위권 분리 기준 계산
        function detectLowerRanks(ranks) {
            if (ranks.length < 4) return { threshold: LOWER_RANK_THRESHOLD, lowerRanks: [] };

            const sorted = [...ranks].sort((a, b) => a - b);
            const q1 = sorted[Math.floor(sorted.length * 0.25)];
            const q3 = sorted[Math.floor(sorted.length * 0.75)];
            const iqr = q3 - q1;

            // IQR 기반 임계값 또는 고정 임계값 중 더 관대한 값 사용
            const iqrThreshold = q3 + 1.5 * iqr;
            const threshold = Math.max(LOWER_RANK_THRESHOLD, Math.min(iqrThreshold, 50));

            const lowerRanks = ranks.filter(r => r > threshold);
            return { threshold, lowerRanks };
        }

        // 분리 Y축용 데이터 변환 (하위권을 압축 구간에 매핑)
        function transformDataForBreakAxis(originalRank, state) {
            if (!state.enabled || originalRank === null) return originalRank;

            if (originalRank <= state.mainZoneMax) {
                // 상위권 구간: 그대로 표시
                return originalRank;
            } else {
                // 하위권 구간: 압축하여 표시
                const lowerRange = state.lowerZoneMax - state.lowerZoneMin;
                const normalizedPosition = (originalRank - state.lowerZoneMin) / lowerRange;
                // 압축된 Y값 계산 (mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN 아래에 배치)
                const compressedValue = state.mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN +
                    normalizedPosition * (state.displayLowerRange || 10);
                return compressedValue;
            }
        }

        // Break Axis 플러그인 (물결선 그리기)
        const breakAxisPlugin = {
            id: 'breakAxisPlugin',
            afterDraw: function(chart) {
                if (!breakAxisState.enabled) return;

                const ctx = chart.ctx;
                const yAxis = chart.scales.y;
                const chartArea = chart.chartArea;

                // Break 위치 계산 (상위권과 하위권 구간 사이)
                const breakY = yAxis.getPixelForValue(breakAxisState.mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN / 2);

                if (breakY < chartArea.top || breakY > chartArea.bottom) return;

                const waveHeight = 4;
                const waveWidth = 12;

                ctx.save();

                // 클리핑: 차트 영역 내부만 그리기 (Y축 보호)
                ctx.beginPath();
                ctx.rect(chartArea.left, chartArea.top, chartArea.right - chartArea.left, chartArea.bottom - chartArea.top);
                ctx.clip();

                // 배경 마스킹 (차트 영역 내부만)
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(chartArea.left, breakY - waveHeight - 3, chartArea.right - chartArea.left, waveHeight * 2 + 6);

                // 물결선 그리기 (차트 영역 내부만)
                ctx.strokeStyle = '#aaaaaa';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([]);

                // 상단 물결선
                ctx.beginPath();
                for (let x = chartArea.left; x < chartArea.right; x += waveWidth) {
                    ctx.moveTo(x, breakY - waveHeight);
                    ctx.quadraticCurveTo(x + waveWidth / 4, breakY - waveHeight - 2, x + waveWidth / 2, breakY - waveHeight);
                    ctx.quadraticCurveTo(x + waveWidth * 3 / 4, breakY - waveHeight + 2, x + waveWidth, breakY - waveHeight);
                }
                ctx.stroke();

                // 하단 물결선
                ctx.beginPath();
                for (let x = chartArea.left; x < chartArea.right; x += waveWidth) {
                    ctx.moveTo(x, breakY + waveHeight);
                    ctx.quadraticCurveTo(x + waveWidth / 4, breakY + waveHeight - 2, x + waveWidth / 2, breakY + waveHeight);
                    ctx.quadraticCurveTo(x + waveWidth * 3 / 4, breakY + waveHeight + 2, x + waveWidth, breakY + waveHeight);
                }
                ctx.stroke();

                ctx.restore();

                // Y축 왼쪽에 분리 표시 (클리핑 외부에서 그리기)
                ctx.save();
                ctx.fillStyle = '#1F5795';
                ctx.font = '10px Arial';
                ctx.textAlign = 'right';
                ctx.fillText('···', chartArea.left - 5, breakY + 3);
                ctx.restore();
            }
        };

        // 플러그인 등록 (한 번만)
        if (!Chart.registry.plugins.get('breakAxisPlugin')) {
            Chart.register(breakAxisPlugin);
        }

        // 차트 렌더링 함수 (분리 Y축 지원)
        function renderRankTrendChart(labels, productRanks) {
            const numDays = labels.length;

            // X축 틱 간격 계산 (동적)
            let tickStepSize = 1;
            if (numDays > 21) {
                tickStepSize = 3;
            } else if (numDays > 14) {
                tickStepSize = 2;
            }

            // 날짜 레이블 포맷팅
            const formattedLabels = labels.map(d => {
                const date = new Date(d);
                return `${(date.getMonth() + 1).toString().padStart(2, '0')}-${date.getDate().toString().padStart(2, '0')}`;
            });

            // 모든 순위 데이터 수집
            const allRanks = Object.values(productRanks)
                .flat()
                .map(d => d.rank)
                .filter(r => r !== null && r !== undefined);

            // 하위권 분리 기준 계산
            const { threshold, lowerRanks } = detectLowerRanks(allRanks);
            const hasLowerRanks = lowerRanks.length > 0;

            // 상위권 데이터 (하위권 제외)
            const upperZoneRanks = allRanks.filter(r => r <= threshold);
            const lowerZoneRanks = allRanks.filter(r => r > threshold);

            // 분리 Y축 상태 업데이트
            if (hasLowerRanks && upperZoneRanks.length > 0) {
                breakAxisState.enabled = true;
                breakAxisState.mainZoneMax = Math.max(...upperZoneRanks) + 2;
                breakAxisState.lowerZoneMin = Math.min(...lowerZoneRanks);
                breakAxisState.lowerZoneMax = Math.max(...lowerZoneRanks);
                breakAxisState.displayLowerRange = 8; // 하위권 표시 압축 범위
                breakAxisState.lowerRanks = lowerZoneRanks;
            } else {
                breakAxisState.enabled = false;
            }

            // 원본 데이터 저장 (툴팁용)
            breakAxisState.originalData = {};
            Object.entries(productRanks).forEach(([name, data]) => {
                breakAxisState.originalData[name] = {};
                data.forEach(d => {
                    breakAxisState.originalData[name][d.date] = d.rank;
                });
            });

            // 데이터셋 생성 (하위권 변환 적용)
            const datasets = Object.entries(productRanks).map(([name, data], idx) => {
                const ranks = labels.map(date => {
                    const found = data.find(d => d.date === date);
                    if (!found) return null;
                    const originalRank = found.rank;
                    return transformDataForBreakAxis(originalRank, breakAxisState);
                });

                // 하위권 포인트 스타일 (파란 테두리로 강조)
                const pointStyles = labels.map(date => {
                    const found = data.find(d => d.date === date);
                    if (found && found.rank > threshold) return 'triangle';
                    return 'circle';
                });

                const pointBorderColors = labels.map(date => {
                    const found = data.find(d => d.date === date);
                    if (found && found.rank > threshold) return '#1F5795';  // 하위권은 Amore Blue
                    return chartColors[idx % chartColors.length];
                });

                const pointRadii = labels.map(date => {
                    const found = data.find(d => d.date === date);
                    if (found && found.rank > threshold) return 6;
                    return numDays <= 14 ? 4 : 2;
                });

                return {
                    label: name.length > 45 ? name.substring(0, 45) + '...' : name,
                    fullLabel: name,
                    data: ranks,
                    borderColor: chartColors[idx % chartColors.length],
                    backgroundColor: idx === 0 ? 'rgba(32,128,128,0.1)' : 'transparent',
                    tension: 0.3,
                    fill: idx === 0,
                    borderWidth: 2.5,
                    pointStyle: pointStyles,
                    pointRadius: pointRadii,
                    pointBorderColor: pointBorderColors,
                    pointBorderWidth: labels.map(date => {
                        const found = data.find(d => d.date === date);
                        if (found && found.rank > threshold) return 2;
                        return 1;
                    }),
                    pointHoverRadius: 7,
                    spanGaps: true,
                    segment: {
                        // 하위권으로 이동하는 선분은 점선으로 표시
                        borderDash: ctx => {
                            const p0 = ctx.p0.parsed.y;
                            const p1 = ctx.p1.parsed.y;
                            if (breakAxisState.enabled) {
                                const isP0Lower = p0 > breakAxisState.mainZoneMax;
                                const isP1Lower = p1 > breakAxisState.mainZoneMax;
                                if (isP0Lower !== isP1Lower) return [5, 5];
                            }
                            return undefined;
                        }
                    }
                };
            });

            // Y축 범위 계산
            let rankYMin = 1;
            let rankYMax;

            if (breakAxisState.enabled) {
                // 분리 Y축: 상위권 구간 + 압축된 하위권 구간
                rankYMax = breakAxisState.mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN + breakAxisState.displayLowerRange + 2;
            } else {
                // 일반 모드: 데이터 범위 기반
                if (allRanks.length > 0) {
                    const minRank = Math.min(...allRanks);
                    const maxRank = Math.max(...allRanks);
                    const range = maxRank - minRank;
                    const padding = Math.max(3, Math.ceil(range * 0.1));
                    rankYMin = Math.max(1, minRank - padding);
                    rankYMax = maxRank + padding;
                } else {
                    rankYMax = 100;
                }
            }

            // 차트 업데이트
            if (charts.rankTrend) {
                charts.rankTrend.data.labels = formattedLabels;
                charts.rankTrend.data.datasets = datasets;

                // Y축 동적 설정
                charts.rankTrend.options.scales.y.min = rankYMin;
                charts.rankTrend.options.scales.y.max = rankYMax;

                // Y축 틱 콜백 (하위권 구간은 실제 값 표시)
                charts.rankTrend.options.scales.y.ticks = {
                    ...charts.rankTrend.options.scales.y.ticks,
                    callback: function(value) {
                        if (!breakAxisState.enabled) return value;

                        // 상위권 구간
                        if (value <= breakAxisState.mainZoneMax) {
                            return value;
                        }

                        // Break 구간 근처는 표시 안함
                        if (value > breakAxisState.mainZoneMax &&
                            value < breakAxisState.mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN) {
                            return '';
                        }

                        // 하위권 구간: 역변환하여 실제 값 표시
                        const compressedStart = breakAxisState.mainZoneMax + MAIN_ZONE_BOTTOM_MARGIN;
                        if (value >= compressedStart) {
                            const normalizedPos = (value - compressedStart) / breakAxisState.displayLowerRange;
                            const lowerRange = breakAxisState.lowerZoneMax - breakAxisState.lowerZoneMin;
                            const realValue = breakAxisState.lowerZoneMin + normalizedPos * lowerRange;
                            // 하위권 구간 경계값만 표시
                            if (Math.abs(value - compressedStart) < 1) {
                                return Math.round(breakAxisState.lowerZoneMin) + '+';
                            }
                            if (Math.abs(value - (compressedStart + breakAxisState.displayLowerRange)) < 1) {
                                return Math.round(breakAxisState.lowerZoneMax);
                            }
                        }
                        return '';
                    }
                };

                // 툴팁 콜백 (원본 순위 표시)
                charts.rankTrend.options.plugins.tooltip = {
                    ...charts.rankTrend.options.plugins.tooltip,
                    callbacks: {
                        title: function(context) {
                            return context[0].label;
                        },
                        label: function(context) {
                            const datasetLabel = context.dataset.fullLabel || context.dataset.label;
                            const dateLabel = labels[context.dataIndex];
                            const originalRank = breakAxisState.originalData[datasetLabel]?.[dateLabel];

                            if (originalRank !== undefined) {
                                const isLowerRank = originalRank > breakAxisState.mainZoneMax;
                                const lowerRankMark = isLowerRank ? ' ↓ 하위권' : '';
                                return `${datasetLabel.substring(0, 30)}${datasetLabel.length > 30 ? '...' : ''}: ${originalRank}위${lowerRankMark}`;
                            }
                            return `${datasetLabel}: ${context.parsed.y}위`;
                        }
                    }
                };

                // X축 동적 설정
                charts.rankTrend.options.scales.x.ticks = {
                    ...charts.rankTrend.options.scales.x.ticks,
                    maxTicksLimit: Math.ceil(numDays / tickStepSize) + 1,
                    autoSkip: true,
                    maxRotation: numDays > 14 ? 45 : 0
                };

                charts.rankTrend.update('none');

                // 하위권 순위 정보 표시
                updateLowerRankInfo(lowerZoneRanks, threshold);
            }
        }

        // 하위권 순위 정보 UI 업데이트
        function updateLowerRankInfo(lowerRanks, threshold) {
            const container = document.getElementById('outlier-info');
            if (!container) return;

            if (lowerRanks.length === 0) {
                container.style.display = 'none';
                return;
            }

            container.style.display = 'block';
            container.innerHTML = `
                <div style="display: flex; align-items: center; gap: 8px; padding: 8px 12px;
                            background: linear-gradient(135deg, #e8f4fd 0%, #d1e9f9 100%);
                            border-radius: 6px; border-left: 4px solid #1F5795; font-size: 12px;">
                    <span style="font-size: 16px;">📊</span>
                    <span>
                        <strong>하위권 순위 분리 표시</strong>: ${lowerRanks.length}개 (${lowerRanks.map(r => r + '위').join(', ')})
                        <br><span style="color: #1F5795; font-size: 11px;">상위권(1~${threshold}위) 확대 표시 / 하위권은 하단 압축 구간에 ▲ 마커로 표시</span>
                    </span>
                </div>
            `;
        }

        // 제품 필터 적용 (체크박스 기반)
        function applyProductFilter() {
            const checkboxes = document.querySelectorAll('.product-checkbox:checked');
            selectedProductNames = Array.from(checkboxes).map(cb => cb.value);

            // 현재 데이터로 차트 다시 렌더링
            if (currentLaneigeProducts && Object.keys(currentLaneigeProducts).length > 0) {
                const productsToShow = selectedProductNames.length > 0
                    ? Object.fromEntries(Object.entries(currentLaneigeProducts).filter(([name]) => selectedProductNames.includes(name)))
                    : currentLaneigeProducts;

                renderRankTrendChart(currentRankLabels, productsToShow);
            }
        }

        // 제품 매트릭스 차트 업데이트
        async function updateProductMatrixChart(startDate, endDate, days) {
            try {
                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('matrix-missing-dates', missingDates, totalRequestedDays);

                if (!historicalData || !historicalData.rank_history) {
                    showToast('해당 기간의 데이터가 없습니다.', 'info');
                    return;
                }

                // 버블 차트용 색상 (HEX 형식)
                const bubbleColors = [
                    '#208080', // LANEIGE teal
                    '#1F5795', // Amore blue
                    '#C4A962', // Gold
                    '#8B2635', // Deep red
                    '#4BC0C0', // Teal light
                    '#001C58', // Pacific blue
                    '#9966FF', // Purple
                    '#FF9F40'  // Orange
                ];

                // LANEIGE 제품만 필터링하여 제품별 평균 순위, 변동성, 리뷰 수 계산
                const rankHistory = historicalData.rank_history;
                const productStats = {};

                Object.values(rankHistory).forEach(dayData => {
                    if (dayData && dayData.products) {
                        dayData.products
                            .filter(p => p.brand && p.brand.toLowerCase() === 'laneige')
                            .forEach(product => {
                                const name = product.name || product.product_name;
                                if (!name) return;
                                if (!productStats[name]) {
                                    productStats[name] = { ranks: [], name, reviewsCounts: [], prices: [] };
                                }
                                if (product.rank) {
                                    productStats[name].ranks.push(product.rank);
                                }
                                // 리뷰 수 수집 (최신 값 사용)
                                if (product.reviews_count) {
                                    productStats[name].reviewsCounts.push(product.reviews_count);
                                }
                                // 가격 수집
                                if (product.price) {
                                    productStats[name].prices.push(product.price);
                                }
                            });
                    }
                });

                // LANEIGE 제품이 없으면 경고
                if (Object.keys(productStats).length === 0) {
                    showToast('해당 기간에 LANEIGE 제품 데이터가 없습니다.', 'warning');
                    return;
                }

                // 데이터 계산 (리뷰 수, 가격 포함)
                const bubbleData = Object.values(productStats)
                    .filter(p => p.ranks.length > 0)
                    .map((product, idx) => {
                        const avgRank = product.ranks.reduce((a, b) => a + b, 0) / product.ranks.length;
                        const volatility = product.ranks.length > 1
                            ? Math.sqrt(product.ranks.map(r => Math.pow(r - avgRank, 2)).reduce((a, b) => a + b, 0) / product.ranks.length)
                            : 0;
                        // 최신 리뷰 수 (가장 마지막 값)
                        const reviewsCount = product.reviewsCounts.length > 0
                            ? product.reviewsCounts[product.reviewsCounts.length - 1]
                            : 0;
                        // 평균 가격
                        const avgPrice = product.prices.length > 0
                            ? product.prices.reduce((a, b) => a + b, 0) / product.prices.length
                            : null;
                        return { name: product.name, avgRank, volatility, reviewsCount, avgPrice, idx };
                    });

                // 동적 축 범위 계산 (버블 크기 고려)
                const allRanks = bubbleData.map(d => d.avgRank);
                const allVolatilities = bubbleData.map(d => d.volatility);

                const minRank = Math.min(...allRanks);
                const maxRank = Math.max(...allRanks);
                const maxVolatility = Math.max(...allVolatilities);

                // 버블 크기를 축 범위 기준으로 계산하여 패딩 적용
                // 버블이 그래프 영역 안에 완전히 들어오도록 축 범위 확장
                const dataXRange = maxRank - minRank || 10;
                const dataYRange = maxVolatility || 10;

                // 전체 축 범위 예측 (데이터 + 여유)
                const estimatedXRange = dataXRange + 20;
                const estimatedYRange = dataYRange + 15;

                // 버블 반지름(최대 25px)이 축 범위에서 차지하는 비율
                // 차트 너비 약 500px, 높이 약 350px 기준
                const bubbleRadiusInXUnits = (25 / 500) * estimatedXRange * 1.2;
                const bubbleRadiusInYUnits = (25 / 350) * estimatedYRange * 1.2;

                // 패딩: 버블 반지름 + 추가 여유
                const rankPadding = Math.max(5, bubbleRadiusInXUnits + 2);
                const volPadding = Math.max(5, bubbleRadiusInYUnits + 2);

                // x축: 음수 허용하여 좌측 버블도 완전히 표시
                const xMin = Math.floor(minRank - rankPadding);
                const xMax = Math.ceil(maxRank + rankPadding);
                const yMax = Math.ceil(maxVolatility + volPadding);

                // 버블 차트 데이터셋 생성 (작은 점으로 고정)
                const matrixDatasets = bubbleData.map((item, idx) => {
                    return {
                        label: item.name.length > 40 ? item.name.substring(0, 40) + '...' : item.name,
                        data: [{
                            x: Math.round(item.avgRank * 10) / 10,
                            y: Math.round(item.volatility * 10) / 10,
                            r: 6, // 작은 점 크기 고정
                            reviewsCount: item.reviewsCount,
                            avgPrice: item.avgPrice,
                            fullName: item.name
                        }],
                        backgroundColor: bubbleColors[idx % bubbleColors.length],
                        borderColor: bubbleColors[idx % bubbleColors.length],
                        borderWidth: 1,
                        hoverBackgroundColor: bubbleColors[idx % bubbleColors.length],
                        hoverBorderWidth: 2,
                        hoverRadius: 8
                    };
                });

                // 차트 업데이트
                if (charts.productMatrix && matrixDatasets.length > 0) {
                    charts.productMatrix.data.datasets = matrixDatasets;

                    // 동적 축 설정 (y축은 0부터 시작)
                    charts.productMatrix.options.scales.x.min = Math.max(0, xMin);
                    charts.productMatrix.options.scales.x.max = xMax;
                    charts.productMatrix.options.scales.y.min = 0;
                    charts.productMatrix.options.scales.y.max = Math.max(45, yMax);

                    // y축 간격 정리 (5 단위)
                    charts.productMatrix.options.scales.y.ticks = { stepSize: 5 };
                    charts.productMatrix.options.scales.x.ticks = { stepSize: 5 };

                    // 클리핑 비활성화 + 패딩으로 버블 잘림 방지
                    charts.productMatrix.options.clip = false;
                    charts.productMatrix.options.layout = {
                        padding: { top: 20, right: 25, bottom: 10, left: 15 }
                    };

                    charts.productMatrix.update('none');
                }

                // 브랜드 수와 데이터 포인트 반환
                return {
                    brandCount: bubbleData.length,
                    dataPoints: Object.keys(historicalData.rank_history || {}).length * bubbleData.length
                };

            } catch (error) {
                console.error('Error updating product matrix chart:', error);
                throw error;
            }
        }

        // 할인율 추이 차트 업데이트
        async function updateDiscountTrendChartWithRange(startDate, endDate, days) {
            try {
                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('discount-missing-dates', missingDates, totalRequestedDays);

                if (!historicalData) {
                    showToast('해당 기간의 데이터가 없습니다.', 'info');
                    return;
                }

                const rankHistory = historicalData.rank_history || {};
                const dates = Object.keys(rankHistory).sort();

                // LANEIGE 제품 목록 수집 (드롭다운용)
                const productSet = new Set();
                dates.forEach(date => {
                    const dayData = rankHistory[date];
                    if (dayData && dayData.products) {
                        dayData.products
                            .filter(p => p.brand && p.brand.toLowerCase() === 'laneige')
                            .forEach(p => {
                                const name = p.name || p.product_name;
                                if (name) productSet.add(name);
                            });
                    }
                });

                // 드롭다운 업데이트
                const productSelect = document.getElementById('discountProductSelect');
                const sortedProducts = Array.from(productSet).sort();
                if (productSelect) {
                    const currentValue = productSelect.value;
                    productSelect.innerHTML = '';
                    sortedProducts.forEach((name, idx) => {
                        const shortName = name.length > 50 ? name.substring(0, 50) + '...' : name;
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = shortName;
                        option.title = name;
                        productSelect.appendChild(option);
                    });
                    // 이전 선택 유지 또는 첫 번째 제품 선택
                    if (currentValue && productSet.has(currentValue)) {
                        productSelect.value = currentValue;
                    } else if (sortedProducts.length > 0) {
                        productSelect.value = sortedProducts[0];
                    }
                }

                // 선택된 제품 가져오기
                const selectedProduct = productSelect ? productSelect.value : '';

                const priceData = [];
                const discountData = [];
                const formattedLabels = [];

                dates.forEach(date => {
                    const dayData = rankHistory[date];
                    if (dayData && dayData.products && dayData.products.length > 0) {
                        // LANEIGE 제품 필터링
                        let targetProducts = dayData.products.filter(p =>
                            p.brand && p.brand.toLowerCase() === 'laneige'
                        );

                        // 특정 제품 선택 시 해당 제품만 필터링
                        if (selectedProduct) {
                            targetProducts = targetProducts.filter(p =>
                                (p.name || p.product_name) === selectedProduct
                            );
                        }

                        if (targetProducts.length === 0) {
                            // 날짜는 추가하되 데이터 없음 표시
                            const d = new Date(date);
                            formattedLabels.push(`${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`);
                            priceData.push(null);
                            discountData.push(null);
                            return;
                        }

                        // 가격과 할인율 계산
                        // 원화 오류 데이터 필터링: 2026년 1월 이전 && $100 초과는 원화로 잘못 수집된 데이터
                        const KRW_ERROR_CUTOFF_DATE = new Date('2026-01-06');
                        const USD_PRICE_MAX = 100;
                        const currentDate = new Date(date);
                        const isKrwErrorPeriod = currentDate < KRW_ERROR_CUTOFF_DATE;

                        const prices = targetProducts
                            .map(p => p.price)
                            .filter(p => {
                                if (p === null || p === undefined) return false;
                                // 2026년 1월 이전에만 $100 초과 필터링
                                if (isKrwErrorPeriod && p > USD_PRICE_MAX) return false;
                                return true;
                            });
                        const discounts = targetProducts
                            .filter(p => {
                                if (p.price === null || p.price === undefined) return false;
                                if (isKrwErrorPeriod && p.price > USD_PRICE_MAX) return false;
                                return true;
                            })
                            .map(p => p.discount_percent || 0);

                        // 유효한 USD 가격 데이터가 없으면 null 처리 (원화 데이터만 있는 날)
                        const avgPrice = prices.length > 0
                            ? prices.reduce((a, b) => a + b, 0) / prices.length
                            : null;
                        const avgDiscount = discounts.length > 0
                            ? discounts.reduce((a, b) => a + b, 0) / discounts.length
                            : null;

                        priceData.push(avgPrice);
                        discountData.push(avgDiscount !== null ? Math.round(avgDiscount * 10) / 10 : null);

                        const d = new Date(date);
                        formattedLabels.push(`${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`);
                    } else {
                        // 데이터 없는 날짜도 레이블에 추가 (차트 X축 일관성)
                        const d = new Date(date);
                        formattedLabels.push(`${(d.getMonth() + 1).toString().padStart(2, '0')}/${d.getDate().toString().padStart(2, '0')}`);
                        priceData.push(null);
                        discountData.push(null);
                    }
                });

                // 차트 업데이트
                if (charts.discountTrend && formattedLabels.length > 0) {
                    charts.discountTrend.data.labels = formattedLabels;
                    charts.discountTrend.data.datasets[0].data = priceData;
                    charts.discountTrend.data.datasets[1].data = discountData;
                    charts.discountTrend.update('none');

                    // 누락 데이터 (원화 오류) 알림 표시
                    const nullCount = priceData.filter(p => p === null).length;
                    const missingDatesContainer = document.getElementById('discount-missing-dates');
                    if (missingDatesContainer) {
                        if (nullCount > 0) {
                            const nullDates = formattedLabels.filter((_, idx) => priceData[idx] === null);
                            missingDatesContainer.innerHTML = `
                                <div style="background: rgba(196, 169, 98, 0.1); border-left: 3px solid #C4A962; padding: 8px 12px; margin-bottom: 8px; border-radius: 4px; font-size: 11px;">
                                    <strong>⚠️ ${nullDates.join(', ')}</strong> 날짜의 가격 데이터가 없습니다. (2026.01.06 이전 원화 수집 오류)
                                </div>
                            `;
                            missingDatesContainer.style.display = 'block';
                        } else {
                            missingDatesContainer.style.display = 'none';
                        }
                    }

                    // 현재 할인율 배지 업데이트 (null이 아닌 최신 값 사용)
                    const validDiscounts = discountData.filter(d => d !== null);
                    const validPrices = priceData.filter(p => p !== null);
                    const latestDiscount = validDiscounts.length > 0 ? validDiscounts[validDiscounts.length - 1] : 0;
                    const latestPrice = validPrices.length > 0 ? validPrices[validPrices.length - 1] : null;
                    const discountBadge = document.getElementById('discount-badge');
                    if (discountBadge) {
                        const priceText = latestPrice ? ` (${formatPrice(latestPrice)})` : '';
                        discountBadge.textContent = `현재 할인율: ${latestDiscount}%${priceText}`;
                    }

                    // 인사이트 업데이트
                    const insightEl = document.getElementById('discount-insight');
                    if (insightEl && validDiscounts.length > 1) {
                        const trend = validDiscounts[validDiscounts.length - 1] > validDiscounts[0] ? '상승' :
                                      validDiscounts[validDiscounts.length - 1] < validDiscounts[0] ? '하락' : '유지';
                        insightEl.textContent = `추세: ${trend}`;
                    }
                } else if (formattedLabels.length === 0) {
                    showToast('선택한 제품의 가격 데이터가 없습니다.', 'info');
                }

            } catch (error) {
                console.error('Error updating discount trend chart:', error);
                throw error;
            }
        }

        // 순위 추이 차트 업데이트
        async function updateRankTrendChartWithRange(startDate, endDate, days) {
            try {
                console.log('[DateRange] updateRankTrendChartWithRange:', { startDate, endDate, days });

                // fetchHistoricalData를 직접 호출하는 대신 updateRankTrendChart 사용
                await updateRankTrendChart(startDate, endDate, days);

                console.log(`[DateRange] Rank trend chart updated for ${startDate} to ${endDate}`);
            } catch (error) {
                console.error('[DateRange] Error updating rank trend chart:', error);
                showToast('순위 추이 차트 업데이트 중 오류가 발생했습니다.', 'error');
            }
        }

        // 제품 매트릭스 차트 업데이트
        async function updateProductMatrixChartWithRange(startDate, endDate, days) {
            try {
                console.log('[DateRange] updateProductMatrixChartWithRange:', { startDate, endDate, days });

                // updateProductMatrixChart 함수 호출
                await updateProductMatrixChart(startDate, endDate, days);

                console.log(`[DateRange] Product matrix chart updated for ${startDate} to ${endDate}`);
            } catch (error) {
                console.error('[DateRange] Error updating product matrix chart:', error);
                showToast('제품 매트릭스 차트 업데이트 중 오류가 발생했습니다.', 'error');
            }
        }

        // 성장 유형 데이터 업데이트
        async function updateGrowthTypeDataWithRange(startDate, endDate, days) {
            try {
                console.log('[DateRange] updateGrowthTypeDataWithRange:', { startDate, endDate, days });

                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('growth-missing-dates', missingDates, totalRequestedDays);

                if (!historicalData) {
                    showToast('해당 기간의 데이터가 없습니다.', 'info');
                    return;
                }

                const rankHistory = historicalData.rank_history || {};
                const dates = Object.keys(rankHistory).sort();

                // Top 100에서 모든 제품 수집 (제품별 통계)
                const productStats = {};
                dates.forEach(date => {
                    const dayData = rankHistory[date];
                    if (dayData && dayData.products) {
                        dayData.products.forEach(p => {
                            const name = p.name || p.product_name;
                            if (!name) return;
                            if (!productStats[name]) {
                                productStats[name] = {
                                    name,
                                    brand: p.brand || 'Unknown',
                                    ranks: [],
                                    discounts: [],
                                    hasCoupon: false,
                                    hasDeal: false
                                };
                            }
                            if (p.rank) productStats[name].ranks.push(p.rank);
                            if (p.discount_percent) productStats[name].discounts.push(p.discount_percent);
                            if (p.coupon_text) productStats[name].hasCoupon = true;
                            if (p.deal_badge) productStats[name].hasDeal = true;
                        });
                    }
                });

                // 제품 목록 (평균 순위 기준 정렬, LANEIGE 우선)
                const sortedProducts = Object.values(productStats)
                    .filter(p => p.ranks.length > 0)
                    .map(p => ({
                        ...p,
                        avgRank: p.ranks.reduce((a, b) => a + b, 0) / p.ranks.length,
                        avgDiscount: p.discounts.length > 0 ? p.discounts.reduce((a, b) => a + b, 0) / p.discounts.length : 0
                    }))
                    .sort((a, b) => {
                        const aIsLaneige = a.brand.toLowerCase() === 'laneige';
                        const bIsLaneige = b.brand.toLowerCase() === 'laneige';
                        if (aIsLaneige && !bIsLaneige) return -1;
                        if (!aIsLaneige && bIsLaneige) return 1;
                        return a.avgRank - b.avgRank;
                    });

                // 드롭다운 업데이트
                const productSelect = document.getElementById('growthTypeProductSelect');
                if (productSelect) {
                    const currentSelection = productSelect.value;
                    productSelect.innerHTML = '<option value="">전체 LANEIGE 제품</option>';

                    const laneigProducts = sortedProducts.filter(p => p.brand.toLowerCase() === 'laneige');
                    const otherProducts = sortedProducts.filter(p => p.brand.toLowerCase() !== 'laneige');

                    if (laneigProducts.length > 0) {
                        const laneigGroup = document.createElement('optgroup');
                        laneigGroup.label = '🏆 LANEIGE';
                        laneigProducts.forEach((p) => {
                            const option = document.createElement('option');
                            option.value = p.name;
                            const shortName = p.name.length > 40 ? p.name.substring(0, 40) + '...' : p.name;
                            option.textContent = shortName;
                            option.title = p.name;
                            laneigGroup.appendChild(option);
                        });
                        productSelect.appendChild(laneigGroup);
                    }

                    if (otherProducts.length > 0) {
                        const otherGroup = document.createElement('optgroup');
                        otherGroup.label = '📊 경쟁사 (Top 100)';
                        otherProducts.slice(0, 50).forEach((p) => {
                            const option = document.createElement('option');
                            option.value = p.name;
                            const shortName = p.name.length > 35 ? p.name.substring(0, 35) + '...' : p.name;
                            option.textContent = `[${p.brand}] ${shortName}`;
                            option.title = p.name;
                            otherGroup.appendChild(option);
                        });
                        productSelect.appendChild(otherGroup);
                    }

                    if (currentSelection) {
                        productSelect.value = currentSelection;
                    }
                }

                // 선택된 제품 가져오기 (빈 값이면 LANEIGE 전체)
                let selectedProducts;
                if (productSelect && productSelect.value) {
                    selectedProducts = sortedProducts.filter(p => p.name === productSelect.value);
                } else {
                    selectedProducts = sortedProducts.filter(p => p.brand.toLowerCase() === 'laneige');
                }

                // 성장 유형 분류 계산
                let organicCount = 0;
                let discountBasedCount = 0;
                let organicProducts = [];
                let discountProducts = [];

                selectedProducts.forEach(p => {
                    const isDiscountBased = p.avgDiscount > 15 || p.hasCoupon || p.hasDeal;
                    // 제품명 줄임 (35자)
                    const shortName = p.name.length > 35 ? p.name.substring(0, 35) + '...' : p.name;
                    if (isDiscountBased) {
                        discountBasedCount++;
                        discountProducts.push(shortName);
                    } else {
                        organicCount++;
                        organicProducts.push(shortName);
                    }
                });

                // UI 업데이트 - 숫자
                const organicEl = document.getElementById('organic-count');
                const discountEl = document.getElementById('discount-count');
                if (organicEl) {
                    organicEl.textContent = organicCount > 0 ? `${organicCount}개` : '-';
                }
                if (discountEl) {
                    discountEl.textContent = discountBasedCount > 0 ? `${discountBasedCount}개` : '-';
                }

                // 박스 전체에 툴팁 적용
                const organicBox = document.getElementById('organic-box');
                const discountBox = document.getElementById('discount-box');
                if (organicBox) {
                    organicBox.title = organicProducts.length > 0 ? organicProducts.join('\n') : '';
                    organicBox.style.cursor = organicCount > 0 ? 'help' : 'default';
                }
                if (discountBox) {
                    discountBox.title = discountProducts.length > 0 ? discountProducts.join('\n') : '';
                    discountBox.style.cursor = discountBasedCount > 0 ? 'help' : 'default';
                }

                console.log(`[DateRange] Growth type data updated for ${startDate} to ${endDate}`, { organicCount, discountBasedCount });
            } catch (error) {
                console.error('[DateRange] Error updating growth type data:', error);
                showToast('성장 유형 데이터 업데이트 중 오류가 발생했습니다.', 'error');
            }
        }

        // 경쟁사 프로모션 데이터 업데이트
        async function updateCompetitorPromoDataWithRange(startDate, endDate, days) {
            try {
                console.log('[DateRange] updateCompetitorPromoDataWithRange:', { startDate, endDate, days });

                const historicalData = await fetchHistoricalData(startDate, endDate);

                // 누락된 날짜 확인 및 표시
                const availableDates = historicalData?.available_dates || [];
                const missingDates = findMissingDates(startDate, endDate, availableDates);
                const totalRequestedDays = getDatesBetween(startDate, endDate).length;
                showMissingDatesAlert('competitor-missing-dates', missingDates, totalRequestedDays);

                if (!historicalData) {
                    showToast('해당 기간의 데이터가 없습니다.', 'info');
                    return;
                }

                const rankHistory = historicalData.rank_history || {};
                const dates = Object.keys(rankHistory).sort();

                // Top 100에서 모든 제품 수집 (제품별 통계)
                const productStats = {};
                dates.forEach(date => {
                    const dayData = rankHistory[date];
                    if (dayData && dayData.products) {
                        dayData.products.forEach(p => {
                            const name = p.name || p.product_name;
                            if (!name) return;
                            const key = name; // 제품명을 키로 사용
                            if (!productStats[key]) {
                                productStats[key] = {
                                    name,
                                    brand: p.brand || 'Unknown',
                                    ranks: [],
                                    discounts: [],
                                    hasCoupon: false,
                                    hasSns: false,
                                    couponText: ''
                                };
                            }
                            if (p.rank) productStats[key].ranks.push(p.rank);
                            if (p.discount_percent) productStats[key].discounts.push(p.discount_percent);
                            if (p.coupon_text) {
                                productStats[key].hasCoupon = true;
                                productStats[key].couponText = p.coupon_text;
                            }
                            if (p.is_subscribe_save) productStats[key].hasSns = true;
                        });
                    }
                });

                // 제품 목록 (평균 순위 기준 정렬, LANEIGE 우선)
                const sortedProducts = Object.values(productStats)
                    .filter(p => p.ranks.length > 0)
                    .map(p => ({
                        ...p,
                        avgRank: p.ranks.reduce((a, b) => a + b, 0) / p.ranks.length,
                        avgDiscount: p.discounts.length > 0
                            ? p.discounts.reduce((a, b) => a + b, 0) / p.discounts.length
                            : 0
                    }))
                    .sort((a, b) => {
                        // LANEIGE 제품 우선
                        const aIsLaneige = a.brand.toLowerCase() === 'laneige';
                        const bIsLaneige = b.brand.toLowerCase() === 'laneige';
                        if (aIsLaneige && !bIsLaneige) return -1;
                        if (!aIsLaneige && bIsLaneige) return 1;
                        return a.avgRank - b.avgRank;
                    });

                // 드롭다운 업데이트
                const productSelect = document.getElementById('competitorProductSelect');
                if (productSelect) {
                    const currentSelection = productSelect.value;
                    productSelect.innerHTML = '<option value="">전체 LANEIGE 제품</option>';

                    // LANEIGE 제품 그룹
                    const laneigProducts = sortedProducts.filter(p => p.brand.toLowerCase() === 'laneige');
                    const otherProducts = sortedProducts.filter(p => p.brand.toLowerCase() !== 'laneige');

                    // LANEIGE 옵션 그룹
                    if (laneigProducts.length > 0) {
                        const laneigGroup = document.createElement('optgroup');
                        laneigGroup.label = '🏆 LANEIGE';
                        laneigProducts.forEach((p) => {
                            const option = document.createElement('option');
                            option.value = p.name;
                            const shortName = p.name.length > 40 ? p.name.substring(0, 40) + '...' : p.name;
                            option.textContent = shortName;
                            option.title = p.name;
                            laneigGroup.appendChild(option);
                        });
                        productSelect.appendChild(laneigGroup);
                    }

                    // 경쟁사 옵션 그룹
                    if (otherProducts.length > 0) {
                        const otherGroup = document.createElement('optgroup');
                        otherGroup.label = '📊 경쟁사 (Top 100)';
                        otherProducts.slice(0, 50).forEach((p) => { // 상위 50개만
                            const option = document.createElement('option');
                            option.value = p.name;
                            const shortName = p.name.length > 35 ? p.name.substring(0, 35) + '...' : p.name;
                            option.textContent = `[${p.brand}] ${shortName}`;
                            option.title = p.name;
                            otherGroup.appendChild(option);
                        });
                        productSelect.appendChild(otherGroup);
                    }

                    // 이전 선택 복원
                    if (currentSelection) {
                        productSelect.value = currentSelection;
                    }
                }

                // 선택된 제품 가져오기 (빈 값이면 LANEIGE 전체)
                let selectedProducts;
                if (productSelect && productSelect.value) {
                    selectedProducts = [productSelect.value];
                } else {
                    selectedProducts = sortedProducts.filter(p => p.brand.toLowerCase() === 'laneige').map(p => p.name);
                }

                // 선택된 제품의 프로모션 데이터
                const promoData = selectedProducts.map(productName => {
                    const stats = productStats[productName];
                    if (!stats) return null;
                    const avgRank = stats.ranks.length > 0
                        ? (stats.ranks.reduce((a, b) => a + b, 0) / stats.ranks.length).toFixed(1)
                        : '-';
                    const avgDiscount = stats.discounts.length > 0
                        ? (stats.discounts.reduce((a, b) => a + b, 0) / stats.discounts.length).toFixed(1)
                        : '0.0';
                    return {
                        name: stats.name,
                        brand: stats.brand,
                        avg_rank: parseFloat(avgRank) || 0,
                        avg_discount: parseFloat(avgDiscount),
                        has_coupon: stats.hasCoupon,
                        coupon_text: stats.couponText,
                        has_sns: stats.hasSns
                    };
                }).filter(Boolean);

                // 테이블 업데이트
                updateCompetitorPromoDisplay(promoData);

                console.log(`[DateRange] Competitor promo data updated for ${startDate} to ${endDate}`);
            } catch (error) {
                console.error('[DateRange] Error updating competitor promo data:', error);
                showToast('경쟁사 프로모션 데이터 업데이트 중 오류가 발생했습니다.', 'error');
            }
        }

        // 경쟁사 프로모션 테이블 표시 함수 (제품 단위)
        function updateCompetitorPromoDisplay(promoData) {
            const tbody = document.getElementById('competitor-promo-tbody');
            if (!tbody) return;

            tbody.innerHTML = '';

            if (!promoData || promoData.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" style="text-align: center; color: var(--text-secondary);">선택된 제품이 없습니다.</td></tr>';
                return;
            }

            promoData.forEach(product => {
                const row = document.createElement('tr');
                const isLaneige = product.brand && product.brand.toLowerCase() === 'laneige';
                if (isLaneige) row.classList.add('is-laneige');

                const nameClass = isLaneige ? 'brand-name laneige' : 'brand-name';
                const discountDisplay = product.avg_discount > 0
                    ? product.avg_discount.toFixed(1) + '%'
                    : '<span class="no-data-dash" title="해당 기간에 할인 정보가 수집되지 않았습니다">-</span>';
                const rankDisplay = product.avg_rank
                    ? '#' + product.avg_rank.toFixed(1)
                    : '<span class="no-data-dash" title="해당 기간에 순위 데이터가 없습니다">-</span>';

                const discountBadge = product.avg_discount > 15 ?
                    `<span class="discount-badge" style="font-size: 9px; padding: 2px 6px; margin-left: 4px;">🔥</span>` : '';

                const couponDisplay = product.has_coupon
                    ? `<span title="${product.coupon_text || '쿠폰'}">🎟️</span>`
                    : '<span class="no-data-dash" title="해당 기간에 쿠폰 적용 이력이 없습니다">-</span>';

                const snsDisplay = product.has_sns
                    ? '✓'
                    : '<span class="no-data-dash" title="Subscribe & Save 미적용 제품입니다">-</span>';

                // 제품명 줄임 (20자)
                const shortName = product.name.length > 25
                    ? product.name.substring(0, 25) + '...'
                    : product.name;

                row.innerHTML = `
                    <td class="${nameClass}" title="${product.name}" style="max-width: 180px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${shortName}</td>
                    <td class="num-cell" style="font-size: 11px;">${product.brand}</td>
                    <td class="num-cell">${rankDisplay}</td>
                    <td class="num-cell discount-cell">${discountDisplay}${discountBadge}</td>
                    <td class="num-cell">${couponDisplay}</td>
                    <td class="num-cell">${snsDisplay}</td>
                `;
                tbody.appendChild(row);
            });
        }

        // 차트 색상 정의
        const chartColors = [
            'rgba(32, 128, 128, 0.9)',   // LANEIGE teal
            'rgba(31, 87, 149, 0.9)',    // Amore blue
            'rgba(196, 169, 98, 0.9)',   // Gold
            'rgba(139, 38, 53, 0.9)',    // Deep red
            'rgba(75, 192, 192, 0.9)',   // Teal light
            'rgba(54, 162, 235, 0.9)',   // Blue
            'rgba(255, 159, 64, 0.9)',   // Orange
            'rgba(153, 102, 255, 0.9)'   // Purple
        ];

        // 시간 포맷 함수 (KST 기준)
        function formatDateTime(isoString) {
            if (!isoString) return '없음';

            // 타임존 정보가 없으면 KST(+09:00)로 간주
            let dateStr = isoString;
            if (!isoString.includes('+') && !isoString.includes('Z')) {
                dateStr = isoString + '+09:00';
            }

            const date = new Date(dateStr);

            // KST로 표시 (UTC+9)
            const kstOffset = 9 * 60; // 분 단위
            const localOffset = date.getTimezoneOffset(); // 분 단위 (UTC - 로컬)
            const kstDate = new Date(date.getTime() + (kstOffset + localOffset) * 60 * 1000);

            const year = kstDate.getFullYear();
            const month = String(kstDate.getMonth() + 1).padStart(2, '0');
            const day = String(kstDate.getDate()).padStart(2, '0');
            const hours = String(kstDate.getHours()).padStart(2, '0');
            const minutes = String(kstDate.getMinutes()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}`;
        }

        function formatCurrentTime() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
        }

        // 실시간 시계 시작
        function startClock() {
            function updateClock() {
                const timeValue = document.getElementById('time-value');
                if (timeValue) {
                    timeValue.textContent = formatCurrentTime();
                }
            }
            updateClock(); // 즉시 실행
            setInterval(updateClock, 1000); // 1초마다 업데이트
        }

        // 데이터 업데이트 시간 표시
        function updateDataTime() {
            const dateValue = document.getElementById('date-value');
            if (!dateValue) return;

            if (dashboardData && dashboardData.metadata) {
                const generatedAt = dashboardData.metadata.generated_at;
                dateValue.textContent = formatDateTime(generatedAt);
            } else {
                dateValue.textContent = '없음';
            }
        }

        window.onload = async function() {
            startClock(); // 실시간 시계 시작
            await loadDashboardData();
            updateDataTime(); // 데이터 시간 업데이트
            switchPage('home');
            loadAlertSettings(); // 알림 설정 로드
            initDateRangeSelectors(); // 날짜 범위 선택 초기화

            // 글로벌 날짜 범위로 초기 차트 데이터 로드
            await loadInitialChartDataWithGlobalRange();
        };

        // 글로벌 날짜 범위로 초기 차트 데이터 로드
        async function loadInitialChartDataWithGlobalRange() {
            const { startDate, endDate } = globalDateRange.get();

            if (!startDate || !endDate) {
                console.log('[GlobalDateRange] No initial date range set, skipping initial load');
                return;
            }

            console.log('[GlobalDateRange] Loading initial chart data:', startDate, '~', endDate);

            try {
                // Home 페이지 차트 (SoS 추이) 초기 로드
                await updateSosTrendWithGlobalRange(startDate, endDate);

                console.log('[GlobalDateRange] Initial chart data loaded successfully');
            } catch (error) {
                console.error('[GlobalDateRange] Error loading initial chart data:', error);
            }
        }

        // ============================
        // Alert Settings (알림 설정)
        // ============================
        function openAlertSettings() {
            const modal = document.getElementById('alert-settings-modal');
            if (modal) {
                modal.style.display = 'flex';
                loadAlertSettings();
            }
        }

        function closeAlertSettings() {
            const modal = document.getElementById('alert-settings-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function loadAlertSettings() {
            try {
                const response = await fetch(`${API_BASE}/api/v3/alert-settings`);
                if (response.ok) {
                    const data = await response.json();

                    // 이메일 입력
                    document.getElementById('alert-email').value = data.email || '';

                    // 동의 체크박스
                    document.getElementById('alert-consent').checked = data.consent || false;

                    // 알림 유형 체크박스
                    const alertTypes = data.alert_types || [];
                    document.getElementById('alert-rank-change').checked = alertTypes.includes('rank_change');
                    document.getElementById('alert-insight').checked = alertTypes.includes('important_insight');
                    document.getElementById('alert-error').checked = alertTypes.includes('error');
                    document.getElementById('alert-daily').checked = alertTypes.includes('daily_summary');

                    // 동의 상태에 따라 체크박스 활성화/비활성화
                    toggleAlertOptions();
                }
            } catch (error) {
                console.error('Failed to load alert settings:', error);
            }
        }

        function toggleAlertOptions() {
            const consent = document.getElementById('alert-consent').checked;
            const options = document.querySelectorAll('.alert-type-option input');
            options.forEach(opt => {
                opt.disabled = !consent;
            });
        }

        // 이메일 인증 상태 관리
        let emailVerificationState = {
            verified: false,
            email: null,
            token: null
        };

        // 이메일 인증 요청
        async function sendVerificationEmail() {
            const email = document.getElementById('alert-email').value.trim();
            const btn = document.getElementById('verify-email-btn');
            const statusDiv = document.getElementById('email-verification-status');
            const pendingSpan = document.getElementById('verification-pending');
            const successSpan = document.getElementById('verification-success');
            const errorSpan = document.getElementById('verification-error');
            const errorMsg = document.getElementById('verification-error-msg');

            // 이메일 형식 검증
            const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
            if (!email || !emailRegex.test(email)) {
                statusDiv.style.display = 'block';
                pendingSpan.style.display = 'none';
                successSpan.style.display = 'none';
                errorSpan.style.display = 'inline';
                errorMsg.textContent = '올바른 이메일 주소를 입력해주세요.';
                return;
            }

            // 버튼 비활성화 및 로딩 상태
            btn.disabled = true;
            btn.textContent = '발송 중...';

            try {
                const response = await fetch(`${API_BASE}/api/alerts/send-verification`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({ email: email })
                });

                const data = await response.json();

                statusDiv.style.display = 'block';

                if (response.ok) {
                    pendingSpan.style.display = 'inline';
                    successSpan.style.display = 'none';
                    errorSpan.style.display = 'none';
                    btn.textContent = '재발송';
                    emailVerificationState.email = email;
                    emailVerificationState.token = data.token;

                    // 아이콘 초기화
                    if (window.lucide) lucide.createIcons();
                } else {
                    pendingSpan.style.display = 'none';
                    successSpan.style.display = 'none';
                    errorSpan.style.display = 'inline';
                    errorMsg.textContent = data.detail || '인증 이메일 발송 실패';
                    btn.textContent = '인증하기';
                }
            } catch (error) {
                console.error('Email verification error:', error);
                statusDiv.style.display = 'block';
                pendingSpan.style.display = 'none';
                successSpan.style.display = 'none';
                errorSpan.style.display = 'inline';
                errorMsg.textContent = '서버 연결 오류';
                btn.textContent = '인증하기';
            }

            btn.disabled = false;
        }

        // 이메일 인증 상태 확인 (페이지 로드 시 URL 파라미터 체크)
        function checkEmailVerification() {
            const urlParams = new URLSearchParams(window.location.search);
            const verifyToken = urlParams.get('verify_email');
            const verifyEmail = urlParams.get('email');

            if (verifyToken && verifyEmail) {
                // URL에서 인증 토큰 발견 시 서버에 검증 요청
                verifyEmailToken(verifyToken, verifyEmail);
            }
        }

        // 이메일 토큰 검증
        async function verifyEmailToken(token, email) {
            try {
                const response = await fetch(`${API_BASE}/api/alerts/verify-email`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({ token: token, email: email })
                });

                const data = await response.json();

                if (response.ok && data.verified) {
                    // 인증 성공 - 모달 열고 성공 상태 표시
                    openAlertSettings();
                    setTimeout(() => {
                        const statusDiv = document.getElementById('email-verification-status');
                        const pendingSpan = document.getElementById('verification-pending');
                        const successSpan = document.getElementById('verification-success');
                        const errorSpan = document.getElementById('verification-error');

                        statusDiv.style.display = 'block';
                        pendingSpan.style.display = 'none';
                        successSpan.style.display = 'inline';
                        errorSpan.style.display = 'none';

                        emailVerificationState.verified = true;
                        emailVerificationState.email = email;

                        // 아이콘 초기화
                        if (window.lucide) lucide.createIcons();

                        // URL에서 파라미터 제거
                        window.history.replaceState({}, document.title, window.location.pathname);
                    }, 300);
                } else {
                    alert('이메일 인증 실패: ' + (data.detail || '토큰이 만료되었거나 유효하지 않습니다.'));
                }
            } catch (error) {
                console.error('Email verification error:', error);
            }
        }

        // 페이지 로드 시 인증 체크
        document.addEventListener('DOMContentLoaded', checkEmailVerification);

        async function saveAlertSettings() {
            const email = document.getElementById('alert-email').value;
            const consent = document.getElementById('alert-consent').checked;

            // 이메일 형식 검증
            if (consent && email) {
                const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
                if (!emailRegex.test(email)) {
                    alert('올바른 이메일 주소를 입력해주세요.');
                    return;
                }
            }

            // 알림 유형 수집
            const alertTypes = [];
            if (document.getElementById('alert-rank-change').checked) alertTypes.push('rank_change');
            if (document.getElementById('alert-insight').checked) alertTypes.push('important_insight');
            if (document.getElementById('alert-error').checked) alertTypes.push('error');
            if (document.getElementById('alert-daily').checked) alertTypes.push('daily_summary');

            try {
                const response = await fetch(`${API_BASE}/api/v3/alert-settings`, {
                    method: 'POST',
                    headers: getApiHeaders(),
                    body: JSON.stringify({
                        email: email,
                        consent: consent,
                        alert_types: alertTypes
                    })
                });

                if (response.ok) {
                    alert('알림 설정이 저장되었습니다.');
                    closeAlertSettings();
                } else {
                    const error = await response.json();
                    alert('저장 실패: ' + (error.detail || '알 수 없는 오류'));
                }
            } catch (error) {
                console.error('Failed to save alert settings:', error);
                alert('저장 중 오류가 발생했습니다.');
            }
        }

        async function revokeConsent() {
            if (!confirm('이메일 알림 수신 동의를 철회하시겠습니까?')) {
                return;
            }

            try {
                const response = await fetch(`${API_BASE}/api/v3/alert-settings/revoke`, {
                    method: 'POST',
                    headers: getApiHeaders()
                });

                if (response.ok) {
                    alert('동의가 철회되었습니다.');
                    loadAlertSettings();
                }
            } catch (error) {
                console.error('Failed to revoke consent:', error);
            }
        }

    </script>

    <!-- Alert Settings Modal - AMOREPACIFIC CI -->
    <div id="alert-settings-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content" style="max-width: 520px;">
            <div class="modal-header">
                <h3><i data-lucide="bell" style="width: 20px; height: 20px; display: inline;"></i> 알림 설정</h3>
                <button onclick="closeAlertSettings()" class="modal-close">&times;</button>
            </div>
            <div class="modal-body" style="padding: 24px;">
                <!-- 이메일 입력 + 인증 버튼 -->
                <div class="form-group" style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: var(--pacific-blue);">
                        이메일 주소
                    </label>
                    <div style="display: flex; gap: 10px;">
                        <input type="email" id="alert-email"
                               placeholder="your-email@example.com"
                               style="flex: 1; padding: 12px 16px; border: 1px solid #e2e8f0; border-radius: 10px; font-size: 14px; transition: border-color 0.2s;"
                               onfocus="this.style.borderColor='var(--amore-blue)'"
                               onblur="this.style.borderColor='#e2e8f0'">
                        <button onclick="sendVerificationEmail()" id="verify-email-btn"
                                style="padding: 12px 20px; background: var(--amore-blue); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s; white-space: nowrap;">
                            인증하기
                        </button>
                    </div>
                    <!-- 인증 상태 표시 -->
                    <div id="email-verification-status" style="margin-top: 8px; font-size: 13px; display: none;">
                        <span id="verification-pending" style="color: #f59e0b; display: none;">
                            <i data-lucide="clock" style="width: 14px; height: 14px; display: inline; vertical-align: -2px;"></i>
                            인증 이메일이 발송되었습니다. 메일함을 확인해주세요.
                        </span>
                        <span id="verification-success" style="color: #10b981; display: none;">
                            <i data-lucide="check-circle" style="width: 14px; height: 14px; display: inline; vertical-align: -2px;"></i>
                            이메일 인증 완료
                        </span>
                        <span id="verification-error" style="color: #ef4444; display: none;">
                            <i data-lucide="x-circle" style="width: 14px; height: 14px; display: inline; vertical-align: -2px;"></i>
                            <span id="verification-error-msg">인증 실패</span>
                        </span>
                    </div>
                </div>

                <!-- 동의 체크박스 (AMOREPACIFIC CI) -->
                <div class="consent-box" style="background: rgba(31, 87, 149, 0.05); border: 1px solid rgba(31, 87, 149, 0.2); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                    <label style="display: flex; align-items: flex-start; gap: 12px; cursor: pointer;">
                        <input type="checkbox" id="alert-consent" onchange="toggleAlertOptions()"
                               style="width: 20px; height: 20px; margin-top: 2px; accent-color: var(--amore-blue);">
                        <div>
                            <span style="font-weight: 600; color: var(--pacific-blue);">이메일 알림 수신에 동의합니다</span>
                            <p style="font-size: 12px; color: #64748b; margin-top: 4px;">
                                순위 변동, 중요 인사이트, 시스템 에러 등의 알림을 이메일로 받습니다.<br>
                                언제든지 동의를 철회할 수 있습니다.
                            </p>
                        </div>
                    </label>
                </div>

                <!-- 알림 유형 선택 -->
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 12px; color: var(--pacific-blue);">
                        알림 유형 선택
                    </label>
                    <div class="alert-type-options" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <label class="alert-type-option" style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: #f8fafc; border-radius: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s;">
                            <input type="checkbox" id="alert-rank-change" disabled style="accent-color: var(--amore-blue);">
                            <span style="font-size: 13px; color: var(--pacific-blue);">순위 변동</span>
                        </label>
                        <label class="alert-type-option" style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: #f8fafc; border-radius: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s;">
                            <input type="checkbox" id="alert-insight" disabled style="accent-color: var(--amore-blue);">
                            <span style="font-size: 13px; color: var(--pacific-blue);">중요 인사이트</span>
                        </label>
                        <label class="alert-type-option" style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: #f8fafc; border-radius: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s;">
                            <input type="checkbox" id="alert-error" disabled style="accent-color: var(--amore-blue);">
                            <span style="font-size: 13px; color: var(--pacific-blue);">에러 알림</span>
                        </label>
                        <label class="alert-type-option" style="display: flex; align-items: center; gap: 8px; padding: 10px 12px; background: #f8fafc; border-radius: 8px; cursor: pointer; border: 1px solid transparent; transition: all 0.2s;">
                            <input type="checkbox" id="alert-daily" disabled style="accent-color: var(--amore-blue);">
                            <span style="font-size: 13px; color: var(--pacific-blue);">일일 요약</span>
                        </label>
                    </div>
                </div>

                <!-- 버튼 -->
                <div style="display: flex; gap: 12px;">
                    <button onclick="saveAlertSettings()" id="save-alert-btn"
                            style="flex: 1; padding: 12px 20px; background: linear-gradient(135deg, var(--pacific-blue), var(--amore-blue)); color: white; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        저장
                    </button>
                    <button onclick="revokeConsent()"
                            style="padding: 12px 20px; background: #fee2e2; color: #dc2626; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        동의 철회
                    </button>
                    <button onclick="closeAlertSettings()"
                            style="padding: 12px 20px; background: #f1f5f9; color: #64748b; border: none; border-radius: 10px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                        취소
                    </button>
                </div>
            </div>
        </div>
    </div>

    <style>
        /* Alert Settings Modal - AMOREPACIFIC CI 통일 */
        #alert-settings-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 28, 88, 0.4);
            align-items: center;
            justify-content: center;
            z-index: 10000;
            backdrop-filter: blur(4px);
        }
        #alert-settings-modal .modal-content {
            background: white;
            border-radius: 16px;
            box-shadow: 0 20px 60px rgba(0, 28, 88, 0.25);
            max-height: 90vh;
            overflow-y: auto;
            animation: modalSlideIn 0.3s ease;
        }
        @keyframes modalSlideIn {
            from { opacity: 0; transform: scale(0.95) translateY(-20px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        #alert-settings-modal .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 24px;
            border-bottom: 1px solid rgba(31, 87, 149, 0.15);
            background: linear-gradient(135deg, rgba(0, 28, 88, 0.03), rgba(31, 87, 149, 0.05));
        }
        #alert-settings-modal .modal-header h3 {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 18px;
            font-weight: 700;
            color: var(--pacific-blue);
        }
        #alert-settings-modal .modal-close {
            width: 32px;
            height: 32px;
            border: none;
            background: rgba(31, 87, 149, 0.1);
            border-radius: 8px;
            font-size: 20px;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--pacific-blue);
        }
        #alert-settings-modal .modal-close:hover {
            background: rgba(31, 87, 149, 0.2);
        }
        #alert-settings-modal .alert-type-option:hover {
            border-color: var(--amore-blue);
            background: rgba(31, 87, 149, 0.05);
        }
        #alert-settings-modal button:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(0, 28, 88, 0.15);
        }
        #verify-email-btn:hover {
            background: var(--pacific-blue) !important;
        }
        #verify-email-btn:disabled {
            background: #94a3b8 !important;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }
    </style>
</body>
</html>
